<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description></description>
    <link>https://lovetoken.github.io/</link>
    <atom:link href="https://lovetoken.github.io/sitemap.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 09 May 2017 22:06:25 +0900</pubDate>
    <lastBuildDate>Tue, 09 May 2017 22:06:25 +0900</lastBuildDate>
    <generator>Jekyll v3.1.6</generator>
    
      <item>
        <title>온라인 설문지 서비스 Typeform 소개, 설문조사 방법에 대한 설문조사</title>
        <description>&lt;p&gt;평범한 일상생활 속에서도 사람의 생각과 의견을 수렴할 일들은 참 많이 일어난다.&lt;br /&gt;
필자의 경우 학창시절을 돌이켜 볼 때 통계관련 수업시 툭하면 마주하는 프로젝트가 &amp;quot;설문조사&amp;quot; 와 관련된 것이었다.&lt;br /&gt;
이때마다 설문지를 워드나 한글로 타이핑하고 굳이 출력해서 손수 나눠준 후 일일이 되돌려 받는 형식의 설문조사가 일방적으로 이루어졌다.&lt;br /&gt;
설문지를 취합해서 코딩과 펀칭을 하는 수고는 즐겁기도 하면서 손이 많이 가고 큰 정성을 필요로 했다.&lt;br /&gt;
반대로 설문지를 응답하는 상황에서도 이러한 형태의 설문조사방식을 많이 겪는 편인 것 같다.&lt;/p&gt;
&lt;p&gt;설문조사자로서의 입장, 그리고 설문응답자로서의 입장들을 겪을 때마다 느껴지는 질문은&lt;br /&gt;
&amp;quot;의견을 온전하게 전달하고 받을 수 있는 최선의 방법은 무엇일까?&amp;quot; 이다.&lt;br /&gt;
소통은 &lt;strong&gt;말하는 사람&lt;/strong&gt;과 &lt;strong&gt;듣는 사람&lt;/strong&gt; 그리고 &lt;strong&gt;전달 매체(언어)&lt;/strong&gt; 이렇게 3가지 요소가 있는데&lt;br /&gt;
설문조사 측면에선 &lt;strong&gt;조사자&lt;/strong&gt;, &lt;strong&gt;응답자&lt;/strong&gt;, 그리고 &lt;strong&gt;조사방법&lt;/strong&gt; 이렇게 3가지 요소와 비슷하다고 생각한다.&lt;br /&gt;
소통에서 전달 매체의 선택이 잘못될 경우 소통이 불가하다.&lt;br /&gt;
이처럼 설문조사에서 조사방법을 잘 선택하고 설계하는 것은 중요한 문제이다.&lt;/p&gt;
&lt;p&gt;그런 의미에서 여러 시도를 해보고 있다.&lt;br /&gt;
지금까지도 많이 쓰이는 전통적인 종이 설문지 배포 및 수거 방법 외에 다른 방법들이 무엇이 있을까 찾아보고 있고&lt;br /&gt;
좀 더 현명한 방법은 무엇일지 실험을 해보고 있다.&lt;/p&gt;
&lt;p&gt;그중 최근 한 실험은 &lt;a href=&quot;https://www.typeform.com&quot;&gt;Typeform&lt;/a&gt; 과 같은 툴을 이용해 온라인 설문조사 방식이다.&lt;br /&gt;
아래는 Typeform 서비스의 힘을 빌려 만들어 본 설문지이다.&lt;br /&gt;
주제는 이글과 연관있는 &amp;quot;설문조사 방법에 대한 설문조사&amp;quot; 이다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;통계 R 프로그래밍 카페에 배포한 온라인 설문지 (관심있다면 설문응답 해주셔도 됩니다)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;typeform-widget&quot; data-url=&quot;https://lovetoken.typeform.com/to/oQCtip&quot; style=&quot;width: 100%; height: 1100px;&quot;&gt;

&lt;/div&gt;
&lt;script&gt;(function(){var qs,js,q,s,d=document,gi=d.getElementById,ce=d.createElement,gt=d.getElementsByTagName,id=&quot;typef_orm&quot;,b=&quot;https://s3-eu-west-1.amazonaws.com/share.typeform.com/&quot;;if(!gi.call(d,id)){js=ce.call(d,&quot;script&quot;);js.id=id;js.src=b+&quot;widget.js&quot;;q=gt.call(d,&quot;script&quot;)[0];q.parentNode.insertBefore(js,q)}})()&lt;/script&gt;
&lt;div style=&quot;font-family: Sans-Serif;font-size: 12px;color: #999;opacity: 0.5; padding-top: 5px;&quot;&gt;
powered by &lt;a href=&quot;https://www.typeform.com/examples/?utm_campaign=oQCtip&amp;amp;utm_source=typeform.com-7938314-Basic&amp;amp;utm_medium=typeform&amp;amp;utm_content=typeform-embedded-poweredbytypeform&amp;amp;utm_term=KO&quot; style=&quot;color: #999&quot; target=&quot;_blank&quot;&gt;Typeform&lt;/a&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;위와 같이 온라인 설문조사를 직접 만들고 배포를 도와주는 서비스는 여러 가지가 있다.&lt;/p&gt;
&lt;p&gt;가장 대중적인 &lt;a href=&quot;https://www.google.com/intl/ko_kr/forms/about/&quot;&gt;Google docs&lt;/a&gt; 부터 시작해 &lt;a href=&quot;https://ko.surveymonkey.com&quot;&gt;Surveymonkey&lt;/a&gt;, &lt;a href=&quot;https://www.mysurveyasia.co.kr&quot;&gt;Mysurvey&lt;/a&gt;, &lt;a href=&quot;https://www.typeform.com&quot;&gt;Typeform&lt;/a&gt; 등이 있으며&lt;br /&gt;
국내서비스로는 &lt;a href=&quot;http://www.nownsurvey.com&quot;&gt;나우서베이&lt;/a&gt;, &lt;a href=&quot;http://www.ozsurvey.co.kr&quot;&gt;오즈서베이&lt;/a&gt; 등이 있다.&lt;/p&gt;
&lt;p&gt;이 중에서 가장 최근에 서비스를 시작한(2014년)&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; Typeform 의 인기가 요즘 높다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;typeform-소개&quot;&gt;Typeform 소개&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Typeform.com Explainer Video&lt;/p&gt;
&lt;/blockquote&gt;
&lt;iframe width=&quot;100%&quot; height=&quot;350&quot; src=&quot;https://www.youtube.com/embed/5ghyOrFDdaY&quot; frameborder=&quot;0&quot; allowfullscreen&gt;
&lt;/iframe&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;온라인 설문서비스는 딱히 설명할 필요가 없을 정도로 GUI 가 매우 잘 되어있는 편이다.&lt;br /&gt;
&amp;quot;선 배움 후 실습&amp;quot; 이 아닌 &amp;quot;선 실습 후 배움&amp;quot; 이 가능한 서비스이다. 쉽기 때문에 이게 가능하다.&lt;br /&gt;
Typeform 역시 마찬가지이다. 가입 후에 로그인하는 즉시 웹상에서 동작한다.&lt;br /&gt;
이것저것 만져보고 단순한 설문문서를 만들어 보자.&lt;br /&gt;
필자가 만든 위 설문지 역시 &lt;a href=&quot;https://www.typeform.com/tour/&quot;&gt;공식 홈페이지의 튜토리얼&lt;/a&gt;을 1분도 안 보고 만든 첫 설문지이다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/tf1.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/tf2.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;설문 문항은 드래그 &amp;amp; 드랍 방식으로 원하는 곳에 배치할 수 있고&lt;br /&gt;
작은 글과 응답 유형별로 제공되는 메뉴를 통해 손쉽게 만들 수 있다.&lt;br /&gt;
구조적인 설문지가 아닌 이상 Multiple choice 기능만으로 설문지를 만드는데 아무 문제가 없을 것이다.&lt;/p&gt;
&lt;p&gt;만드는 즉시 설문지를 배포할 수 있는 링크가 생긴다.&lt;br /&gt;
그 링크는 상단에 Build, Design, Configure, Share, Analyze 5개의 메뉴 중 Share 로 들어가 보면&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/tf3.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;copy 버튼을 눌러 링크를 이용할 수 있다.&lt;br /&gt;
이 링크를 통해 언제 어디서든 응답자에게 설문지를 배포하고 시간과 장소 제약 없이 응답할 수 있게 된다.&lt;/p&gt;
&lt;p&gt;만약 응답자가 링크를 클릭 후 설문에 응답하여 제출버튼을 누른다면&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/tf4.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;설문지를 만든 관리자는&lt;br /&gt;
그 응답자의 결과뿐만 아니라 지금까지 모든 응답에 대해 취합한 report 를 Analyze 메뉴를 통해 확인할 수 있다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/tf5.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;취합결과 역시 &lt;a href=&quot;https://lovetoken.typeform.com/report/oQCtip/vVGD&quot;&gt;여기처럼&lt;/a&gt; 외부링크를 뽑아올 수 있어 공유가 가능하다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/tf6.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;Design 메뉴를 통해 설문지의 템플릿을 원하는 것으로 바꿀 수 있다.&lt;br /&gt;
클릭 몇 번만으로 수려한 디자인의 설문지를 만들 수 있겠다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/tf7.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/tf8.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;이정도만 알아도 사실 다 안 것이고 설문조사를 하는데 아무 문제 없다.&lt;br /&gt;
단 구조화된 설문지(조건부 별로 다른 조사항목이 출현하는 예), 응답완료에 대한 확인메일송신 기능, 파일 업로드 기능 활성화, 응답 및 조사항목 제한해제등을 위해선 요금을 내고 Pro upgrade 를 해야한다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;온라인-설문의-대중화&quot;&gt;온라인 설문의 대중화&lt;/h2&gt;
&lt;p&gt;전통적인 설문방법(설문지를 출력해서 손수 나눠준 후 되돌려 받는 형식)과 온라인 설문방법은 각기 장단점이 존재한다.&lt;br /&gt;
전통적인 설문방법의 장점은 누구든지 쉽게 떠올릴 수 있는 방법이고 펜과 종이만 있으면 가능하다.&lt;br /&gt;
상황에 따라 면대면으로 심층적인 설문을 할 수 있다.&lt;br /&gt;
무엇보다 가장 큰 장점은 전통적이라는 의미에는 전혀 거부감이 없다는 의미를 내포한다는 점에 있다.&lt;/p&gt;
&lt;p&gt;온라인 설문의 장점은 비대면 방식의 특징으로 생기는 것들에 있다.&lt;br /&gt;
설문조사자의 눈치를 보지 않고 언제 어디서든 자유롭게 응답할 수 있기 때문에 오히려 왜곡되지 않는 온전한 의견을 조사자가 응답받을 수도 있다.&lt;br /&gt;
간편한 방법을 통해 응답회수율을 높일 수 있으며,&lt;br /&gt;
응답 이후 관리 측면에서는 전통적인 설문방법과 비교될 수 없는 높은 생산성을 가지고 있다.&lt;/p&gt;
&lt;p&gt;이처럼 각자의 장점들이 있다.&lt;br /&gt;
그런데 (Typeform 서비스를 예로 들었지만 이러한) 온라인 설문 서비스를 알기 전에는 편의성이 얼마나 높은지 인지할 수 없었다.&lt;br /&gt;
그리고 인터넷 매체의 발전에 힘입어 온라인 설문은 자연스럽게 대중화되었고 많은 사람이 채택하는 방법이 되었다.&lt;br /&gt;
필자는 수백명 단위의 응답자와 종이 설문지들에 파묻혀 온 시간을 쏟아 리서치를 한 경험이 많았는데&lt;br /&gt;
자괴감을 많이 느낄 정도로 온라인 설문은 큰 강점을 가지고 있음을 뒤늦게 깨달은 것 같다.&lt;/p&gt;
&lt;p&gt;대세는 거스를 수 없다. 대중화되는 이유를 살펴보고 이용해 봄으로써 새로운 방법을 인지하고 싶다면,&lt;br /&gt;
특히 리서치를 사서 고생하는 느낌이 든다면 이러한 서비스를 적극적으로 사용해 보길 추천하고 싶다.&lt;/p&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;&lt;a href=&quot;https://thenextweb.com/apps/2014/02/12/typeform/#.tnw_KfglfLLI&quot;&gt;Steve O&#39;Hear (September 23, 2014). &amp;quot;Online Survey And Form Builder Typeform Raises €1.2M&amp;quot;.&lt;/a&gt;&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Thu, 04 May 2017 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/etc/2017/05/04/Typeform.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/etc/2017/05/04/Typeform.html</guid>
        
        
        <category>etc</category>
        
      </item>
    
      <item>
        <title>R에서 caret package 를 이용한 데이터 학습 간편화 전략</title>
        <description>&lt;p&gt;기계학습(Machine Learning) 에서 기법이 무엇이 되든, 어떤 알고리즘을 사용할 것이든 공통으로 필요한 과정은 &amp;quot;Learning&amp;quot; 즉 &amp;quot;학습&amp;quot;이다.&lt;br /&gt;
학습의 대상은 전통적으로 훈련데이터(Training dataset)이고, 훈련데이터를 학습시키는 아주 다양한 방법들이 존재한다.&lt;br /&gt;
방법별로 특징과 색깔이 완전히 다르며, 무엇보다 &lt;strong&gt;워낙 다양한 방법들이 존재하기 때문&lt;/strong&gt;에 아무리 많이 공부를 한 사람이라 한들 모든 알고리즘을 아는것이 한계가 있다고 생각한다.&lt;br /&gt;
때문에 무엇을 채택해서 어느 정도의 파라미터값을 부여해야 알맞은 모델을 만들 수 있을지 현실적인 문제에 부딪히게 된다.&lt;/p&gt;
&lt;p&gt;R에서 배포되고 있는 머신러닝 관련 패키지의 개수는 &lt;a href=&quot;https://cran.r-project.org/web/views/MachineLearning.html&quot;&gt;CRAN Task View: Machine Learning &amp;amp; Statistical Learning&lt;/a&gt;만을 보아도 수십개가 된다.&lt;br /&gt;
이 패키지들을 모두 하나하나 실행해서 상황에 맞는 모델링을 하기 위해 비교실험을 해보는 것도 가능할 것이다.&lt;br /&gt;
하지만 패키지별로 사용방식이 많이 다를 수 있어 이를 인지하는데도 많은 시간이 걸리고, 비교해보고 싶은 알고리즘의 패키지를 찾아 설치하고 로드하는 것 마저 부담으로 다가올 수 있겠다.&lt;/p&gt;
&lt;p&gt;이러한 상황에서 caret 패키지는 예측모델을 만들기 위한 데이터 학습 시 간편한 함수를 제공해 준다.&lt;br /&gt;
특히 금일&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;기준 242개의 머신러닝 알고리즘을 표준화된 인터페이스를 통해 테스트 해 볼 수 있도록 준비가 되어 있고,&lt;br /&gt;
이에 대해서 다양한 파라미터 시나리오를 구성해 손쉽게 튜닝해주고 변수의 중요도를 측정해준다.&lt;br /&gt;
사용자는 편리한 훈련데이터의 학습을 통해 적절한 알고리즘 선택 의사결정에 도움을 받을 수 있다.&lt;/p&gt;
&lt;p&gt;이러한 기대효과를 가진 caret package 에 대해 소개하는 시간을 가져보도록 하겠다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/caret.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;caret 패키지의 명칭은 &amp;quot;&lt;strong&gt;C&lt;/strong&gt;lassification &lt;strong&gt;A&lt;/strong&gt;nd &lt;strong&gt;RE&lt;/strong&gt;gression &lt;strong&gt;T&lt;/strong&gt;raining&amp;quot; 의 앞글자를 따와 명명되었다.&lt;br /&gt;
주 관심 대상이 되는 종속변수(예측변수)가 명목형 변수라면 &amp;quot;Classification&amp;quot;, 연속형 변수라면 &amp;quot;Regression&amp;quot; 으로 갈피를 잡아 &amp;quot;Training&amp;quot; 을 하게 될 텐데, 이 과정을 caret 패키지를 이용해 코딩해 본 가장 간단한 예제로 시작해 보겠다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(tidyverse) &lt;span class=&quot;co&quot;&gt;# for tidy tools (pipe operation, tibble, etc..)&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(caret)

&lt;span class=&quot;kw&quot;&gt;set.seed&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1234&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# for reproducibility&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt;(Sonar, &lt;span class=&quot;dt&quot;&gt;package =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;mlbench&amp;quot;&lt;/span&gt;)
Sonar &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;Sonar %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;tbl_df
Sonar&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 208 x 61
##        V1     V2     V3     V4     V5     V6     V7     V8     V9    V10
## *   &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;
## 1  0.0200 0.0371 0.0428 0.0207 0.0954 0.0986 0.1539 0.1601 0.3109 0.2111
## 2  0.0453 0.0523 0.0843 0.0689 0.1183 0.2583 0.2156 0.3481 0.3337 0.2872
## 3  0.0262 0.0582 0.1099 0.1083 0.0974 0.2280 0.2431 0.3771 0.5598 0.6194
## 4  0.0100 0.0171 0.0623 0.0205 0.0205 0.0368 0.1098 0.1276 0.0598 0.1264
## 5  0.0762 0.0666 0.0481 0.0394 0.0590 0.0649 0.1209 0.2467 0.3564 0.4459
## 6  0.0286 0.0453 0.0277 0.0174 0.0384 0.0990 0.1201 0.1833 0.2105 0.3039
## 7  0.0317 0.0956 0.1321 0.1408 0.1674 0.1710 0.0731 0.1401 0.2083 0.3513
## 8  0.0519 0.0548 0.0842 0.0319 0.1158 0.0922 0.1027 0.0613 0.1465 0.2838
## 9  0.0223 0.0375 0.0484 0.0475 0.0647 0.0591 0.0753 0.0098 0.0684 0.1487
## 10 0.0164 0.0173 0.0347 0.0070 0.0187 0.0671 0.1056 0.0697 0.0962 0.0251
## # ... with 198 more rows, and 51 more variables: V11 &amp;lt;dbl&amp;gt;, V12 &amp;lt;dbl&amp;gt;,
## #   V13 &amp;lt;dbl&amp;gt;, V14 &amp;lt;dbl&amp;gt;, V15 &amp;lt;dbl&amp;gt;, V16 &amp;lt;dbl&amp;gt;, V17 &amp;lt;dbl&amp;gt;, V18 &amp;lt;dbl&amp;gt;,
## #   V19 &amp;lt;dbl&amp;gt;, V20 &amp;lt;dbl&amp;gt;, V21 &amp;lt;dbl&amp;gt;, V22 &amp;lt;dbl&amp;gt;, V23 &amp;lt;dbl&amp;gt;, V24 &amp;lt;dbl&amp;gt;,
## #   V25 &amp;lt;dbl&amp;gt;, V26 &amp;lt;dbl&amp;gt;, V27 &amp;lt;dbl&amp;gt;, V28 &amp;lt;dbl&amp;gt;, V29 &amp;lt;dbl&amp;gt;, V30 &amp;lt;dbl&amp;gt;,
## #   V31 &amp;lt;dbl&amp;gt;, V32 &amp;lt;dbl&amp;gt;, V33 &amp;lt;dbl&amp;gt;, V34 &amp;lt;dbl&amp;gt;, V35 &amp;lt;dbl&amp;gt;, V36 &amp;lt;dbl&amp;gt;,
## #   V37 &amp;lt;dbl&amp;gt;, V38 &amp;lt;dbl&amp;gt;, V39 &amp;lt;dbl&amp;gt;, V40 &amp;lt;dbl&amp;gt;, V41 &amp;lt;dbl&amp;gt;, V42 &amp;lt;dbl&amp;gt;,
## #   V43 &amp;lt;dbl&amp;gt;, V44 &amp;lt;dbl&amp;gt;, V45 &amp;lt;dbl&amp;gt;, V46 &amp;lt;dbl&amp;gt;, V47 &amp;lt;dbl&amp;gt;, V48 &amp;lt;dbl&amp;gt;,
## #   V49 &amp;lt;dbl&amp;gt;, V50 &amp;lt;dbl&amp;gt;, V51 &amp;lt;dbl&amp;gt;, V52 &amp;lt;dbl&amp;gt;, V53 &amp;lt;dbl&amp;gt;, V54 &amp;lt;dbl&amp;gt;,
## #   V55 &amp;lt;dbl&amp;gt;, V56 &amp;lt;dbl&amp;gt;, V57 &amp;lt;dbl&amp;gt;, V58 &amp;lt;dbl&amp;gt;, V59 &amp;lt;dbl&amp;gt;, V60 &amp;lt;dbl&amp;gt;,
## #   Class &amp;lt;fctr&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;예제에 사용할 데이터셋은 &lt;code&gt;mlbench::Sonar&lt;/code&gt; 을 이용해보겠으며 예측대상변수는 &lt;code&gt;Class&lt;/code&gt; 라는 명칭의 명목형으로 M, R 2개의 이분값이 담겨있다.&lt;br /&gt;
이를 예측하는 다양한 모델을 만들어 볼 것이다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;createdatapartition-함수&quot;&gt;&lt;code&gt;createDataPartition()&lt;/code&gt; 함수&lt;/h2&gt;
&lt;p&gt;첫번째로 훈련데이터셋(Training dataset)과 테스트데이터셋(Test dataset)을 나누어 추후에 모델평가에 이용할 준비를 해보겠다. 비율은 70%를 훈련데이터셋에 배정하겠다.&lt;br /&gt;
&lt;code&gt;sample()&lt;/code&gt; 함수를 이용해 훈련데이터셋과 테스트데이터셋의 파티셔닝을 해 볼 수 있지만&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;indexTrain &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;sample&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;kw&quot;&gt;nrow&lt;/span&gt;(Sonar), &lt;span class=&quot;kw&quot;&gt;round&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;nrow&lt;/span&gt;(Sonar) *&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;.&lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;))
training &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;Sonar[ indexTrain, ]
testing  &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;Sonar[-indexTrain, ]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;caret 패키지에 있는 &lt;code&gt;createDataPartition()&lt;/code&gt; 함수를 이용해 볼 수도 있다.&lt;br /&gt;
이 함수에는 &lt;code&gt;p&lt;/code&gt; 인자가 있어 특정비율로 파티셔닝할 때 편하다.&lt;br /&gt;
단 반환되는 타입이 기본적으로 list 이므로 &lt;code&gt;list&lt;/code&gt; 인자값을 &lt;code&gt;FALSE&lt;/code&gt;로 해 보았다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;indexTrain &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;createDataPartition&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;kw&quot;&gt;nrow&lt;/span&gt;(Sonar), &lt;span class=&quot;dt&quot;&gt;p =&lt;/span&gt; .&lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;list =&lt;/span&gt; F)
training &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;Sonar[ indexTrain, ]
testing  &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;Sonar[-indexTrain, ]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;7:3 비율만큼 잘 파티셔닝이 되어있는지 확인해 보면&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;training&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 148 x 61
##        V1     V2     V3     V4     V5     V6     V7     V8     V9    V10
##     &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;
## 1  0.0262 0.0582 0.1099 0.1083 0.0974 0.2280 0.2431 0.3771 0.5598 0.6194
## 2  0.0100 0.0171 0.0623 0.0205 0.0205 0.0368 0.1098 0.1276 0.0598 0.1264
## 3  0.0286 0.0453 0.0277 0.0174 0.0384 0.0990 0.1201 0.1833 0.2105 0.3039
## 4  0.0519 0.0548 0.0842 0.0319 0.1158 0.0922 0.1027 0.0613 0.1465 0.2838
## 5  0.0223 0.0375 0.0484 0.0475 0.0647 0.0591 0.0753 0.0098 0.0684 0.1487
## 6  0.0164 0.0173 0.0347 0.0070 0.0187 0.0671 0.1056 0.0697 0.0962 0.0251
## 7  0.0039 0.0063 0.0152 0.0336 0.0310 0.0284 0.0396 0.0272 0.0323 0.0452
## 8  0.0123 0.0309 0.0169 0.0313 0.0358 0.0102 0.0182 0.0579 0.1122 0.0835
## 9  0.0090 0.0062 0.0253 0.0489 0.1197 0.1589 0.1392 0.0987 0.0955 0.1895
## 10 0.0298 0.0615 0.0650 0.0921 0.1615 0.2294 0.2176 0.2033 0.1459 0.0852
## # ... with 138 more rows, and 51 more variables: V11 &amp;lt;dbl&amp;gt;, V12 &amp;lt;dbl&amp;gt;,
## #   V13 &amp;lt;dbl&amp;gt;, V14 &amp;lt;dbl&amp;gt;, V15 &amp;lt;dbl&amp;gt;, V16 &amp;lt;dbl&amp;gt;, V17 &amp;lt;dbl&amp;gt;, V18 &amp;lt;dbl&amp;gt;,
## #   V19 &amp;lt;dbl&amp;gt;, V20 &amp;lt;dbl&amp;gt;, V21 &amp;lt;dbl&amp;gt;, V22 &amp;lt;dbl&amp;gt;, V23 &amp;lt;dbl&amp;gt;, V24 &amp;lt;dbl&amp;gt;,
## #   V25 &amp;lt;dbl&amp;gt;, V26 &amp;lt;dbl&amp;gt;, V27 &amp;lt;dbl&amp;gt;, V28 &amp;lt;dbl&amp;gt;, V29 &amp;lt;dbl&amp;gt;, V30 &amp;lt;dbl&amp;gt;,
## #   V31 &amp;lt;dbl&amp;gt;, V32 &amp;lt;dbl&amp;gt;, V33 &amp;lt;dbl&amp;gt;, V34 &amp;lt;dbl&amp;gt;, V35 &amp;lt;dbl&amp;gt;, V36 &amp;lt;dbl&amp;gt;,
## #   V37 &amp;lt;dbl&amp;gt;, V38 &amp;lt;dbl&amp;gt;, V39 &amp;lt;dbl&amp;gt;, V40 &amp;lt;dbl&amp;gt;, V41 &amp;lt;dbl&amp;gt;, V42 &amp;lt;dbl&amp;gt;,
## #   V43 &amp;lt;dbl&amp;gt;, V44 &amp;lt;dbl&amp;gt;, V45 &amp;lt;dbl&amp;gt;, V46 &amp;lt;dbl&amp;gt;, V47 &amp;lt;dbl&amp;gt;, V48 &amp;lt;dbl&amp;gt;,
## #   V49 &amp;lt;dbl&amp;gt;, V50 &amp;lt;dbl&amp;gt;, V51 &amp;lt;dbl&amp;gt;, V52 &amp;lt;dbl&amp;gt;, V53 &amp;lt;dbl&amp;gt;, V54 &amp;lt;dbl&amp;gt;,
## #   V55 &amp;lt;dbl&amp;gt;, V56 &amp;lt;dbl&amp;gt;, V57 &amp;lt;dbl&amp;gt;, V58 &amp;lt;dbl&amp;gt;, V59 &amp;lt;dbl&amp;gt;, V60 &amp;lt;dbl&amp;gt;,
## #   Class &amp;lt;fctr&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;testing&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 60 x 61
##        V1     V2     V3     V4     V5     V6     V7     V8     V9    V10
##     &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;
## 1  0.0200 0.0371 0.0428 0.0207 0.0954 0.0986 0.1539 0.1601 0.3109 0.2111
## 2  0.0453 0.0523 0.0843 0.0689 0.1183 0.2583 0.2156 0.3481 0.3337 0.2872
## 3  0.0762 0.0666 0.0481 0.0394 0.0590 0.0649 0.1209 0.2467 0.3564 0.4459
## 4  0.0317 0.0956 0.1321 0.1408 0.1674 0.1710 0.0731 0.1401 0.2083 0.3513
## 5  0.0079 0.0086 0.0055 0.0250 0.0344 0.0546 0.0528 0.0958 0.1009 0.1240
## 6  0.0124 0.0433 0.0604 0.0449 0.0597 0.0355 0.0531 0.0343 0.1052 0.2120
## 7  0.0126 0.0149 0.0641 0.1732 0.2565 0.2559 0.2947 0.4110 0.4983 0.5920
## 8  0.0473 0.0509 0.0819 0.1252 0.1783 0.3070 0.3008 0.2362 0.3830 0.3759
## 9  0.0099 0.0484 0.0299 0.0297 0.0652 0.1077 0.2363 0.2385 0.0075 0.1882
## 10 0.0151 0.0320 0.0599 0.1050 0.1163 0.1734 0.1679 0.1119 0.0889 0.1205
## # ... with 50 more rows, and 51 more variables: V11 &amp;lt;dbl&amp;gt;, V12 &amp;lt;dbl&amp;gt;,
## #   V13 &amp;lt;dbl&amp;gt;, V14 &amp;lt;dbl&amp;gt;, V15 &amp;lt;dbl&amp;gt;, V16 &amp;lt;dbl&amp;gt;, V17 &amp;lt;dbl&amp;gt;, V18 &amp;lt;dbl&amp;gt;,
## #   V19 &amp;lt;dbl&amp;gt;, V20 &amp;lt;dbl&amp;gt;, V21 &amp;lt;dbl&amp;gt;, V22 &amp;lt;dbl&amp;gt;, V23 &amp;lt;dbl&amp;gt;, V24 &amp;lt;dbl&amp;gt;,
## #   V25 &amp;lt;dbl&amp;gt;, V26 &amp;lt;dbl&amp;gt;, V27 &amp;lt;dbl&amp;gt;, V28 &amp;lt;dbl&amp;gt;, V29 &amp;lt;dbl&amp;gt;, V30 &amp;lt;dbl&amp;gt;,
## #   V31 &amp;lt;dbl&amp;gt;, V32 &amp;lt;dbl&amp;gt;, V33 &amp;lt;dbl&amp;gt;, V34 &amp;lt;dbl&amp;gt;, V35 &amp;lt;dbl&amp;gt;, V36 &amp;lt;dbl&amp;gt;,
## #   V37 &amp;lt;dbl&amp;gt;, V38 &amp;lt;dbl&amp;gt;, V39 &amp;lt;dbl&amp;gt;, V40 &amp;lt;dbl&amp;gt;, V41 &amp;lt;dbl&amp;gt;, V42 &amp;lt;dbl&amp;gt;,
## #   V43 &amp;lt;dbl&amp;gt;, V44 &amp;lt;dbl&amp;gt;, V45 &amp;lt;dbl&amp;gt;, V46 &amp;lt;dbl&amp;gt;, V47 &amp;lt;dbl&amp;gt;, V48 &amp;lt;dbl&amp;gt;,
## #   V49 &amp;lt;dbl&amp;gt;, V50 &amp;lt;dbl&amp;gt;, V51 &amp;lt;dbl&amp;gt;, V52 &amp;lt;dbl&amp;gt;, V53 &amp;lt;dbl&amp;gt;, V54 &amp;lt;dbl&amp;gt;,
## #   V55 &amp;lt;dbl&amp;gt;, V56 &amp;lt;dbl&amp;gt;, V57 &amp;lt;dbl&amp;gt;, V58 &amp;lt;dbl&amp;gt;, V59 &amp;lt;dbl&amp;gt;, V60 &amp;lt;dbl&amp;gt;,
## #   Class &amp;lt;fctr&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;훈련데이터셋이 148개, 테스트데이터셋이 60개로 잘 나누어진 것을 볼 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;머신러닝-알고리즘별-최적의-모수를-찾기-위한-학습방법-사전-설정&quot;&gt;머신러닝 알고리즘별 최적의 모수를 찾기 위한 학습방법 사전 설정&lt;/h2&gt;
&lt;p&gt;K 최근접 이웃모델 즉 KNN(K-Neareast Neighbors) 을 통해 명목변수를 예측하려 한다면&lt;br /&gt;
그 이전에 선행되어야 할 것이 &amp;quot;K&amp;quot; 를 몇개로 설정할 것이냐이다.&lt;br /&gt;
랜덤포레스트(RandomForest) 를 이용하려 한다면 노드를 나눌 기준으로 고려할 변수의 개수인 &amp;quot;mtry&amp;quot; 를 얼마로 정해야 할지도 마찬가지이다.&lt;br /&gt;
위의 예시에서 &amp;quot;K&amp;quot;, &amp;quot;mtry&amp;quot; 와 같은 모수는 예비조사를 통해 사람이 정하거나, 데이터에 근거해 최적의 군집개수를 정하는 과정을 통해 (방법이 어떻게 되었든) 정해져야 모델링을 할 수 있다. (단 비모수적 모델링이라면 제외되는 이야기이겠다)&lt;br /&gt;
이처럼 알고리즘 별로 반드시 정해져야 모델링을 실시 할 수 있는 모수들을 caret package 에선 &amp;quot;Tuning parameters&amp;quot; 로 설명하고 있고, LOOCV, K-fold cross validation 등과 같은 방법을 통해서 데이터에 근거한 최적의 parameter 를 찾는 과정을 거친다.&lt;/p&gt;
&lt;p&gt;알고리즘별로 튜닝 파라미터 개수는 달라지는데 p개의 파라미터일 경우 &lt;span class=&quot;math inline&quot;&gt;3&lt;sup&gt;&lt;em&gt;P&lt;/em&gt;&lt;/sup&gt;&lt;/span&gt; 의 그리드를 탐색하여 후보모델들을 테스트하게 된다.&lt;/p&gt;
&lt;p&gt;예를 들면 이렇다.&lt;br /&gt;
KNN(K-Neareast Neighbors) 는 K 하나인 단모수이므로 &lt;span class=&quot;math inline&quot;&gt;3&lt;sup&gt;1&lt;/sup&gt; = 3&lt;/span&gt; 인 3가지 K 값들을 후보로 두고 모델을 비교하게 된다.&lt;br /&gt;
RRLDA(Robust Regularized Linear Discriminant Analysis) 의 경우 모수의 개수가 lambda, hp, penalty 총 3개인데 &lt;span class=&quot;math inline&quot;&gt;3&lt;sup&gt;3&lt;/sup&gt; = 27&lt;/span&gt; 인 27가지 후보를 비교하게 될 것이다.&lt;/p&gt;
&lt;p&gt;3개이던 27개 이던 다수의 후보에 대해서 비교하는 방식 또한 고려대상이다.&lt;br /&gt;
후보의 비교방법을 K-fold cross validation 으로 한다고 할 경우 몇번을 접어 cross validation 을 할 것이냐 란 질문의 K 를 정해야 한다.&lt;br /&gt;
caret 패키지에선 &lt;code&gt;trainControl()&lt;/code&gt; 함수를 통해 일관된 비교방법을 각 후보에게 통일되게 적용하여 평가할 수 있게 도와준다.&lt;/p&gt;
&lt;p&gt;아래 코드는 10-fold cross validation 을 5번 반복하여 가장 좋은 후보의 파라미터 그리드를 찾게 해주는 일종의 장치를 만드는 코드이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;fitControl &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;trainControl&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;method =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;repeatedcv&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;number =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;repeats =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이렇게 만들어진 비교방법에 대한 정보가 담겨있는 &lt;code&gt;fitControl&lt;/code&gt; 객체는 추후에 학습 과정에서 사용하게 될 것이다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;randomforest-로-학습시켜보기&quot;&gt;RandomForest 로 학습시켜보기&lt;/h2&gt;
&lt;p&gt;본격적으로 훈련데이터셋을 이용해 학습을 시켜보겠다.&lt;br /&gt;
학습을 위한 표준화된 인터페이스는 바로 &lt;code&gt;train()&lt;/code&gt; 함수이다.&lt;br /&gt;
이함수에서 &lt;code&gt;method&lt;/code&gt; 인자만 바꿔주면 원하는 학습모델 알고리즘을 구현할 수 있게 된다.&lt;/p&gt;
&lt;p&gt;아래 코드는 랜덤포레스트를 통해 훈련데이터셋을 학습하는 코드다.&lt;br /&gt;
랜덤포레스트 알고리즘을 통해 학습할 것을 &lt;code&gt;method = &amp;quot;rf&amp;quot;&lt;/code&gt; 를 통해 선언한다.&lt;br /&gt;
랜덤포레스트에서 Tuning parameter 에 해당되는 &amp;quot;mtry&amp;quot; 는 10-fold cross validation 을 5번 반복하여 가장 좋게 평가된 것을 선택하는 후보채택방법인 &lt;code&gt;fitControl&lt;/code&gt; 객체를 &lt;code&gt;trControl&lt;/code&gt; 인자에 입력한다.&lt;br /&gt;
&lt;code&gt;verbose&lt;/code&gt; 인자는 기본적으로 &lt;code&gt;TRUE&lt;/code&gt; 로 설정되어 있는데 &amp;quot;mtry&amp;quot; 선정과정이 적나라하게 모두 출력된다.&lt;br /&gt;
이 출력을 막고싶었기 때문에 &lt;code&gt;FALSE&lt;/code&gt; 로 해제하였다.&lt;/p&gt;
&lt;p&gt;더해서 랜덤포레스트를 알고리즘을 이용하기 위한 원 소스인 randomForest 패키지 여부를 먼저 확인하는 과정이 있으므로&lt;br /&gt;
만약 randomForest 패키지가 없다면 설치를 시도할 것인지를 물어볼 것이다. 이럴땐 패키지를 설치하겠다는 의미인 &amp;quot;1&amp;quot;을 입력하면 설치 이후 학습을 연이어 진행한다.&lt;a href=&quot;#fn2&quot; class=&quot;footnoteRef&quot; id=&quot;fnref2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;rf_fit &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;train&lt;/span&gt;(Class ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;., &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; training, &lt;span class=&quot;dt&quot;&gt;method =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;rf&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;trControl =&lt;/span&gt; fitControl, &lt;span class=&quot;dt&quot;&gt;verbose =&lt;/span&gt; F)
rf_fit&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## Random Forest 
## 
## 148 samples
##  60 predictor
##   2 classes: &amp;#39;M&amp;#39;, &amp;#39;R&amp;#39; 
## 
## No pre-processing
## Resampling: Cross-Validated (10 fold, repeated 5 times) 
## Summary of sample sizes: 133, 133, 133, 133, 133, 133, ... 
## Resampling results across tuning parameters:
## 
##   mtry  Accuracy   Kappa    
##    2    0.8401905  0.6762815
##   31    0.7969524  0.5898194
##   60    0.7793333  0.5547874
## 
## Accuracy was used to select the optimal model using  the largest value.
## The final value used for the model was mtry = 2.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;mtry 후보는 2, 31, 60 개로 자동설정된 것을 볼 수 있고, 이 중 Kappa 통계량과 정확도에 의해서 mtry = 2 가 최종적으로 선정된 것을 볼 수 있다.&lt;br /&gt;
선정과정을 자세하게 보고 싶을 경우엔 &lt;code&gt;verbose = F&lt;/code&gt; 를 삭제하고 실행해 보면 좋을 수도 있겠다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;테스트셋에-적용하여-정확도-확인&quot;&gt;테스트셋에 적용하여 정확도 확인&lt;/h2&gt;
&lt;p&gt;보통 훈련데이터셋을 이용해 모델 학습하면&lt;br /&gt;
바로 해보고 싶은 것이 Test dataset 에 적용시켜 영리한 모델인지를 확인해 보는 것이다.&lt;/p&gt;
&lt;p&gt;제너릭 함수인 &lt;code&gt;predict()&lt;/code&gt; 를 이용해 볼 수 도 있겠지만&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;predict&lt;/span&gt;(rf_fit, &lt;span class=&quot;dt&quot;&gt;newdata =&lt;/span&gt; testing)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##  [1] M M R M R R M M R M R R R R M R R R R R R R R M M R R M M R M M M M M
## [36] M M M M M M M M M M M R M M R M M M M M M M M M M
## Levels: M R&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;caret package 의 &lt;code&gt;confusionMatrix()&lt;/code&gt; 를 곁들이면 더 간편하게 분류교차표 및 정확도까지 출력된다.&lt;a href=&quot;#fn3&quot; class=&quot;footnoteRef&quot; id=&quot;fnref3&quot;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;predict&lt;/span&gt;(rf_fit, &lt;span class=&quot;dt&quot;&gt;newdata =&lt;/span&gt; testing) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;confusionMatrix&lt;/span&gt;(testing$Class)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## Confusion Matrix and Statistics
## 
##           Reference
## Prediction  M  R
##          M 30  9
##          R  3 18
##                                           
##                Accuracy : 0.8             
##                  95% CI : (0.6767, 0.8922)
##     No Information Rate : 0.55            
##     P-Value [Acc &amp;gt; NIR] : 4.67e-05        
##                                           
##                   Kappa : 0.5876          
##  Mcnemar&amp;#39;s Test P-Value : 0.1489          
##                                           
##             Sensitivity : 0.9091          
##             Specificity : 0.6667          
##          Pos Pred Value : 0.7692          
##          Neg Pred Value : 0.8571          
##              Prevalence : 0.5500          
##          Detection Rate : 0.5000          
##    Detection Prevalence : 0.6500          
##       Balanced Accuracy : 0.7879          
##                                           
##        &amp;#39;Positive&amp;#39; Class : M               
## &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;60개의 테스트 데이터셋 중 7개가 오분류 되어 약 88% 의 정확도를 가진 것으로 볼 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;tuning-parameters-의-그리드-조정하기&quot;&gt;Tuning parameters 의 그리드 조정하기&lt;/h2&gt;
&lt;h3 id=&quot;사용자-검색-그리드custom-search-grid&quot;&gt;사용자 검색 그리드(custom search grid)&lt;/h3&gt;
&lt;p&gt;최적 파라미터 선정 시 탐색범위와 그리드를 수동으로 조절할 수 있다.&lt;br /&gt;
자동으로 &lt;span class=&quot;math inline&quot;&gt;3&lt;sup&gt;&lt;em&gt;P&lt;/em&gt;&lt;/sup&gt;&lt;/span&gt; 공식에 의해 정해진 mtry 의 후보는 2, 31, 60 로 3개가 되었다.&lt;br /&gt;
만약 더 많은 후보와 상대평가하고 싶을 경우 후보를 사용자가 직접 설정할 수 있다는 것이다.&lt;/p&gt;
&lt;p&gt;아래 코드는 mtry 의 후보를 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 로 바꾸어 설정하고 이 중에서 채택해 보는 코드이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;customGrid &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;expand.grid&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;mtry =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;)
rf_fit2 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;train&lt;/span&gt;(Class ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;., &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; training, &lt;span class=&quot;dt&quot;&gt;method =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;rf&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;trControl =&lt;/span&gt; fitControl, &lt;span class=&quot;dt&quot;&gt;tuneGrid =&lt;/span&gt; customGrid, &lt;span class=&quot;dt&quot;&gt;verbose =&lt;/span&gt; F)

rf_fit2&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## Random Forest 
## 
## 148 samples
##  60 predictor
##   2 classes: &amp;#39;M&amp;#39;, &amp;#39;R&amp;#39; 
## 
## No pre-processing
## Resampling: Cross-Validated (10 fold, repeated 5 times) 
## Summary of sample sizes: 133, 133, 134, 133, 133, 133, ... 
## Resampling results across tuning parameters:
## 
##   mtry  Accuracy   Kappa    
##    1    0.8283810  0.6509334
##    2    0.8449524  0.6849450
##    3    0.8352381  0.6654026
##    4    0.8366667  0.6687853
##    5    0.8390476  0.6740847
##    6    0.8349524  0.6651819
##    7    0.8245714  0.6441155
##    8    0.8406667  0.6766160
##    9    0.8322857  0.6603633
##   10    0.8284762  0.6522812
## 
## Accuracy was used to select the optimal model using  the largest value.
## The final value used for the model was mtry = 2.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;후보를 사용자 검색에 의해 늘려보아도 이전과 같이 mtry = 2 가 최적의 파라미터로 선정되는 것을 볼 수 있다.&lt;/p&gt;
&lt;h3 id=&quot;랜덤-검색-그리드random-selection-of-tuning-parameter-combinations&quot;&gt;랜덤 검색 그리드(&lt;a href=&quot;http://www.jmlr.org/papers/volume13/bergstra12a/bergstra12a.pdf&quot;&gt;random selection of tuning parameter combinations&lt;/a&gt;)&lt;/h3&gt;
&lt;p&gt;튜닝 파라미터의 개수가 많으면 많아질수록 탐색그리드의 개수는 지수적으로 증가하게 되고 동일한 간격의 그리드 구성으로 인해 탐색과정이 비효율적이 될 수 있다.&lt;br /&gt;
지금까지 튜닝 파라미터가 한개인 랜덤포레스트를 예시로 했는데 이번에는 튜닝 파라미터가 2개인 RDA(Regularized Discriminant Analysis) 를 통해 훈련을 해보겠다.&lt;br /&gt;
&lt;code&gt;method = &amp;quot;rda&amp;quot;&lt;/code&gt; 를 통해 알고리즘을 RDA 로 선언할 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;rda_fit &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;train&lt;/span&gt;(Class ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;., &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; training, &lt;span class=&quot;dt&quot;&gt;method =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;rda&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;trControl =&lt;/span&gt; fitControl, &lt;span class=&quot;dt&quot;&gt;verbose =&lt;/span&gt; F)

rda_fit&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## Regularized Discriminant Analysis 
## 
## 148 samples
##  60 predictor
##   2 classes: &amp;#39;M&amp;#39;, &amp;#39;R&amp;#39; 
## 
## No pre-processing
## Resampling: Cross-Validated (10 fold, repeated 5 times) 
## Summary of sample sizes: 133, 133, 133, 133, 134, 133, ... 
## Resampling results across tuning parameters:
## 
##   gamma  lambda  Accuracy   Kappa    
##   0.0    0.0     0.5687619  0.1108443
##   0.0    0.5     0.7151429  0.4264147
##   0.0    1.0     0.7499048  0.4979435
##   0.5    0.0     0.8162857  0.6298722
##   0.5    0.5     0.8340000  0.6646203
##   0.5    1.0     0.7962857  0.5907191
##   1.0    0.0     0.6405714  0.2773524
##   1.0    0.5     0.6392381  0.2748428
##   1.0    1.0     0.6406667  0.2776946
## 
## Accuracy was used to select the optimal model using  the largest value.
## The final values used for the model were gamma = 0.5 and lambda = 0.5.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;총 9개의 파라미터 조합을 비교하는 것을 볼 수 있다.&lt;br /&gt;
바로 위에 소개한 사용자 검색 그리드 역시 &lt;code&gt;expand.grid()&lt;/code&gt; 함수를 이용하여 동일간격 그리드를 검색하게 될 것이다. 이와는 다르게 랜덤 검색 그리드를 이용하면 동일간격 조건을 파괴시켜 파라미터 조합을 구성할 수 도 있다.&lt;br /&gt;
&lt;code&gt;trainControl()&lt;/code&gt; 함수의 &lt;code&gt;search = &amp;quot;random&amp;quot;&lt;/code&gt; 을 통해 검색 타입을 랜덤으로 바꾼다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;fitControl &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;trainControl&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;method =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;repeatedcv&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;number =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;repeats =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;search =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;random&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이후 &lt;code&gt;rda_fit2&lt;/code&gt; 라는 객체이름으로 학습을 다시 시도하고 저장해 본다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;rda_fit2 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;train&lt;/span&gt;(Class ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;., &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; training, &lt;span class=&quot;dt&quot;&gt;method =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;rda&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;trControl =&lt;/span&gt; fitControl, &lt;span class=&quot;dt&quot;&gt;verbose =&lt;/span&gt; F)
rda_fit2&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## Regularized Discriminant Analysis 
## 
## 148 samples
##  60 predictor
##   2 classes: &amp;#39;M&amp;#39;, &amp;#39;R&amp;#39; 
## 
## No pre-processing
## Resampling: Cross-Validated (10 fold, repeated 5 times) 
## Summary of sample sizes: 134, 133, 134, 133, 133, 133, ... 
## Resampling results across tuning parameters:
## 
##   gamma      lambda      Accuracy   Kappa    
##   0.1905631  0.09127881  0.8182857  0.6359082
##   0.4408472  0.90947514  0.8528571  0.7038502
##   0.5510134  0.81992551  0.8500952  0.6971829
## 
## Accuracy was used to select the optimal model using  the largest value.
## The final values used for the model were gamma = 0.4408472 and lambda
##  = 0.9094751.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;튜닝파라미터가 gamma, lambda 2개인데 검색타입을 랜덤으로 바꾸는 순간 &lt;span class=&quot;math inline&quot;&gt;3&lt;sup&gt;&lt;em&gt;P&lt;/em&gt;&lt;/sup&gt;&lt;/span&gt; 공식으로 후보군을 설정하지 않는 것을 확인할 수 있다.&lt;br /&gt;
수동으로 튜닝파라미터 조합개수를 늘려볼 필요가 있다. 이땐 &lt;code&gt;train()&lt;/code&gt; 함수의 &lt;code&gt;tuneLength&lt;/code&gt; 인자를 이용하면 된다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;rda_fit2 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;train&lt;/span&gt;(Class ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;., &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; training, &lt;span class=&quot;dt&quot;&gt;method =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;rda&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;trControl =&lt;/span&gt; fitControl, &lt;span class=&quot;dt&quot;&gt;tuneLength =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;50&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;verbose =&lt;/span&gt; F)
rda_fit2&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## Regularized Discriminant Analysis 
## 
## 148 samples
##  60 predictor
##   2 classes: &amp;#39;M&amp;#39;, &amp;#39;R&amp;#39; 
## 
## No pre-processing
## Resampling: Cross-Validated (10 fold, repeated 5 times) 
## Summary of sample sizes: 133, 133, 133, 133, 134, 133, ... 
## Resampling results across tuning parameters:
## 
##   gamma       lambda       Accuracy   Kappa    
##   0.02467175  0.046240696  0.7835238  0.5655217
##   0.04621138  0.002756874  0.7919048  0.5824003
##   0.07368577  0.095874564  0.8066667  0.6118768
##   0.07701965  0.222859888  0.8202857  0.6398213
##   0.08188038  0.929917497  0.8123810  0.6225995
##   0.08238852  0.477012957  0.8337143  0.6662831
##   0.08304677  0.278592744  0.8242857  0.6477351
##   0.13057207  0.394850662  0.8407619  0.6801815
##   0.16005396  0.740609627  0.8583810  0.7147504
##   0.16216482  0.825921020  0.8475238  0.6931098
##   0.17577373  0.014122051  0.8121905  0.6232475
##   0.18138144  0.343863922  0.8367619  0.6723626
##   0.19299614  0.250964919  0.8272381  0.6530806
##   0.21154934  0.924441815  0.8380952  0.6743253
##   0.29112614  0.062553048  0.8165714  0.6318989
##   0.32592688  0.815187029  0.8491429  0.6957937
##   0.33401985  0.355391729  0.8343810  0.6667045
##   0.33579572  0.585321935  0.8450476  0.6877346
##   0.38974907  0.595071037  0.8462857  0.6901836
##   0.43134665  0.053143749  0.8057143  0.6091455
##   0.46238233  0.225248311  0.8180952  0.6334203
##   0.48010298  0.220008595  0.8167619  0.6308603
##   0.52875129  0.900502936  0.8369524  0.6717790
##   0.59418161  0.835826412  0.8410476  0.6796135
##   0.64002373  0.715450695  0.8450476  0.6871024
##   0.66951286  0.080254850  0.8084762  0.6133645
##   0.66992710  0.557613578  0.8411429  0.6791014
##   0.68394252  0.120018550  0.8085714  0.6136620
##   0.70021389  0.623248231  0.8423810  0.6819366
##   0.70083494  0.075418255  0.8072381  0.6108154
##   0.71019128  0.776717800  0.8287619  0.6548209
##   0.72006479  0.588846389  0.8301905  0.6573055
##   0.73698825  0.234913379  0.8139048  0.6242272
##   0.74356291  0.148414826  0.8139048  0.6242293
##   0.75140091  0.109355597  0.8112381  0.6189670
##   0.75224234  0.263593657  0.8179048  0.6324297
##   0.76679423  0.973216361  0.7871429  0.5722820
##   0.79372463  0.790550417  0.8045714  0.6062931
##   0.82214953  0.130020319  0.8098095  0.6156629
##   0.82467612  0.550611505  0.8059048  0.6081189
##   0.82612455  0.693889297  0.7966667  0.5900626
##   0.84879017  0.495823009  0.7993333  0.5949617
##   0.85219803  0.931135875  0.7571429  0.5118228
##   0.86055616  0.314226715  0.8045714  0.6050836
##   0.86385220  0.089582003  0.7966667  0.5883829
##   0.87890898  0.058559475  0.7939048  0.5827761
##   0.89994468  0.677635454  0.7641905  0.5254671
##   0.93039376  0.101246271  0.7522857  0.5002045
##   0.93660375  0.971543712  0.7182857  0.4340252
##   0.95149425  0.689020876  0.7141905  0.4257570
## 
## Accuracy was used to select the optimal model using  the largest value.
## The final values used for the model were gamma = 0.160054 and lambda
##  = 0.7406096.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;tuneLength = 50&lt;/code&gt; 로 설정해본 결과이다.&lt;br /&gt;
기본 그리드 검색방법에 비교해 보면 채택된 파라미터의 값이 소수점이 더 많아져 자연스럽게 정밀해 진 것을 확인할 수 있다.&lt;br /&gt;
이처럼 튜닝파라미터를 랜덤하게 50개로 설정하여 조금 더 융통성 있는 최적의 파라미터 튜닝 방법을 고려해 볼 수도 있겠다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;병렬처리parallel-processing&quot;&gt;병렬처리(Parallel Processing)&lt;/h2&gt;
&lt;p&gt;병렬처리를 통해 빠른 탐색 전략을 취할 수 있다.&lt;br /&gt;
doMC 패키지와의 연계를 지원되는 caret 패키지는 학습 시 생기는 많은 연산을 병렬처리를 통해 시간 비용을 낮출 수 있다.&lt;br /&gt;
특히 튜닝파라미터의 조합 수가 많으면 많을수록 병렬처리는 많은 효용이 있을 것이다.&lt;/p&gt;
&lt;p&gt;필요에 따라 doMC 패키지를 설치하고 로드한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;co&quot;&gt;# install.packages(&amp;quot;doMC&amp;quot;)&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;doMC&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;doMC 패키지를 로드하면 &lt;code&gt;getDoParWorkers()&lt;/code&gt; 를 통해 현재 활성화된 코어수를 확인할 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;getDoParWorkers&lt;/span&gt;() &lt;span class=&quot;co&quot;&gt;# default cores count&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;기본적으론 세팅 이전엔 1코어임을 확인할 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;time &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;system.time&lt;/span&gt;({
  &lt;span class=&quot;kw&quot;&gt;train&lt;/span&gt;(Class ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;., &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; training, &lt;span class=&quot;dt&quot;&gt;method =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;gbm&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;trControl =&lt;/span&gt; fitControl, &lt;span class=&quot;dt&quot;&gt;verbose =&lt;/span&gt; F)
})
time&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##    user  system elapsed 
## 218.508   1.495 221.734&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이때 GBM(Stochastic Gradient Boosting Model)알고리즘으로 학습에 소요되는 시간은 222 초 내외이다.&lt;/p&gt;
&lt;p&gt;이번에는 &lt;code&gt;registerDoMC()&lt;/code&gt; 함수를 이용해 코어수를 2개로 늘린 후 학습에 소요되는 시간을 비교해보자.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;registerDoMC&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;cores =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;getDoParWorkers&lt;/span&gt;()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] 2&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;time &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;system.time&lt;/span&gt;({
  &lt;span class=&quot;kw&quot;&gt;train&lt;/span&gt;(Class ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;., &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; training, &lt;span class=&quot;dt&quot;&gt;method =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;gbm&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;trControl =&lt;/span&gt; fitControl, &lt;span class=&quot;dt&quot;&gt;verbose =&lt;/span&gt; F)
})
time&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##    user  system elapsed 
##   0.595   0.067  44.684&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이때 학습에 소요되는 시간은 45 초 내외이다.&lt;br /&gt;
확실히 소요시간이 줄어든 것을 볼 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://topepo.github.io/caret&quot; class=&quot;uri&quot;&gt;https://topepo.github.io/caret&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;2017-04-23 기준으로 글이 작성 및 수정 되었다&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn2&quot;&gt;&lt;p&gt;1: yes, 2: no&lt;a href=&quot;#fnref2&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn3&quot;&gt;&lt;p&gt;예제가 Classification 일때 이므로 Regression 일때는 논외다&lt;a href=&quot;#fnref3&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Sun, 23 Apr 2017 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2017/04/23/caret_package.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2017/04/23/caret_package.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>R에서 car::vif() 함수를 이용한 분산팽창요인(Variance Inflation Factor) 구하기</title>
        <description>&lt;h2 id=&quot;다중공산성과-분산팽창계수&quot;&gt;다중공산성과 분산팽창계수&lt;/h2&gt;
&lt;p&gt;다중공산성은 주관심대상인 종속변수 Y에 대해 설명하려는 독립변수들 간 강한 상관관계로부터 나온다.&lt;br /&gt;
다중공산성은 회귀분석 모델링을 할 때 다양한 이유로 분석가들을 괴롭히는 문제이다.&lt;br /&gt;
따라서 다중공산성 문제를 사전에 방지하기 위해 다양한 진단법이 존재한다.&lt;br /&gt;
그중 하나가 분산팽창계수를 계산하여 분산팽창요인 여부를 찾는 방법이 있다.&lt;/p&gt;
&lt;p&gt;분산팽창요인(Variance Inflation Factor) 줄여서 VIF는 다음과 같이 찾을 수 있다.&lt;/p&gt;
&lt;p&gt;우선 다중회귀분석 시 종속변수 Y를 제외하고&lt;br /&gt;
나머지 독립변수간의 상관관계만을 고려하여 2개 이상의 독립변수 조합 간 회귀분석을 따로 실시한다.&lt;br /&gt;
실시해본 결과 설명력(결정계수 ; &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;R&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/span&gt;)이 높으면 우리가 우려하는 다중공산성문제가 발생되는 것이며&lt;br /&gt;
만약 독립변수 간 상관관계가 높아 특정조합상(i 번째 독립변수를 종속변수로 두어 회귀분석 실시)에서 회귀선의 설명력이 좋으면 분산팽창계수 값이 커지게 된다.&lt;/p&gt;
&lt;p&gt;분산팽창계수의 정의는 아래와 같다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/vif_1.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;보통 이 분산팽창계수가 10 이상일때 &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;j&lt;/em&gt;&lt;/span&gt;번째 독립변수는 다중공산성이 있는 독립변수라 판단한다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;boston-데이터셋을-이용한-실습예제&quot;&gt;Boston 데이터셋을 이용한 실습예제&lt;/h2&gt;
&lt;p&gt;Boston 데이터셋을 이용하여 다중공산성이 있는 독립변수가 존재하는지 R에서 &lt;code&gt;vif()&lt;/code&gt; 함수를 이용하여 찾아보겠다.&lt;/p&gt;
&lt;p&gt;우선 &lt;code&gt;vif()&lt;/code&gt; 는 car package 안에 내장되어있는 함수이다.&lt;br /&gt;
필요에 따라 패키지를 설치하고 로드한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;install.packages&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;car&amp;quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;car&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;MASS package 에 있는 Boston 데이터셋을 이용할 수 있도록 준비한다.&lt;br /&gt;
참고로 Boston 데이터는 집값에 영향을 주는 것으로 생각되는 요인들을 정하여 Boston 지역 부근의 집들을 전수조사한 데이터라고 한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt;(Boston, &lt;span class=&quot;dt&quot;&gt;package =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;MASS&amp;quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;summary&lt;/span&gt;(Boston)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##       crim                zn             indus            chas        
##  Min.   : 0.00632   Min.   :  0.00   Min.   : 0.46   Min.   :0.00000  
##  1st Qu.: 0.08204   1st Qu.:  0.00   1st Qu.: 5.19   1st Qu.:0.00000  
##  Median : 0.25651   Median :  0.00   Median : 9.69   Median :0.00000  
##  Mean   : 3.61352   Mean   : 11.36   Mean   :11.14   Mean   :0.06917  
##  3rd Qu.: 3.67708   3rd Qu.: 12.50   3rd Qu.:18.10   3rd Qu.:0.00000  
##  Max.   :88.97620   Max.   :100.00   Max.   :27.74   Max.   :1.00000  
##       nox               rm             age              dis        
##  Min.   :0.3850   Min.   :3.561   Min.   :  2.90   Min.   : 1.130  
##  1st Qu.:0.4490   1st Qu.:5.886   1st Qu.: 45.02   1st Qu.: 2.100  
##  Median :0.5380   Median :6.208   Median : 77.50   Median : 3.207  
##  Mean   :0.5547   Mean   :6.285   Mean   : 68.57   Mean   : 3.795  
##  3rd Qu.:0.6240   3rd Qu.:6.623   3rd Qu.: 94.08   3rd Qu.: 5.188  
##  Max.   :0.8710   Max.   :8.780   Max.   :100.00   Max.   :12.127  
##       rad              tax           ptratio          black       
##  Min.   : 1.000   Min.   :187.0   Min.   :12.60   Min.   :  0.32  
##  1st Qu.: 4.000   1st Qu.:279.0   1st Qu.:17.40   1st Qu.:375.38  
##  Median : 5.000   Median :330.0   Median :19.05   Median :391.44  
##  Mean   : 9.549   Mean   :408.2   Mean   :18.46   Mean   :356.67  
##  3rd Qu.:24.000   3rd Qu.:666.0   3rd Qu.:20.20   3rd Qu.:396.23  
##  Max.   :24.000   Max.   :711.0   Max.   :22.00   Max.   :396.90  
##      lstat            medv      
##  Min.   : 1.73   Min.   : 5.00  
##  1st Qu.: 6.95   1st Qu.:17.02  
##  Median :11.36   Median :21.20  
##  Mean   :12.65   Mean   :22.53  
##  3rd Qu.:16.95   3rd Qu.:25.00  
##  Max.   :37.97   Max.   :50.00&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;종속변수는 집값을 의미하는 &lt;code&gt;medv&lt;/code&gt; 변수로 할 것이다.&lt;br /&gt;
나머지 변수 중 이산형 자료로 판단되는 &lt;code&gt;chas&lt;/code&gt;, &lt;code&gt;rad&lt;/code&gt; 변수는 편의상 제외하고 독립변수로 설정해 다중회귀적합을 해본 결과이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;str&lt;/span&gt;(Boston) &lt;span class=&quot;co&quot;&gt;# chas, rad 변수가 integer type 인 것을 확인할 수 있음&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## &amp;#39;data.frame&amp;#39;:    506 obs. of  14 variables:
##  $ crim   : num  0.00632 0.02731 0.02729 0.03237 0.06905 ...
##  $ zn     : num  18 0 0 0 0 0 12.5 12.5 12.5 12.5 ...
##  $ indus  : num  2.31 7.07 7.07 2.18 2.18 2.18 7.87 7.87 7.87 7.87 ...
##  $ chas   : int  0 0 0 0 0 0 0 0 0 0 ...
##  $ nox    : num  0.538 0.469 0.469 0.458 0.458 0.458 0.524 0.524 0.524 0.524 ...
##  $ rm     : num  6.58 6.42 7.18 7 7.15 ...
##  $ age    : num  65.2 78.9 61.1 45.8 54.2 58.7 66.6 96.1 100 85.9 ...
##  $ dis    : num  4.09 4.97 4.97 6.06 6.06 ...
##  $ rad    : int  1 2 2 3 3 3 5 5 5 5 ...
##  $ tax    : num  296 242 242 222 222 222 311 311 311 311 ...
##  $ ptratio: num  15.3 17.8 17.8 18.7 18.7 18.7 15.2 15.2 15.2 15.2 ...
##  $ black  : num  397 397 393 395 397 ...
##  $ lstat  : num  4.98 9.14 4.03 2.94 5.33 ...
##  $ medv   : num  24 21.6 34.7 33.4 36.2 28.7 22.9 27.1 16.5 18.9 ...&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;data &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;subset&lt;/span&gt;(Boston, &lt;span class=&quot;dt&quot;&gt;select =&lt;/span&gt; -&lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(chas, rad)) &lt;span class=&quot;co&quot;&gt;# integer type 인 chas, rad 변수 독립변수에서 제외&lt;/span&gt;
lmfit &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;lm&lt;/span&gt;(medv ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;. , &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; data)
&lt;span class=&quot;kw&quot;&gt;summary&lt;/span&gt;(lmfit)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = medv ~ ., data = data)
## 
## Residuals:
##      Min       1Q   Median       3Q      Max 
## -13.3315  -2.8771  -0.6792   1.6858  27.4744 
## 
## Coefficients:
##               Estimate Std. Error t value Pr(&amp;gt;|t|)    
## (Intercept)  2.970e+01  5.051e+00   5.879 7.59e-09 ***
## crim        -7.010e-02  3.269e-02  -2.144 0.032482 *  
## zn           3.989e-02  1.409e-02   2.831 0.004835 ** 
## indus       -4.198e-02  6.080e-02  -0.691 0.490195    
## nox         -1.458e+01  3.899e+00  -3.740 0.000206 ***
## rm           4.188e+00  4.255e-01   9.843  &amp;lt; 2e-16 ***
## age         -1.868e-03  1.359e-02  -0.137 0.890696    
## dis         -1.503e+00  2.059e-01  -7.301 1.15e-12 ***
## tax          8.334e-04  2.386e-03   0.349 0.727038    
## ptratio     -8.738e-01  1.323e-01  -6.607 1.02e-10 ***
## black        8.843e-03  2.763e-03   3.200 0.001461 ** 
## lstat       -5.267e-01  5.224e-02 -10.083  &amp;lt; 2e-16 ***
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1
## 
## Residual standard error: 4.899 on 494 degrees of freedom
## Multiple R-squared:  0.7225, Adjusted R-squared:  0.7163 
## F-statistic: 116.9 on 11 and 494 DF,  p-value: &amp;lt; 2.2e-16&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;다중회귀분석 결과를 &lt;code&gt;summary()&lt;/code&gt; 함수로 간단히 살펴보면&lt;br /&gt;
독립변수 각각에 대한 회귀계수들과 유의성을 판단할 수 있는 output 들이 출력 된다.&lt;br /&gt;
하지만 지금까지 나와 있는 output 만을 보고 다중공산성이 있는지 없는지 판단하기는 쉽지 않다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vif()&lt;/code&gt; 함수를 꺼내 들어보겠다.&lt;br /&gt;
&lt;code&gt;vif()&lt;/code&gt; 함수 사용방법은 아주아주 간단한 편이다. 아래코드처럼 &lt;code&gt;lm()&lt;/code&gt; 함수로 반환된 객체를 넣어주기만 하면 된다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;vif&lt;/span&gt;(lmfit)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##     crim       zn    indus      nox       rm      age      dis      tax 
## 1.663648 2.272992 3.660714 4.294324 1.880883 3.077311 3.953729 3.403205 
##  ptratio    black    lstat 
## 1.725085 1.338875 2.928554&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;vif&lt;/span&gt;(lmfit) &amp;gt;&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##    crim      zn   indus     nox      rm     age     dis     tax ptratio 
##   FALSE   FALSE   FALSE   FALSE   FALSE   FALSE   FALSE   FALSE   FALSE 
##   black   lstat 
##   FALSE   FALSE&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;vif()&lt;/code&gt; 함수를 실행해 본 결과 종속변수를 제외한 독립변수가 나열되고, 그 밑에 각 독립변수의 분산팽창계수값이 출력된다.&lt;br /&gt;
값을 보니 10을 넘는 변수가 존재하지 않다.&lt;br /&gt;
따라서 현 분석에서 다중공산성이 존재하는 독립변수는 없다고 결론을 낼 수 있겠다.&lt;/p&gt;
</description>
        <pubDate>Sun, 16 Apr 2017 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2017/04/16/vif.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2017/04/16/vif.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>R에서 RImpala 패키지를 이용해 Impala 커넥션 맺기 (with Docker)</title>
        <description>&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/Rimpala.jpg&quot; width=&quot;80%&quot;&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cloudera.com/documentation/enterprise/5-8-x/topics/impala.html&quot;&gt;Impala&lt;/a&gt; 라는걸 사용해 봐야 할 일이 생겼다.&lt;br /&gt;
필자는 Hadoop, SQL 과 같은 기술이 상당히 낯설고 두려움이 있었는데 Impala 를 통해 조금씩 알게 되는 계기가 되었으면 좋겠다.&lt;/p&gt;
&lt;p&gt;Impala 는 아파치 프로젝트에 incubating 단계로 관리되고 있는 프로젝트로써&lt;br /&gt;
HDFS(Hadoop Distributed File System) 안에 있는 데이터를 SQL 을 통해 실시간으로(대화형으로) 분석할 수 있게 도와주는 시스템이라고 한다.&lt;br /&gt;
HDFS 를 이용하기 위해선 MapReduce 프레임워크를 알고 이용했어야 한다는 불편한 제약을 Impala 를 통해 벗어날 수 있다 이해할 수 있겠다.&lt;/p&gt;
&lt;p&gt;Impala 소개는 이쯤 하고 (&lt;del&gt;읔.. 알고있는게 이정도 뿐이다 😅&lt;/del&gt;) 여하튼 지금은 &lt;a href=&quot;https://www.docker.com/&quot;&gt;Docker&lt;/a&gt; 을 통해 Impala 를 간단히 구동시켜보고,&lt;br /&gt;
RImpala package 를 이용해 R 상에서 Impala 와 커넥션을 맺는데 성공했던 과정을 짤막하게 정리하고 적어보고자 한다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;ready-impala&quot;&gt;Ready impala&lt;/h2&gt;
&lt;p&gt;Impala 이용 전 &lt;code&gt;.jar&lt;/code&gt; 리소스들을 준비해야 한다고 한다.&lt;br /&gt;
아래 R 코드를 통해 다운로드 및 워킹디렉토리에 압축해제가 가능하다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;download.file&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;https://github.com/Mu-Sigma/RImpala/blob/master/impala-jdbc-cdh5.zip?raw=true&amp;quot;&lt;/span&gt;, 
              &lt;span class=&quot;st&quot;&gt;&amp;quot;jdbc.zip&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;method =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;curl&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;extra =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;-L&amp;quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;unzip&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;jdbc.zip&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;docker-images-ready&quot;&gt;Docker images ready&lt;/h2&gt;
&lt;p&gt;그다음 터미널을 들어가 Docker 를 구동할 준비를 한다.&lt;br /&gt;
여기서 Docker 를 이용하려는 이유를 언급해야 할 것 같은데&lt;br /&gt;
Impala 를 이용하기 위해선 Hadoop 시스템이 사전에 준비되어야 하고, JDBC 를 위한 Java 설정등 다양한 준비(Requirements)가 매우 부담되기 때문이다.&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;br /&gt;
이러한 이유로 나는 Docker 를 이용해 누군가 개발해 놓은, 사전에 잘 구축한 환경을 사용하고자 하기 때문에&lt;br /&gt;
Docker 구동을 위해 boot2docker 를 시작했다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;boot2docker&lt;/span&gt; init
$ &lt;span class=&quot;kw&quot;&gt;boot2docker&lt;/span&gt; up
$ &lt;span class=&quot;kw&quot;&gt;boot2docker&lt;/span&gt; ssh&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;boot2docker ssh&lt;/code&gt; 를 통해 docker 가상머신에 접속 후 &amp;quot;Impala&amp;quot; 를 검색어로 적당한 이미지를 찾아본다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;docker@boot2docker&lt;/span&gt;:~$ docker search impala&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;NAME                                DESCRIPTION                                     STARS
cloudera/impala-dev                 Impala development environment                  10
codingtony/impala                                                                   5
rooneyp1976/impala                  Impala 2.0.1 on Ubuntu 14.04 Image (fork o...   4
lancope/impala-shell                                                                1
yanlinw/docker-impala               impala 2.0.1 + sqoop + sql server driver        0
mikefaille/ubuntu-impala            Description                                     0
galloplabs/hadoop-cdh-impala                                                        0
yanlinw/docker-impala-sqoop         impala sqoop2                                   0
cpcloud86/impala                                                                    0
damsl/impala                                                                        0
joshdub223/impala                                                                   0
aurele/shiny4saagie-impala          Form that reads/writes from Impala on Saagie    0
sebastianmontero/impala                                                             0
datadudes/impala-rest-api           Simple rest API for Impala                      0
andreysabitov/impala-kudu                                                           0
... [이하 생략]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;여러 가지가 이미지가 준비되어 있는데 그중 개인적으론 &amp;quot;cloudera/impala-dev&amp;quot; 보단 &amp;quot;codingtony/impala&amp;quot; 가 바로 사용하기 좋았다.&lt;br /&gt;
&amp;quot;codingtony/impala&amp;quot; 이미지를 준비 내려받았다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;docker@boot2docker&lt;/span&gt;:~$ docker pull codingtony/impala&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1.4GB 정도가 다운로드 되는데 시간이 조금 소요된다.&lt;br /&gt;
다운로드 이후 image 가 잘 준비되어 있는지 &lt;code&gt;docker images&lt;/code&gt; 를 통해 확인할 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;docker@boot2docker&lt;/span&gt;:~$ docker images&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
codingtony/impala   latest              24f0d50712cf        2 years ago         1.452 GB&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;다음을 통해 준비한 Impala 이미지를 컨테이너로 실행시킨다.&lt;a href=&quot;#fn2&quot; class=&quot;footnoteRef&quot; id=&quot;fnref2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;docker@boot2docker&lt;/span&gt;:~$ docker run -d --name &lt;span class=&quot;st&quot;&gt;&amp;quot;impala&amp;quot;&lt;/span&gt; -p 9000:9000 -p 50010:50010 -p 50020:50020 -p 50070:50070 -p 50075:50075 -p 21000:21000 -p 21050:21050 -p 25000:25000 -p 25010:25010 -p 25020:25020 codingtony/impala&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;참고로 &lt;code&gt;docker run&lt;/code&gt; 의 다양한 옵션들 중 &lt;code&gt;-d,&lt;/code&gt; &lt;code&gt;--name&lt;/code&gt; 은 각각&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-d&lt;/code&gt; : background 프로세스로 실행해 놓겠다는 의미&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--name &amp;quot;impala&amp;quot;&lt;/code&gt; : image 이름의 alias 를 부여, 예를 들어 본 컨테이너에 접근하기 위해선 &amp;quot;codingtony/impala&amp;quot; 의 이름을 다 입력해야 하는데 앞으론 &amp;quot;impala&amp;quot; 라는 이름으로 접근 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;의 의미를 가지고 있다.&lt;br /&gt;
참고로 Impala 컨테이너가 백그라운드로 잘 실행되는 상태인지 확인을 위해선 &lt;code&gt;docker ps&lt;/code&gt; 명령어로 프로세스 확인할 수 있다.&lt;br /&gt;
프로세스가 잘 돌고 있는 것을 확인했다면&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;docker@boot2docker&lt;/span&gt;:~$ docker exec -it impala /bin/bash&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;를 통해 Impala 컨테이너의 bash 셸을 열어 입력/출력이 가능하도록 사용할 수 있고&lt;br /&gt;
&lt;code&gt;impala-shell&lt;/code&gt; 를 실행해 대화형 쿼리를 주고받을 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@cb4ba4d0f902:/# impala-shell

Starting Impala Shell without Kerberos authentication
Connected to cb4ba4d0f902:21000
Server version: impalad version 1.4.2-cdh5 RELEASE (build eac952d4ff674663ec3834778c2b981b252aec78)
Welcome to the Impala shell. Press TAB twice to see a list of available commands.

Copyright (c) 2012 Cloudera, Inc. All rights reserved.

(Shell build version: Impala Shell v1.4.2-cdh5 (eac952d) built on Tue Sep 16 19:15:40 PDT 2014)
[cb4ba4d0f902:21000] &amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;rimpala-package-이용한-로컬에서의-impala-제어&quot;&gt;RImpala package 이용한 로컬에서의 impala 제어&lt;/h2&gt;
&lt;h3 id=&quot;docker-vm-ip-확인&quot;&gt;Docker VM IP 확인&lt;/h3&gt;
&lt;p&gt;로컬 상에서 RImpala package 이용한 로컬 상의 제어를 위해 docker ip 를 확인할 필요가 있다.&lt;br /&gt;
이는 &lt;code&gt;boot2docker ip&lt;/code&gt; 를 통해 쉽게 확인 가능하다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;boot2docker&lt;/span&gt; ip&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;예를 들어 &amp;quot;192.168.59.103&amp;quot; 임을 위의 커멘드를 통해 확인했다고 가정하겠다.&lt;/p&gt;
&lt;h3 id=&quot;r상에-rimpala-패키지를-이용한-커넥션&quot;&gt;R상에 RImpala 패키지를 이용한 커넥션&lt;/h3&gt;
&lt;p&gt;R로 되돌아오자.&lt;br /&gt;
먼저 &lt;code&gt;.jar&lt;/code&gt; 들을 다운받은 디렉토리 path를 &lt;code&gt;rimpala.init()&lt;/code&gt; 함수에 입력한 코드를 먼저 실행하고,&lt;br /&gt;
docker 가상환경의 ip, 그리고 Impala JDBC/ODBC 기본값 포트번호 (21050) 를 &lt;code&gt;rimpala.connect()&lt;/code&gt; 에 입력한 코드를 그다음으로 실행하면 &lt;code&gt;TRUE&lt;/code&gt; 가 반기면 커넥션이 성공한 것이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(RImpala)

&lt;span class=&quot;kw&quot;&gt;rimpala.init&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;libs =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;impala-jdbc-cdh5&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;Classpath added successfully&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;rimpala.connect&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;IP =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;192.168.59.103&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;port =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;21050&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;use-databases&quot;&gt;Use databases&lt;/h3&gt;
&lt;p&gt;자 이제 즐기면(?) 되겠다. database 가 무엇이 있는지 확인부터 해보자.&lt;br /&gt;
&lt;code&gt;show databases;&lt;/code&gt; 쿼리를 날려보는 건 &lt;code&gt;rimpala.showdatabases()&lt;/code&gt; 을 실행하는 것과 같다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;rimpala.showdatabases&lt;/span&gt;()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##               name
## 1 _impala_builtins
## 2          default&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;쿼리문 자체를 이용하고자 한다면 &lt;code&gt;rimpala.query()&lt;/code&gt; 함수를 이용하면 된다.&lt;br /&gt;
단 쿼리문 마지막에 세미콜론(;)은 넣지 않아야 에러가 나지 않았다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;rimpala.query&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;show databases&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##               name
## 1 _impala_builtins
## 2          default&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;사용할 데이터베이스 선택을 해보자.&lt;br /&gt;
&amp;quot;default&amp;quot; database 를 사용하려한다면&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;rimpala.usedatabase&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;default&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;를 하면된다. &lt;code&gt;use default;&lt;/code&gt; 쿼리와 같다.&lt;/p&gt;
&lt;h3 id=&quot;send-query-test&quot;&gt;Send query test&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;tryCatch&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;rimpala.query&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;drop table sample&amp;quot;&lt;/span&gt;), &lt;span class=&quot;dt&quot;&gt;error =&lt;/span&gt; function(e){})&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## NULL&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;tryCatch&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;rimpala.query&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;create table sample(no integer)&amp;quot;&lt;/span&gt;), &lt;span class=&quot;dt&quot;&gt;error =&lt;/span&gt; function(e){})&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## NULL&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;tryCatch&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;rimpala.query&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;insert into sample (no) values (1)&amp;quot;&lt;/span&gt;), &lt;span class=&quot;dt&quot;&gt;error =&lt;/span&gt; function(e){})&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## NULL&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;data &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;rimpala.query&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;select * from sample&amp;quot;&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# output value is data.frame class&lt;/span&gt;
data&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##   no
## 1  1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;rimpala.query()&lt;/code&gt; 함수로 쿼리를 보낼 때 에러를 많이 반환했다.&lt;br /&gt;
하지만 이상하게도 R상에선 에러를 뿜었으나 쿼리가 Impala 에 잘 먹혔다.&lt;br /&gt;
이 때문에 임시방편으로 &lt;code&gt;tryCatch()&lt;/code&gt; 를 통해 예외처리를 했다.&lt;br /&gt;
다만 데이터를 끌어오는데는 쿼리는 문제없이 잘 실행됬다.&lt;/p&gt;
&lt;h3 id=&quot;close-connect-impala&quot;&gt;close connect impala&lt;/h3&gt;
&lt;p&gt;커넥션은 &lt;code&gt;rimpala.close()&lt;/code&gt; 로 끊을 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;rimpala.close&lt;/span&gt;()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.cloudera.com/blog/2013/12/how-to-do-statistical-analysis-with-impala-and-r/&quot;&gt;How-to: Do Statistical Analysis with Impala and R&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://d2.naver.com/helloworld/246342&quot;&gt;Naver D2 - Hadoop에서의 실시간 SQL 질의: Impala&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/codingtony/docker-impala&quot;&gt;Github Readme (codingtony/docker-impala)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;Cloudera 에서 &lt;a href=&quot;https://www.cloudera.com/documentation/enterprise/5-9-x/topics/impala_prereqs.html&quot;&gt;Impala install 페이지&lt;/a&gt;를 보고 지레 겁먹어서 그렇기도 하다&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn2&quot;&gt;&lt;p&gt;&lt;code&gt;docker pull&lt;/code&gt; 과정 없이 바로 &lt;code&gt;docker run&lt;/code&gt; 을 해도 된다. 무슨말이냐면 사실 &lt;code&gt;docker run&lt;/code&gt; 은 이미지가 없을 경우 자동으로 이미지를 다운로드 하기 때문이다&lt;a href=&quot;#fnref2&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Tue, 21 Mar 2017 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2017/03/21/RImpala_package.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2017/03/21/RImpala_package.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>인터넷 접속이 불가능 한 내부망에서의 R package 설치방법에 대해</title>
        <description>&lt;p&gt;(지금은 그렇지 않은데) 이전에 일하던 환경이 망분리(내부망)의 도입으로 인하여&lt;br /&gt;
인터넷이 불가능한 상황에서 R을 이용해 분석을 해야 했던 적이 있었다.&lt;br /&gt;
특히 보안으로 인한 법 개정인지 몰라도 망분리 도입이 공기업을 시작으로 활발하게 진행하는 듯 싶은데,&lt;br /&gt;
이로인한 많은 이슈를 대응해야 하는 사람들 입장에선 많이 피곤할 것으로 생각한다.&lt;/p&gt;
&lt;p&gt;오픈소스 도구 특성상 대부분이 그렇겠지만, 인터넷의 의존도는 높을 것이다.&lt;br /&gt;
그중 하나인 R 언어 역시 마찬가지다.&lt;br /&gt;
R 패키지의 설치는 기본적으론 &lt;a href=&quot;https://cran.r-project.org/&quot;&gt;CRAN&lt;/a&gt; 을 통해 패키지 리소스들을 요청하고 다운로드 하는데 이것이 불가해진다.&lt;br /&gt;
그렇다고 패키지 설치가 아예 불가능한 것은 아닌데, 문제는 R을 이용하는 클라이언트 입장에서 매우 불편을 느끼게 된다는 것이 문제다.&lt;br /&gt;
R을 잘 알고 사용하는 사람이라면 방법이 어찌 되었건 간에 패키지 리소스를 로컬상으로 옮겨서 이슈를 해결하지만, 수동적으로 R 을 분석을 위해서 단편적으로 이용하시는 분들 입장에선 어디까지나 해괴망측한 에러 중 하나로 판단할 것이 당연하다.&lt;br /&gt;
클라이언트 입장에서 가장 간단한 패키지 설치 방법을 PPT로 제작해 보았다.&lt;/p&gt;
&lt;iframe src=&quot;https://lovetoken.github.io/assets/assets/player/KeynoteDHTMLPlayer.html#0&quot; width=&quot;100%&quot; height=&quot;500px&quot;&gt;
&lt;/iframe&gt;
&lt;p&gt;준비한 슬라이드 쇼에는 가장 간단한 패키지 수동설치법에 대해서&lt;br /&gt;
5page 로 축약하여 설명을 해 놓았다.&lt;/p&gt;
&lt;p&gt;망분리란 고립된(?) 환경을 체험 중인 분들에게&lt;br /&gt;
그나마 해갈이 될 수 있도록 도움이 되었으면 좋겠다 😢&lt;/p&gt;
</description>
        <pubDate>Sun, 05 Mar 2017 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2017/03/05/Rpackage_install_in.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2017/03/05/Rpackage_install_in.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>R에서 의미가 있었던 프로파일링 모음</title>
        <description>&lt;p&gt;훌륭한진 못해도 좋은 개발을 하고 싶다는 생각이 많이 든다.&lt;br /&gt;
좋은 코드를 짜기 위해 노력중이다.&lt;br /&gt;
좋은 코드에 필요한 요소들은 여러가지가 있겠지만, 지금 가장 큰 흥미를 가지고 관심가지는 것은 효율성이다.&lt;br /&gt;
효율성에서도 여러 가지 측면이 있겠지만 코드수행시간에 특히 민감해 하고 있다.&lt;br /&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Profiling_(computer_programming)&quot;&gt;Profiling&lt;/a&gt; 을 통해 이런저런 실험들을 해보고 있고, 그 중 나름 유의미했던 실험들을 정리해 보고자 한다.&lt;/p&gt;
&lt;p&gt;프로파일링에 사용한 도구는 rbenchmark package 의 &lt;code&gt;benchmark()&lt;/code&gt; 함수로 통일 하였고, 대조군 코드를 통해 비교적 쉽게 받아들일 수 있도록 작성해 보았다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;lapply-vs-parallelmclapply&quot;&gt;&lt;code&gt;lapply()&lt;/code&gt; VS &lt;code&gt;parallel::mclapply()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&amp;quot;parallel&amp;quot; package 에 있는 &lt;code&gt;mclapply()&lt;/code&gt; 함수는 &lt;code&gt;lapply()&lt;/code&gt; 함수와 기능이 똑같다.&lt;br /&gt;
다만 &lt;code&gt;mc.cores&lt;/code&gt; 인자를 가지고 있고 멀티코어 개수를 지정하여 병렬처리를 간편하게 수행할 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(parallel)

&lt;span class=&quot;kw&quot;&gt;benchmark&lt;/span&gt;(
  &lt;span class=&quot;kw&quot;&gt;lapply&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1000&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;9999&lt;/span&gt;, rnorm),
  &lt;span class=&quot;kw&quot;&gt;mclapply&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1000&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;9999&lt;/span&gt;, rnorm, &lt;span class=&quot;dt&quot;&gt;mc.cores =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;)
)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;                                 test replications elapsed relative 
2 mclapply(1000:9999, rnorm, mc.c ...          100 289.162    1.000 
1                 lapply(1000:999 ...          100 464.604    1.607 &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위의 실험은 표준정규분포에서 난수발생을 1000번부터 9999번까지 수행하는 것을 100번&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; 반복시킨 후 수행시간을 평가하는 코드이다.&lt;br /&gt;
&lt;code&gt;mclapply()&lt;/code&gt; 함수로 실행한 결과가 평균 289초, &lt;code&gt;lapply()&lt;/code&gt; 함수로 실행한 결과가 평균 464초 걸렸고 상대적으로 &lt;code&gt;lapply()&lt;/code&gt; 를 사용한 코드가 &lt;code&gt;mclapply()&lt;/code&gt; 로 사용한 코드보다 1.607배 많은 시간이 소요됨을 알 수 있다.&lt;/p&gt;
&lt;p&gt;반면에 난수발생을 적게 시킬 경우 &lt;code&gt;mclapply()&lt;/code&gt; 는 &lt;code&gt;lapply()&lt;/code&gt; 보다 멍청해(?) 지는 것을 볼 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;benchmark&lt;/span&gt;(
  &lt;span class=&quot;kw&quot;&gt;lapply&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;99&lt;/span&gt;, rnorm),
  &lt;span class=&quot;kw&quot;&gt;mclapply&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;99&lt;/span&gt;, rnorm, &lt;span class=&quot;dt&quot;&gt;mc.cores =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;)
)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##                              test replications elapsed relative 
## 1                 lapply(10:9 ...          100   0.118    1.000 
## 2 mclapply(10:99, rnorm, mc.c ...          100   1.994   16.898 &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;filtering-data.table-data.frame-dplyrfilter&quot;&gt;Filtering data.table, data.frame + &lt;code&gt;dplyr::filter()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;이번에 수행한 프로파일링은 &lt;a href=&quot;http://using.tistory.com/81&quot;&gt;빵군님의 블로그 글&lt;/a&gt;을 보다가 추가로 생긴 궁금증에 몇 개를 더 추가해 본 경우이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(data.table)
&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(dplyr)

DF &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;data.frame&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;x =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;runif&lt;/span&gt;(&lt;span class=&quot;fl&quot;&gt;2.6e+07&lt;/span&gt;), &lt;span class=&quot;dt&quot;&gt;y =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;rep&lt;/span&gt;(LETTERS, &lt;span class=&quot;dt&quot;&gt;each =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10000&lt;/span&gt;))

DT &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;as.data.table&lt;/span&gt;(DF)
&lt;span class=&quot;kw&quot;&gt;setkey&lt;/span&gt;(DT, y) 

&lt;span class=&quot;kw&quot;&gt;benchmark&lt;/span&gt;(
  DF[DF$y ==&lt;span class=&quot;st&quot;&gt; &amp;quot;D&amp;quot;&lt;/span&gt;, ],
  DT[&lt;span class=&quot;kw&quot;&gt;J&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;D&amp;quot;&lt;/span&gt;), ],
  DF %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;dplyr::&lt;span class=&quot;kw&quot;&gt;filter&lt;/span&gt;(y ==&lt;span class=&quot;st&quot;&gt; &amp;quot;D&amp;quot;&lt;/span&gt;),
  DT %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;dplyr::&lt;span class=&quot;kw&quot;&gt;filter&lt;/span&gt;(y ==&lt;span class=&quot;st&quot;&gt; &amp;quot;D&amp;quot;&lt;/span&gt;)
)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##                             test replications elapsed relative
## 2                   DT[J(&amp;quot;D&amp;quot;), ]          100   2.500    1.000
## 4 DT %&amp;gt;% dplyr::filter(y == &amp;quot;D&amp;quot;)          100  23.083    9.233
## 3 DF %&amp;gt;% dplyr::filter(y == &amp;quot;D&amp;quot;)          100  23.248    9.299
## 1              DF[DF$y == &amp;quot;D&amp;quot;, ]          100  38.298   15.319&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;비교대상은 4가지이다.&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;code&gt;data.frame&lt;/code&gt; 형에서 필터링&lt;/li&gt;
&lt;li&gt;&lt;code&gt;data.table&lt;/code&gt; 형에서 필터링&lt;/li&gt;
&lt;li&gt;&lt;code&gt;data.frame&lt;/code&gt; 형에서 &lt;code&gt;dplyr::filter()&lt;/code&gt; 를 이용한 필터링&lt;/li&gt;
&lt;li&gt;&lt;code&gt;data.table&lt;/code&gt; 형에서 &lt;code&gt;dplyr::filter()&lt;/code&gt; 를 이용한 필터링&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;결과는 J표현식을 사용한 data.table 이 가장 우월하다는 것을 볼 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;sqldf-package-를-통해-join-작업을-하다가-생긴-의문&quot;&gt;sqldf package 를 통해 Join 작업을 하다가 생긴 의문&lt;/h2&gt;
&lt;p&gt;R에서 SQL 문을 통해 data.frame 형을 처리하기 위한 대표적인 패키지가 &lt;a href=&quot;https://cran.r-project.org/web/packages/sqldf/index.html&quot;&gt;sqldf&lt;/a&gt; 이지 않을까?&lt;br /&gt;
필요에 따라서 R에서 SQL 을 통해 data.frame 을 핸들링 하는 확장성을 이용할 수 있다.&lt;/p&gt;
&lt;p&gt;하지만 문득 이런 생각이 드는 것도 사실이다.&lt;br /&gt;
R에서 굳이 다른 문법(SQL)을 이용하는 것은&lt;br /&gt;
영국 가서 미국발음으로 영어하고, 미국 가서 영국발음으로 영어 하는 것으로 비유해 보고 싶다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;merge()&lt;/code&gt;, &lt;code&gt;dplyr::left_join()&lt;/code&gt;, &lt;code&gt;sqldf()&lt;/code&gt; 3가지 함수를 통해 left join 을 하는 예제로 프로파일링을 해보았는데&lt;br /&gt;
그 이후 SQL 문법을 불필요하게 남용하지 않아야 겠다는 생각을 가졌다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(sqldf)
&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(dplyr)

df1 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;data.frame&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;Key =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;), 
                  &lt;span class=&quot;dt&quot;&gt;Var1 =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;a&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;b&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;c&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;c&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;b&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;c&amp;quot;&lt;/span&gt;), &lt;span class=&quot;dt&quot;&gt;stringsAsFactors =&lt;/span&gt; F)
df2 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;data.frame&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;Key =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;), 
                  &lt;span class=&quot;dt&quot;&gt;Var2 =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;x&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;y&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;z&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;xx&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;yy&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;zz&amp;quot;&lt;/span&gt;), &lt;span class=&quot;dt&quot;&gt;stringsAsFactors =&lt;/span&gt; F)

&lt;span class=&quot;kw&quot;&gt;benchmark&lt;/span&gt;(
  df1 %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;merge&lt;/span&gt;(df2, &lt;span class=&quot;dt&quot;&gt;by =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;Key&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;all.x =&lt;/span&gt; T),
  df1 %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;dplyr::&lt;span class=&quot;kw&quot;&gt;left_join&lt;/span&gt;(df2, &lt;span class=&quot;dt&quot;&gt;by =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;Key&amp;quot;&lt;/span&gt;),
  &lt;span class=&quot;kw&quot;&gt;sqldf&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;SELECT df1.Key, Var1, Var2 FROM df1 LEFT JOIN df2 on df1.Key=df2.Key&amp;quot;&lt;/span&gt;)
)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##                                                 test replications elapsed relative 
## 2                                     df1 %&amp;gt;% dp ...          100   0.033    1.000 
## 1                                     df1 %&amp;gt;% me ...          100   0.089    2.697 
## 3 sqldf(&amp;quot;SELECT df1.Key, Var1, Var2 FROM df1 LEF ...          100   2.361   71.545 &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;sqldf()&lt;/code&gt; 을 통한 join 이 다른방법보다 71배 더 오래걸려 비교적 느림을 알 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;output&quot;&gt;Output&lt;/h2&gt;
&lt;p&gt;위의 SQL 프로파일링과도 이어지는 컨셉이다.&lt;br /&gt;
냉면으로 유명한 집에서 국수를 먹고, 국수가 유명한 집에서 밥을 먹지 않는 것 처럼&lt;br /&gt;
각 언어의 특색에 맞는 장점들을 충분히 이용하는것이 합리적이라 생각한다.&lt;/p&gt;
&lt;p&gt;이번 프로파일링도 비슷하다.&lt;br /&gt;
R에서 처리된 결과물을 R object 이미지로(.rda)로 저장하는것과 .csv 포맷으로 저장하는 것을 비교해 보았다.&lt;br /&gt;
(R에서 처리된 결과물의 예제를 &lt;code&gt;mtcars&lt;/code&gt; 내장데이터로 가정해보겠다)&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;benchmark&lt;/span&gt;(
  &lt;span class=&quot;kw&quot;&gt;save&lt;/span&gt;(mtcars, &lt;span class=&quot;dt&quot;&gt;file =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;mtcars.rda&amp;quot;&lt;/span&gt;),
  &lt;span class=&quot;kw&quot;&gt;write.csv&lt;/span&gt;(mtcars, &lt;span class=&quot;dt&quot;&gt;file =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;mtcars.csv&amp;quot;&lt;/span&gt;)
)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##                                     test replications elapsed relative
## 1      save(mtcars, file = &amp;quot;mtcars.rda&amp;quot;)          100   0.054    1.000
## 2 write.csv(mtcars, file = &amp;quot;mtcars.csv&amp;quot;)          100   0.116    2.148&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;결과는 .rda 로 객체이미지를 저장시키는 것이 2배 빠른 것을 볼 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;역행렬-계산시-특이값-분해singular-value-decomposition-이용&quot;&gt;역행렬 계산시 특이값 분해(Singular value decomposition) 이용&lt;/h2&gt;
&lt;p&gt;(정방)행렬의 차원이 크면 클수록 역행렬을 계산할 때 컴퓨터가 힘들어 한다.&lt;br /&gt;
조금이라도 빠르게 계산할 수 있는 방법이 없을까 고민하다가 특이값 분해(SVD) 를 알게된 이후로 조금 개선된 방법을 찾게 되었다.&lt;/p&gt;
&lt;p&gt;SVD 를 아주 간단하게 설명하면 행렬&lt;a href=&quot;#fn2&quot; class=&quot;footnoteRef&quot; id=&quot;fnref2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;X&lt;/em&gt;&lt;/span&gt; 를 대각행렬 &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;D&lt;/em&gt;&lt;/span&gt; 를 중앙으로 하고 3개의 행렬곱으로 나누어 준다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;span class=&quot;math display&quot;&gt;&lt;em&gt;X&lt;/em&gt; = &lt;em&gt;U&lt;/em&gt;&lt;em&gt;D&lt;/em&gt;&lt;em&gt;V&lt;/em&gt;&lt;sup&gt;&lt;em&gt;T&lt;/em&gt;&lt;/sup&gt;&lt;/span&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;그리고 이렇게 분해된 행렬곱을 변환하면&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;span class=&quot;math display&quot;&gt;&lt;em&gt;X&lt;/em&gt;&lt;sup&gt;−1&lt;/sup&gt; = &lt;em&gt;V&lt;/em&gt;&lt;em&gt;D&lt;/em&gt;&lt;sup&gt;−1&lt;/sup&gt;&lt;em&gt;U&lt;/em&gt;&lt;sup&gt;&lt;em&gt;T&lt;/em&gt;&lt;/sup&gt;&lt;/span&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;이 되는 특성을 가지고 있다.&lt;br /&gt;
컴퓨터 입장에선 복잡한 &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;X&lt;/em&gt;&lt;/span&gt;를 바로 역행렬 계산하는 것 보다, 부담이 적은 단위행렬 &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;D&lt;/em&gt;&lt;/span&gt;를 역행렬 계산하는것을 쉬워할 것이다.&lt;br /&gt;
이러한 특성을 이용한 것이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;m &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;matrix&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;rnorm&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1000&lt;/span&gt;^&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;), &lt;span class=&quot;dv&quot;&gt;1000&lt;/span&gt;)
svd &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;svd&lt;/span&gt;(m)

&lt;span class=&quot;kw&quot;&gt;benchmark&lt;/span&gt;(
  &lt;span class=&quot;kw&quot;&gt;solve&lt;/span&gt;(m),
  svd$v %*%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;solve&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;diag&lt;/span&gt;(svd$d)) %*%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;t&lt;/span&gt;(svd$u)
)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##                                        test replications elapsed relative
## 1                                  solve(m)          100 238.183    1.194
## 2 svd$v %*% solve(diag(svd$d)) %*% t(svd$u)          100 199.452    1.000&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;SVD로 나눈 행렬을 이용해 역행렬 &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;X&lt;/em&gt;&lt;sup&gt;−1&lt;/sup&gt;&lt;/span&gt; 을 구하는것이 조금 빠른것을 볼 수 있다.&lt;br /&gt;
상대적으로 볼 때 별차이가 없어 보일수도 있지만 행렬의 차원이 크면 클수록 절대소요시간차이는 엄청날 것이다.&lt;/p&gt;
&lt;p&gt;그런데 여기서 반론을 제기할 수 있다.&lt;br /&gt;
바로 특이값 분해시 코드수행속도도 포함시켜야 하지 않느냐 이다.&lt;br /&gt;
즉 엄밀히 말하면 &lt;code&gt;svd &amp;lt;- svd(m)&lt;/code&gt; 코드 수행시간도 더해주어야 할 것이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;system.time&lt;/span&gt;(svd &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;svd&lt;/span&gt;(m))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##   user  system elapsed 
##  4.101   0.047   4.202 &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;하지만 4초내외로 특이값분해는 의외로 많은 시간이 걸리지 않는다.&lt;br /&gt;
이 4초 내외를 더해보았자 대세에 지장이 없는 수준이다.&lt;br /&gt;
게다가 &lt;code&gt;svd()&lt;/code&gt; 말고도 이보다 더 빠르게 특이값 분해를 할 수 있는 방법&lt;a href=&quot;#fn3&quot; class=&quot;footnoteRef&quot; id=&quot;fnref3&quot;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;들도 있으니 참고해 볼만하다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;to-be-continued&quot;&gt;To be continued&lt;/h2&gt;
&lt;p&gt;의미 있는 프로파일링이 다음에 또 생기면 이어서 덧붙여질 예정이다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;프로파일링에-사용했던-동작환경&quot;&gt;프로파일링에 사용했던 동작환경&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;sessionInfo&lt;/span&gt;()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## R version 3.3.1 (2016-06-21)
## Platform: x86_64-apple-darwin13.4.0 (64-bit)
## Running under: OS X 10.12.3 (Sierra)
## 
## locale:
## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8
## 
## attached base packages:
## [1] parallel  stats     grDevices utils     datasets  graphics  methods  
## [8] base     
## 
## other attached packages:
## [1] rbenchmark_1.0.0            data.table_1.10.4          
## [3] ggplot2_2.2.1               dplyr_0.5.0                
## [5] knitr_1.15.1                useful.lovetoken_0.1.0.0090
## 
## loaded via a namespace (and not attached):
##  [1] Rcpp_0.12.9      magrittr_1.5     munsell_0.4.3    colorspace_1.3-2
##  [5] R6_2.2.0         stringr_1.2.0    plyr_1.8.4       tools_3.3.1     
##  [9] grid_3.3.1       gtable_0.2.0     pacman_0.4.1     DBI_0.5-1       
## [13] htmltools_0.3.5  yaml_2.1.14      lazyeval_0.2.0   assertthat_0.1  
## [17] digest_0.6.12    rprojroot_1.2    tibble_1.2       evaluate_0.10   
## [21] rmarkdown_1.3    stringi_1.1.2    scales_0.4.1     backports_1.0.5&lt;/code&gt;&lt;/pre&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;&lt;code&gt;benchmark()&lt;/code&gt; 함수에서 &lt;code&gt;replications&lt;/code&gt; 인자를 통해 조정이 가능하며, 디폴트 값이 100이다&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn2&quot;&gt;&lt;p&gt;이때 행렬은 정방행렬이 아니어도 특이값 분해가 가능하다&lt;a href=&quot;#fnref2&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn3&quot;&gt;&lt;p&gt;&lt;code&gt;corpcor::fast.svd()&lt;/code&gt; 와 같은 것도 있다&lt;a href=&quot;#fnref3&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Wed, 22 Feb 2017 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2017/02/22/Profiling.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2017/02/22/Profiling.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>Docker 를 이용해 Rstudio server 띄워보기 (on Mac OSX)</title>
        <description>&lt;p&gt;가상머신보다 경량화된 &lt;a href=&quot;https://www.docker.com/&quot;&gt;Docker&lt;/a&gt; 기술을 이것저것 만져보며 차차 공부중에 있다.&lt;br /&gt;
Docker가 왜 가상머신보다 가볍고 빠른지 지금은 논리적으로 설명하지 못한다.&lt;br /&gt;
가상머신상에서 실험했을 당시 불편한 점들과 만족스럽지 못한 성능을 대체할만한 기술 중 Docker 라는 것이 있다는 소문을 듣고 추천을 받았으며 인기가 매우 높다는 정도만 알고 있다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;우선 본 글은 Docker를 이용해 Rstudio server를 띄움으로써 &amp;quot;Hello Docker!&amp;quot; 를 외치는 것이 목표라 하겠다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;docker-준비&quot;&gt;Docker 준비&lt;/h2&gt;
&lt;p&gt;Docker 을 OSX 에서 설치하는 방법은 다양하다.&lt;br /&gt;
&lt;a href=&quot;https://www.docker.com/&quot;&gt;Docker 공식홈페이지&lt;/a&gt;의 튜토리얼 대로 설치하는 것이 가장 정석의 방법이고,&lt;br /&gt;
&lt;a href=&quot;https://penandpants.com/2014/03/09/docker-via-homebrew/&quot;&gt;Homebrew 를 통해서도 설치&lt;/a&gt;할 수 있으며,&lt;br /&gt;
&lt;a href=&quot;https://www.docker.com/products/docker-toolbox&quot;&gt;Docker Toolbox&lt;/a&gt; 를 이용해 큰 고민 없이 설치할 수도 있다.&lt;/p&gt;
&lt;p&gt;필자는 정석방법대로 하다가 진도가 중간에 막히게 되어 Docker Toolbox 를 overwrite 한 시행착오가 있었는데, 현재로썬 Docker Toolbox 로 설치하는 것이 가장 간단한 방법이라 추측된다.&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;br /&gt;
아래 사진은 &lt;a href=&quot;https://www.docker.com/products/docker-toolbox&quot;&gt;Docker Toolbox&lt;/a&gt; 로 접속했을 때 모습이다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/docker_toolbox.png&quot;&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;왼쪽 맥용 다운로드 링크를 누르면 &lt;code&gt;.pkg&lt;/code&gt; 파일이 다운로드 된다.&lt;br /&gt;
실행하여 설치를 진행하면 된다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/dtInstall_1.png&quot; width=&quot;80%&quot;&gt;
&lt;/center&gt;
&lt;br&gt; &lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/dtInstall_2.png&quot; width=&quot;80%&quot;&gt;
&lt;/center&gt;
&lt;br&gt; &lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/dtInstall_3.png&quot; width=&quot;80%&quot;&gt;
&lt;/center&gt;
&lt;br&gt; &lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/dtInstall_4.png&quot; width=&quot;80%&quot;&gt;
&lt;/center&gt;
&lt;br&gt; &lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/dtInstall_5.png&quot; width=&quot;80%&quot;&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;다른 곳은 특이사항 없이 설치를 진행하면 되는데 이곳에서 무언가를 선택하라고 나온다.&lt;br /&gt;
오른쪽의 Kitematic (Beta) 는 Docker 를 GUI 방식으로 이용할 수 있는 것이고,&lt;br /&gt;
왼쪽은 터미널을 이용해서 빠르게 사용하겠다는 것이다.&lt;br /&gt;
나는 왼쪽을 눌러 사용하는 터미널을 선택 후 계속 버튼을 눌렀다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/dtInstall_6.png&quot; width=&quot;80%&quot;&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;설치가 성공되면 터미널에서 &lt;code&gt;docker&lt;/code&gt;, &lt;code&gt;boot2docker&lt;/code&gt; 가 실행 가능하다.&lt;br /&gt;
설치가 잘 되었는지 실험삼아 각각의 버전을 확인해보는 커맨드를 입력 해 보았다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker --version
Docker version 1.12.6, build 78d1802&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;$ boot2docker version
Boot2Docker-cli version: v1.8.0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;boot2docker-로-docker-vm-준비하기&quot;&gt;boot2docker 로 docker VM 준비하기&lt;/h2&gt;
&lt;p&gt;&amp;quot;boot2docker&amp;quot; 이름대로 docker 를 이용하기 전에 수행되어야 한다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ boot2docker

Usage: boot2docker [&amp;lt;options&amp;gt;] {help|init|up|ssh|save|down|poweroff|reset|restart|config|status|info|ip|shellinit|delete|download|upgrade|version} [&amp;lt;args&amp;gt;]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;boot2docker 의 사용법을 살펴보면 많은 기능이 있는 것을 볼 수 있는데, 이 중에서 지금은 &lt;code&gt;init&lt;/code&gt;, &lt;code&gt;up&lt;/code&gt;, &lt;code&gt;ssh&lt;/code&gt; 만 알고 넘어가도 되겠다.&lt;br /&gt;
아래와 같이 입력해 실행한다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ boot2docker init
$ boot2docker up&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;boot2docker init&lt;/code&gt; 로 docker daemon 에 대한 VM 을 처음으로 준비한다.&lt;br /&gt;
그다음 &lt;code&gt;boot2docker up&lt;/code&gt; 로 docker daemon VM 을 실행시키는데 수십초 정도가 걸린다.&lt;a href=&quot;#fn2&quot; class=&quot;footnoteRef&quot; id=&quot;fnref2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Waiting for VM and Docker daemon to start...
........ooooooooo
Started.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그 이후에&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ boot2docker ssh&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;를 실행하여 접속하면&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ boot2docker ssh

                        ##         .
                  ## ## ##        ==
               ## ## ## ## ##    ===
           /&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;\___/ ===
      ~~~ {~~ ~~~~ ~~~ ~~~~ ~~~ ~ /  ===- ~~~
           \______ o           __/
             \    \         __/
              \____\_______/
 _                 _   ____     _            _
| |__   ___   ___ | |_|___ \ __| | ___   ___| | _____ _ __
| &amp;#39;_ \ / _ \ / _ \| __| __) / _` |/ _ \ / __| |/ / _ \ &amp;#39;__|
| |_) | (_) | (_) | |_ / __/ (_| | (_) | (__|   &amp;lt;  __/ |
|_.__/ \___/ \___/ \__|_____\__,_|\___/ \___|_|\_\___|_|
Boot2Docker version 1.8.0, build master : 7f12e95 - Tue Aug 11 17:55:16 UTC 2015
Docker version 1.8.0, build 0d03096
docker@boot2docker:~$&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;docker VM 에 접속되며 호스트 OS 가 아닌 bash 인것을 확인할 수 있다.&lt;br /&gt;
저 고래의 모습이 터미널에 출력되면 docker를 본격적으로 이용할 수 있는 모든 준비가 되었다는 것으로 이해해도 좋다. 🐳🐳🐳&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;hello-docker-를-위한-rstudio-server-띄우기&quot;&gt;Hello Docker! 를 위한 Rstudio server 띄우기&lt;/h2&gt;
&lt;p&gt;Docker 의 장점은 여러가지가 있다고 하는데 대표적으로 내세우는 장점이 배포성이라고 한다.&lt;br /&gt;
&lt;a href=&quot;https://hub.docker.com/&quot;&gt;Docker Hub&lt;/a&gt; 는 개발환경 세팅이 끝난 이미지들을 공유하는 곳인데,&lt;br /&gt;
지금 예로 들을 Rstudio server 의 경우도 환경세팅이 끝난 이미지를 찾아 바로 이용할 수 있다.&lt;br /&gt;
이 말은 Rstudio server 구축에 필요한 과정들을 쓸데없이 재발명하지 않고 사용할 수 있다는 것이다.&lt;br /&gt;
실제로 Rstudio server 구축은 어려우면 어렵지 쉬운 과제가 아니다.&lt;/p&gt;
&lt;p&gt;docker VM 에 접속된 상황에서&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker@boot2docker:~$ docker search rstudio-server&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;를 입력해 보자.&lt;br /&gt;
위의 명령어는 Docker Hub 에서 &amp;quot;rstudio-server&amp;quot; 란 검색어로 이미지를 검색하는 것이다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker@boot2docker:~$ docker search rstudio-server

NAME                                     DESCRIPTION                   STARS  OFFICIAL  AUTOMATED
rocker/rstudio                           RStudio Server image          107              [OK]
h2sp/cent65-rstudio-server                                             2                [OK]
mgymrek/docker-rstudio-server                                          1                [OK]
analyticsplatform/rstudio-server         Docker Images for RStudio...  0                [OK]
mjmg/centos-rstudio-opencpu-server       Latest CENTOS with rstudi...  0                [OK]
mjmgaro/fedora-rstudio-server            Latest Fedora with rstudi...  0                [OK]
mjmg/fedora-rstudio-opencpu-server       Latest FEDORA with rstudi...  0                [OK]
davislaboratory/docker-rstudio-serve...  rstudio server for Docker...  0                [OK]
mjmg/fedora-rstudio-server               Latest Fedora with rstudi...  0                [OK]
mjmg/centos-rstudio-opencpu-shiny-se...  Latest CENTOS with rstudi...  0                [OK]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;잘 보면 3번째 열에 &amp;quot;STARS&amp;quot; 라는 것이 있는데 Docker 사용자가 추천한 횟수를 의미한다.&lt;br /&gt;
가장 높은 별을 받은 첫번째 이미지를 우리 예제로 이용해 볼 것이다.&lt;/p&gt;
&lt;p&gt;첫번째 이미지의 명칭은 &amp;quot;rocker/rstudio&amp;quot; 이다.&lt;br /&gt;
이 이미지를 받고 컨테이너를 생성하여(&lt;em&gt;docker VM 에 Rstudio server 를 설치한다고 이해해도 좋다&lt;/em&gt;) Rstudio server 를 실행해 보겠다.&lt;br /&gt;
&lt;code&gt;docker run&lt;/code&gt; 명령이면 이 모든 것이 한번에 된다.&lt;br /&gt;
아래 커맨드를 입력해 실행해 보자.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker@boot2docker:~$ docker run --rm -p 8787:8787 rocker/rstudio&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;조금 복잡해 보일지 몰라도 핵심은 &lt;code&gt;docker run &amp;lt;이미지 이름&amp;gt;&lt;/code&gt; 이다.&lt;br /&gt;
&lt;code&gt;--rm&lt;/code&gt; , &lt;code&gt;-p&lt;/code&gt; 인자들은 부가적인 옵션으로 생각하면 되는데 &lt;code&gt;--rm&lt;/code&gt; 은 컨테이너 종료시 리소스들을 자동으로 반환해주고, &lt;code&gt;-p&lt;/code&gt; 는 포트번호를 직접 입력할 수 있게 한다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker@boot2docker:~$ docker run --rm -p 8787:8787 rocker/rstudio

[fix-attrs.d] applying owners &amp;amp; permissions fixes...
[fix-attrs.d] 00-runscripts: applying...
[fix-attrs.d] 00-runscripts: exited 0.
[fix-attrs.d] done.
[cont-init.d] executing container initialization scripts...
[cont-init.d] conf: executing...
[cont-init.d] conf: exited 0.
[cont-init.d] done.
[services.d] starting services
[services.d] done.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;무엇인가 촤라락 실행된다.&lt;br /&gt;
그리고 실행이 유지되는데, 바로 Rstudio server 를 가동중인 상태인 것이다. 포트번호를 8787로 부여했기 때문에 docker VM 의 IP에서 8787 번 포트로 접속하면 가동중인 Rstudio server 를 띄울 수 있게 된다.&lt;/p&gt;
&lt;p&gt;그런데 잠깐 docker VM 의 IP 를 모르는 상태에서 설명을 쭉쭉 해버리고 있었다.&lt;br /&gt;
IP는 &lt;code&gt;ifconfig&lt;/code&gt; 등으로 확인해 볼 수 있는데 잠깐 가동중인 Rstudio server 를 종료하고 bash 로 빠져 나와야 할 상황이다.&lt;br /&gt;
이럴땐 &lt;kbd&gt;ctrl&lt;/kbd&gt; + &lt;kbd&gt;C&lt;/kbd&gt; 를 눌러 bash 로 빠져나올 수 있다.&lt;br /&gt;
그리고 IP 확인을 위해&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker@boot2docker:~$ ifconfig&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;를 실행하여 &amp;quot;eth1&amp;quot; 의 IP 를 확인한다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker@boot2docker:~$ ifconfig

docker0   Link encap:Ethernet  HWaddr 02:42:22:E3:A5:EA
          inet addr:172.17.42.1  Bcast:0.0.0.0  Mask:255.255.0.0
          inet6 addr: fe80::42:22ff:fee3:a5ea/64 Scope:Link
          UP BROADCAST MULTICAST  MTU:1500  Metric:1
          RX packets:211 errors:0 dropped:0 overruns:0 frame:0
          TX packets:448 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:817705 (798.5 KiB)  TX bytes:48897 (47.7 KiB)

eth0      Link encap:Ethernet  HWaddr 08:00:27:D1:4E:08
          inet addr:10.0.2.15  Bcast:10.0.2.255  Mask:255.255.255.0
          inet6 addr: fe80::a00:27ff:fed1:4e08/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:1250 errors:0 dropped:0 overruns:0 frame:0
          TX packets:799 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:129451 (126.4 KiB)  TX bytes:118182 (115.4 KiB)

eth1      Link encap:Ethernet  HWaddr 08:00:27:3D:AA:C9
          inet addr:192.168.59.103  Bcast:192.168.59.255  Mask:255.255.255.0
          inet6 addr: fe80::a00:27ff:fe3d:aac9/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:465 errors:0 dropped:0 overruns:0 frame:0
          TX packets:226 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:53127 (51.8 KiB)  TX bytes:822933 (803.6 KiB)

lo        Link encap:Local Loopback
          inet addr:127.0.0.1  Mask:255.0.0.0
          inet6 addr: ::1/128 Scope:Host
          UP LOOPBACK RUNNING  MTU:65536  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;필자의 경우 &lt;code&gt;http://192.168.59.103:8787&lt;/code&gt; 가 Rstudio server 를 띄울 수 있는 주소가 된다.&lt;br /&gt;
다시 Rstudio server 컨테이너를 실행하기 위해&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker@boot2docker:~$ docker run --rm -p 8787:8787 rocker/rstudio&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 후 &lt;code&gt;http://192.168.59.103:8787&lt;/code&gt; 로 접속해 본다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/rssLogin.png&quot;&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;로그인 화면이 뜬다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;username : rstudio&lt;/li&gt;
&lt;li&gt;password : rstudio&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;로 로그인을 해보면&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/rss.png&quot;&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;Rstudio server 를 띄울 수 있고 웹상에서 Rstudio 를 이용할 수 있게 된다.&lt;br /&gt;
이렇게 해서 Docker 를 이용한 Rstudio server 이미지를 이용해 손쉽게 &amp;quot;Hello Docker!&amp;quot; 해보았다.&lt;br /&gt;
Docker 를 조금 공부한다면 다른 서비스들도 이러한 방법으로 어려운 구축과정 없이 이용할 수 있지 않을까?&lt;/p&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;Docker command 를 사용하던 도중에도 Docker Toolbox 를 설치하는것을 추천하는 경고메세지가 나오기도 한다 (Docker Toolbox (https://docker.com/toolbox) is the recommended install method)&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn2&quot;&gt;&lt;p&gt;&lt;code&gt;boot2docker up&lt;/code&gt; 대신 &lt;code&gt;boot2docker boot&lt;/code&gt;, &lt;code&gt;boot2docker start&lt;/code&gt; 도 똑같다&lt;a href=&quot;#fnref2&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Sat, 28 Jan 2017 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2017/01/28/Docker_Rstudio_server.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2017/01/28/Docker_Rstudio_server.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>R에서 다수의 패키지 편하게 불러오기</title>
        <description>&lt;h2 id=&quot;상황&quot;&gt;상황&lt;/h2&gt;
&lt;p&gt;R 에서 여러 개의 패키지를 사용해야 하는 프로그램을 작성해야 한다면 &lt;code&gt;library()&lt;/code&gt; 함수로 사용하는 패키지를 불러오는 코드를 서두에 작성하는 전략을 사용할 것이다. &lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;package1&amp;quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;package2&amp;quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;package3&amp;quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;package4&amp;quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;package5&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위의 코드는 5개의 패키지를 로드하는 코드로 볼 수 있는데, 만약 필요로 하는 패키지의 수가 5개가 아닌 수십 개가 된다면 수십개의 &lt;code&gt;library()&lt;/code&gt; 함수를 작성하게 될 것이다.&lt;br /&gt;
아쉽게도 &lt;code&gt;library()&lt;/code&gt; 함수는 불러올 대상이 되는 패키지를 복수개로 입력할 수 없어&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;package1&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;package2&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;package3&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;package4&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;package5&amp;quot;&lt;/span&gt;))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Error : 
  &amp;#39;package&amp;#39;는 반드시 길이가 1이어야 합니다&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;와 같은 꼴로는 사용할 수 없기 때문에 코드가 불필요하게 길어진다.&lt;br /&gt;
반복문을 이용해 굳이 해결책을 찾자면 벡터형 문자열을 이용할 수 있을 것인데&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;for(i in &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;package1&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;package2&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;package3&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;package4&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;package5&amp;quot;&lt;/span&gt;)){
  &lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(i, &lt;span class=&quot;dt&quot;&gt;character.only =&lt;/span&gt; T)
} &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;중간에 패키지 로드가 실패했을 경우 (예를 들어 &amp;quot;package3&amp;quot; 호출이 실패)&lt;br /&gt;
이후의 패키지들 (&amp;quot;package4&amp;quot;, &amp;quot;package5&amp;quot;) 이 로드되지 않는 등 실제로 사용하기엔 불편한 점들이 있을 것이다.&lt;/p&gt;
&lt;p&gt;또한, 위에 제시한 어떠한 방법이든&lt;br /&gt;
자신이 만든 프로그램이 다수의 패키지에 의존되면 의존될수록 타인이 자신의 프로그램을 이용할 때 오류가 일어날 가능성도 커진다.&lt;br /&gt;
타인은 프로그램에 의존된 패키지가 모두 설치되어 있을 리 없다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;pacman-패키지의-p_load-함수&quot;&gt;pacman 패키지의 &lt;code&gt;p_load()&lt;/code&gt; 함수&lt;/h2&gt;
&lt;p&gt;이처럼 재현 가능한 연구를 방해하는 요소들을 없애기 위해 고민하다가 pacman package 를 알게 되었고&lt;br /&gt;
pacman 패키지에서 제공되는 여러 함수 중 &lt;code&gt;p_load()&lt;/code&gt; 함수의 도움을 가장 많이 받고 있다.&lt;br /&gt;
일반적인 상황에서 &lt;code&gt;p_load()&lt;/code&gt; 함수는 위에 제시한 불편한 문제들을 잘 해결해 준다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;pacman::&lt;span class=&quot;kw&quot;&gt;p_load&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;package1&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;package2&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;package3&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;package4&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;package5&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;다수의 패키지를 불러올 때 복수의 문자열 벡터를 입력받을 수 있어 코드 길이를 줄일 수 있다.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;불러오길 희망하는 다수의 패키지 중에&lt;br /&gt;
설치가 되지 않은 패키지가 있어도 알아서 설치를 진행한 후 설치가 잘 완료되면 불러오는 기능이 한 번에 수행된다.&lt;br /&gt;
예를 들어 &amp;quot;package3&amp;quot; 이란 패키지가 설치되어있지 않은 상황이라 하더라도&lt;br /&gt;
오류와 함께 코드실행이 멈추는 것이 아니라 CRAN 에 &amp;quot;package3&amp;quot; 을 찾은 후 패키지 설치완료 후 불러온다.&lt;br /&gt;
CRAN 에 존재하지 않는 패키지명칭을 적지 않는 한 &lt;code&gt;p_load()&lt;/code&gt; 함수로 패키지를 로드할 때 오류가 날 일은 거의 없을 것이다.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;코드 중간중간 필요한 시점에서 &lt;code&gt;library()&lt;/code&gt; 호출을 할 수 도 있겠으나, 프로젝트를 시작하기 앞서 필요한 모든 패키지를 보여주기 위해 보통 서두에 몰아 패키지를 호출하는 경우가 많은것 같다&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Thu, 12 Jan 2017 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2017/01/12/multiple_load_packages.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2017/01/12/multiple_load_packages.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>R에서 Startup option 설정하기 (on Mac OSX)</title>
        <description>&lt;p&gt;만약 R에서 꾸준히 + 자주자주 + 빈번하게 활용하는 패키지가 있다면 매번 &lt;code&gt;library()&lt;/code&gt; 로 호출하는 것이 귀찮을 수 있다.&lt;br /&gt;
나의 경우 dplyr package 를 항시 사용하는 편이어서 R이 켜질 때 자동으로 &lt;code&gt;library(dplyr)&lt;/code&gt; 이 실행됐으면 했는데 찾아보니 R은 이런 경우를 생각해 Startup option 들을 제공하고 있다는 것을 알았다.&lt;/p&gt;
&lt;p&gt;여러 방법이 있지만 내가 볼 때 가장 간편한 방법은&lt;br /&gt;
자신의 홈 디렉토리에 &amp;quot;.Rprofile&amp;quot; 이란 숨김파일을 만든 후&lt;br /&gt;
이안에 자주 활용하는 패키지를 호출하는 명령어를 미리 적어 놓는 것이다.&lt;/p&gt;
&lt;p&gt;자세히 정리하면 아래와 같다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;홈-디렉토리로-들어가-.rprofile-숨김파일-만들기&quot;&gt;홈 디렉토리로 들어가 &amp;quot;.Rprofile&amp;quot; 숨김파일 만들기&lt;/h2&gt;
&lt;p&gt;쉘에서 틸드(~)문자는 사용자의 홈 디렉토리를 의미하는 특별한 기호이다.&lt;br /&gt;
터미널을 실행한 후 틸드문자를 이용해 사용자 홈디렉토리로 이동한다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd ~&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;아마도 &amp;quot;.Rprofile&amp;quot; 파일이 존재할 수도 있다. 물론 없을 수도 있고 상황에 따라 다르다.&lt;br /&gt;
상관없이 텍스트에디터를 이용해 &amp;quot;.Rprofile&amp;quot; 를 수정하거나 새로 만들면 되겠다.&lt;br /&gt;
간편히 nano 를 이용한다고 치면&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nano .Rprofile&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;를 통해 &amp;quot;.Rprofile&amp;quot; 를 열거나 새로 만들게 된다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;startup-커멘드-및-옵션들-작성하기&quot;&gt;Startup 커멘드 및 옵션들 작성하기&lt;/h2&gt;
&lt;p&gt;&amp;quot;.Rprofile&amp;quot; 에 무언가를 작성할 것인데&lt;br /&gt;
바로 이곳에 &lt;code&gt;library(dplyr)&lt;/code&gt; 과 같은 것을 적고 저장시키면&lt;br /&gt;
앞으로 R을 실행하자마자 &lt;code&gt;library(dplyr)&lt;/code&gt; 명령어가 자동으로 실행된다.&lt;br /&gt;
이러한 간단한 원리를 이용해 패키지 자동호출 외에도 &lt;code&gt;options()&lt;/code&gt; set 을 미리 지정하는 것도 매우 좋은 Tip이 될 수 있겠다.&lt;/p&gt;
&lt;p&gt;나의 &amp;quot;.Rprofile&amp;quot; 을 소개하자면 이렇다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;options&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;help_type =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;html&amp;quot;&lt;/span&gt;) ## 1
&lt;span class=&quot;kw&quot;&gt;options&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;stringsAsFactors =&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;FALSE&lt;/span&gt;) ## 2

pacman::&lt;span class=&quot;kw&quot;&gt;p_load&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;useful.lovetoken&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;knitr&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;dplyr&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;ggplot2&amp;quot;&lt;/span&gt;) ## 3

opts_chunk$&lt;span class=&quot;kw&quot;&gt;set&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;fig.path =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;output/figure/&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;fig.align =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;center&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;out.width =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;80%&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;warning =&lt;/span&gt; F, &lt;span class=&quot;dt&quot;&gt;message =&lt;/span&gt; F) ## 4

&lt;span class=&quot;kw&quot;&gt;theme_set&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;theme_bw&lt;/span&gt;()) ## 5&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;함수 도움말을 볼 때 기본적으로 html 포맷의 형태에 문서가 열리는걸로 고정시켰다&lt;a href=&quot;#fn2&quot; class=&quot;footnoteRef&quot; id=&quot;fnref2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;read.csv()&lt;/code&gt; 와 같은 함수에서 &lt;code&gt;stringsAsFactors&lt;/code&gt; 인자값이 &lt;code&gt;getOption(&amp;quot;stringsAsFactors&amp;quot;)&lt;/code&gt; 에 의존되는데 이를 &lt;code&gt;FALSE&lt;/code&gt; 로 고정시켰다&lt;/li&gt;
&lt;li&gt;필자가 자주쓰는 패키지로 R을 실행할 때 무조건 호출될 패키지 4개를 pacman 을 통해 호출했다&lt;/li&gt;
&lt;li&gt;Rmarkdown 을 쓰는 경우 knitr 패키지를 통해 코드청크 글로벌 옵션들을 지정시켰다&lt;/li&gt;
&lt;li&gt;ggplot2 의 메인테마에 대한 설정이다&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;여러분도 여러분 나름의 &amp;quot;.Rprofile&amp;quot; 를 작성해 보시길 🙃&lt;br /&gt;
그리고 본 글은 Mac OS X 를 기준으로 작성한 경우이지만, 리눅스이어도 홈 디렉토리의 경로만 약간 다를 뿐 틸드문자를 이용한 방법은 똑같다고 보면 되겠다.&lt;br /&gt;
윈도우의 경우는 R이 설치된 &amp;quot;C:\Program Files\R\R-***\etc\&amp;quot; 이곳에 &amp;quot;.Rprofile&amp;quot; 를 작성하면 되겠다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.onthelambda.com/2014/09/17/fun-with-rprofile-and-customizing-r-startup/&quot;&gt;Fun with .Rprofile and customizing R startup&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://stat.ethz.ch/R-manual/R-devel/library/base/html/Startup.html&quot;&gt;&lt;code&gt;?Startup&lt;/code&gt; in R&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;vi, vim 들도 있지만 이걸 아시는분들을 위한 글은 아닐수도... 있을것 같다&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn2&quot;&gt;&lt;p&gt;IDE 에 따라 도움말 포맷이 유동적으로 설정된다. 이걸 무조건 html type 으로만 열리게 고정시킨 경우이다&lt;a href=&quot;#fnref2&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Tue, 20 Dec 2016 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2016/12/20/RStartup_Option.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2016/12/20/RStartup_Option.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>Google 에서 사용하는 R 코딩 스타일 규약</title>
        <description>&lt;p&gt;구글에서는 코드를 작성할 때 아래 링크로 정리된 규약을 따라 프로그램을 작성한다고 한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://google.github.io/styleguide/Rguide.xml&quot;&gt;Google&#39;s R Style Guide&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;여러가지 규칙이 있고 이에 대한 예제가 상세히 제시되어 있다.&lt;br /&gt;
간단하게 주요 10가지 사항만 정리해 보면&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;한 줄에 80자 이상을 작성하지 않는다.&lt;/li&gt;
&lt;li&gt;단일명령문에는 중괄호 &lt;code&gt;{}&lt;/code&gt; 를 사용하지 않는다.&lt;/li&gt;
&lt;li&gt;모든 연산자에는 양 좌, 우에 띄어쓰기를 하여 자간을 맞춘다.&lt;/li&gt;
&lt;li&gt;쉼표 &lt;code&gt;,&lt;/code&gt; 는 앞에 공백을 두지 않고 뒤에만 넣는다.&lt;/li&gt;
&lt;li&gt;들여쓰기는 Space를 이용해 2칸으로 정한다. Tab 을 사용하지 않는다.&lt;/li&gt;
&lt;li&gt;괄호와 대괄호에서 여는곳과 닫는곳에 공백을 넣지 않는다.&lt;/li&gt;
&lt;li&gt;할당연산자는 &lt;code&gt;&amp;lt;-&lt;/code&gt; 를 사용한다. &lt;code&gt;=&lt;/code&gt; 를 사용하지 않는다.&lt;/li&gt;
&lt;li&gt;함수의 정의에서 인수를 설정할 땐 기본값이 없는 인수를 먼저 나열하고, 그 뒤에 기본값을 갖는 인수를 나열한다.&lt;/li&gt;
&lt;li&gt;프로그램에선 오류를 만들 가능성이 있는 &lt;code&gt;attach()&lt;/code&gt; 를 사용하지 않는다.&lt;/li&gt;
&lt;li&gt;(구글은 일관성을 위하여 세미콜론을 불필요하다고 판단했다) 세미콜론 &lt;code&gt;;&lt;/code&gt; 으로 줄을 끝내거나 같은 줄에 둘 이상의 명령을 넣지 않는다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;정도가 된다.&lt;/p&gt;
&lt;p&gt;나름대로 정리된 Code convention 을 읽지 않았을 이전에는 항상 R 스크립트가 뒤죽박죽인 면이 있었는데 앞으론 통일시킬 수 있을 것 같다.&lt;br /&gt;
무엇보다 중요한 건 코딩시 생기는 불필요한 코딩 스타일의 선택에 대한 고민을 줄여 줄 수 있을 거라 생각된다.&lt;/p&gt;
</description>
        <pubDate>Sun, 18 Dec 2016 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2016/12/18/RCodeConventions.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2016/12/18/RCodeConventions.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>Getting Started StackOverflow</title>
        <description>&lt;a href=&quot;http://stackoverflow.com/&quot;&gt;&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/SO_logo.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이 글을 쓰는 시점 스택오버플로우&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;를 눈팅만 한지 2년 가까이 되었다.&lt;br /&gt;
나는 굳이 분류하자면 개발군과 비개발군 중 비개발군에 속하는 사람이다.&lt;br /&gt;
따라서 스택오버플로우에 있는 글들을 눈팅만 해도 충분하게 넘칠 정도로 얻어갔다.&lt;/p&gt;
&lt;p&gt;그런데 요즘시대 개발, 비개발 분류하는것이 의미가 없어질 정도로 다양하게 섭렵해야 하는 시대가 아닌가?&lt;br /&gt;
다양한 컴퓨터언어와 오픈소스도구들을 이것저것 만지작하면서 최소한 개발자들과의 협업이 가능한 수준의 배경지식과 개발능력을 함양할 필요가 있다고 생각이 바뀌기 시작했다.&lt;br /&gt;
그리고 눈팅만 2년째 하다 보니 입문자 입장에서의(나를 위한) 얼토당토않은 낮은 수준의 질문글이 보이지 않는다는 것을 느끼게 되었다.&lt;a href=&quot;#fn2&quot; class=&quot;footnoteRef&quot; id=&quot;fnref2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;br /&gt;
그래서 내가 생각하는 낮은 수준의 질문을 발번역해 영어로 작문하고, 작성된 글을 올리기 위하여 스택오버플로우에 로그인하였다.&lt;a href=&quot;#fn3&quot; class=&quot;footnoteRef&quot; id=&quot;fnref3&quot;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이때부터 스택오버플로우의 사용방법과, 생태계의 메커니즘을 좀 정확히 알고 싶은 마음이 생겼는데&lt;br /&gt;
이를 계기로 이글을 작성한 다음 적극적으로 애용해보려 한다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;스택오버플로우-간단-소개&quot;&gt;스택오버플로우 간단 소개&lt;/h2&gt;
&lt;p&gt;스택오버플로우는 2008년경에 만들어진 프로그래머들 사이의 질문/답변 커뮤니케이션 사이트이다.&lt;br /&gt;
조엘 스폴스키 등 2명이 기존의 있던 Q&amp;amp;A 사이트인 Experts_Exchange를 더 개방시킨 웹사이트로서 만들어진 사이트라고 한다.&lt;br /&gt;
만들어진지 8년만에 개발관련된 구글링을 하면 절반이 넘는 게시글이 스택오버플로우로 연결되어 있을 정도로 아주 중요한 웹사이트가 되었다.(&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_Overflow&quot;&gt;wiki 참고&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;스택오버플로우의-운영-원리&quot;&gt;스택오버플로우의 운영 원리&lt;/h2&gt;
&lt;p&gt;스택오버플로우는 reputation 즉 명성도라는 것을 이용한다. (평판이라고도 한다)&lt;br /&gt;
평판제도는 스택오버플로우를 사용할 때 특정 자격을 부여하는 등 사용 동기부여를 주기도 한다.&lt;br /&gt;
이 제도 때문에 사용자들이 좀 더 정확한 질문, 그에 대한 알찬 답변을 상호적으로 주고 받을 수 있는 좋은 메커니즘으로 작용하고 있고, 자연스럽게 주제와 벗어난 질문과 글들이 필터링 되는 좋은 인프라가 뿌리잡았다고 생각한다.&lt;br /&gt;
나도 특정 커뮤니티를 운영하는 사람으로서 부러운, 그리고 여러모로 본받고싶은 생태계이다.&lt;/p&gt;
&lt;p&gt;명성도를 얻는 방법은 구체적인 방법을 뒤에 작성할 것이지만, 결국은 질문과 답변을 주고받으면 자연스럽게 오르는 규칙이다.&lt;br /&gt;
우선 최초 가입시점 자신의 명성도는 1점으로 시작한다. 아래 그림은 Profile로 들어가본 모습이다. &lt;a href=&quot;#fn4&quot; class=&quot;footnoteRef&quot; id=&quot;fnref4&quot;&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/SO_1.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;명성도 외에도 또 다른 숫자가 점과 함께 표기되어 있다.&lt;br /&gt;
이건 배지(Badge)의 개수를 의미한다.&lt;br /&gt;
배지는 있어도 그만 없어도 그만이지만 있으면 기분이 흡족해지는 그런 물건이 아닌가?&lt;br /&gt;
평판도와 함께 각 배지 종류별 갯수도 함께 표시되어진다.&lt;br /&gt;
배지의 종류는 골드, 실버, 브론즈로 3가지가 나뉘는데 지금 나는 브론즈 배지가 2개가 있다는 것을 의미한다.&lt;br /&gt;
활동을 열심히 해서 평판도와 여러 가지 종류의 배지를 획득하게 되면 Profile 은 이런식으로 발전하게 될 것이다. (R의 knitr 패키지 개발자 Yihui Xie 의 Profile 을 예로 들어보았다)&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/SO_2.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;배지와는 다르게 명성도는 스택오버플로우 이용에 직접적인 영향을 끼친다.&lt;br /&gt;
직접적인 영향이라고 해서 차별이 있는 것이 아니다.&lt;br /&gt;
명성도가 없어도 스택오버플로우를 이용하는데 전혀 문제가 없다.&lt;br /&gt;
다만 일종의 특권(Privilege)이 생기는 것으로 생각하는 게 좋다.&lt;/p&gt;
&lt;p&gt;특권은 명성도가 일정치를 초과했을 시점부터 생긴다.&lt;br /&gt;
표로 정리해보면 이렇다. (지금상황에서 무슨 의미인지 정확하게 모르는 특권은 번역하지 않고 영어로 그대로 놔두었는데, 알게 되면 번역하겠다)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;http://stackoverflow.com/help/privileges?tab=all&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;
&lt;colgroup&gt;
&lt;col style=&quot;width: 8%&quot; /&gt;
&lt;col style=&quot;width: 91%&quot; /&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr class=&quot;header&quot;&gt;
&lt;th style=&quot;text-align: left;&quot;&gt;명성도&lt;/th&gt;
&lt;th style=&quot;text-align: left;&quot;&gt;특권내용&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;25,000&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;스택오버플로우 사이트의 내부분석을 위한 Google analytics 접근이 가능&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;20,000&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;신뢰할 수 있는 사용자로 판단되어 스택오버플로우의 모든 질문글에 대해 편집, 삭제 권한이 부여됨&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;15,000&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;보호된 질문을 사용할 수 있음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;10,000&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;access to moderator tools : Access reports, delete questions, review reviews&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;5,000&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;모든 글에 대해 태그를 수정할 수 있음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;3,000&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;cast close and reopen votes : Help decide whether posts are off-topic or duplicates&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;2,500&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;어떤 태그가 다른것과 동일한 의미를 가지는지 결정할 수 있음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;2,000&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;이미 올려진 질문, 질문에 대한 답변을 즉시 편집할 수 있음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;1,500&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;새로운 태그를 만들 수 있음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;1,000&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;established user : You&#39;ve been around for a while; see vote counts&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;1,000&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;특정한 사람들과 대화할 수 있는 대화방을 만들 수 있음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;500&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;access review queues : Access first posts and late answers review queues&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;250&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;자신의 질문글에 대한 투표를 종료할 수 있고, 이후에 종료된 것을 다시 열 수 있음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;200&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;광고를 줄일 수 있는 옵션을 사용할 수 있음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;125&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;질문과 질문의 답변글에 대해 upvote 외에도 downvote 를 할 수 있음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;100&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;위키 커뮤니티에 협업할 수 있음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;100&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;대화방을 만들 수 있음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;100&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;문서에 대하여 제안된 변경사항에 대하여 승인 및 거부할 수 있음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;75&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;자신의 명성을 보상으로 걸 수 있는 질문을 할 수 있음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;50&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;다른 사람의 게시물에 댓글을 달 수 있음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;20&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;대화방에 참석이 가능&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;15&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;신고기능(Flag)을 이용할 수 있음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;15&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;답변글에 대해 투표가 가능, 단 upvote 만 할 수 있음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;10&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;신규유저에 대한 제한처리 기능 해제&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;10&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;create wiki posts : Create answers that can be easily edited by most users&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;5&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;participate in meta : Discuss the site itself: bugs, feedback, and governance&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;1&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;질문 혹은 답변글을 작성할 수 있음&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;지금 명성도가 1인 나는 질문과 답변글을 작성할 수 있다.&lt;br /&gt;
그런데 예를들어 질문을 열심히하고 답변을 주고받으며 명성도가 15점 이상 되면 다른 질문과 답변에 대해서 투표를 할 수 있다.&lt;br /&gt;
정확히 말하면 upvote 가 가능한데 좋은 Q&amp;amp;A 글이라 생각되는 것에 대해서 점수를 준다고 생각하면 된다.&lt;br /&gt;
그리고 upvote 를 받은 글의 주인은 명성도가 오르게 된다.&lt;br /&gt;
반대로 downvote 도 가능하다. (단 명성도 125 필요)&lt;br /&gt;
스택오버플로우는 이렇게 투표를 받은 질문글이 상위로 노출되어 좀 더 가치 있는 질문글과 답변으로 자가발전하게 되는 식이다.&lt;/p&gt;
&lt;p&gt;명성도를 얻는 방법은 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;내가 작성한 질문에 upvote 가 되면 +5&lt;/li&gt;
&lt;li&gt;내가 작성한 답변에 upvote 가 되면 +10&lt;/li&gt;
&lt;li&gt;내가 작성한 답변이 질문자에 의해 승인이 되면 +15&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;see-also&quot;&gt;See also&lt;/h2&gt;
&lt;p&gt;스택오버플로우의 가장 아쉬운 점은 영어를 사용해야 한다는 점이다.&lt;br /&gt;
개발 및 코드와 함께 작성될 질문글은 많은 부가적인 설명과 함께 작성하게 될 가능성이 높은데&lt;br /&gt;
영어를 완벽하게 구사하지 못한다면 자신이 표출하고 싶은 의미를 서술하기 힘들 것이다.&lt;/p&gt;
&lt;p&gt;이런 이유때문에 아마도 눈팅만 2년째이었을 수도 있다.&lt;br /&gt;
여하튼 이런 애로사항을 많은 사람이 가지고 있었다는 걸 StackOverflow in Korean (이하 &lt;a href=&quot;(http://stackoverflow-in-korean.github.io/)&quot;&gt;SOK&lt;/a&gt;) 를 통해 알 수 있었다.&lt;br /&gt;
스택오버플로우는 내부적으로 Non-english 를 위한 베타버전을 운용하고 있는데&lt;br /&gt;
한국을 위한 스택오버플로우를 만들기위해 SOK 에서 열심히 온라인 활동을 했었지만 &lt;a href=&quot;http://stackoverflow-in-korean.github.io/docs/%EC%97%B0%ED%98%81/&quot;&gt;기각&lt;/a&gt;되었다고 한다.&lt;br /&gt;
진작에 이런 활동을 알고 있었다면 부족하게나마 도움을 주었을텐데 하는 아쉬움이 많이 든다.&lt;/p&gt;
&lt;p&gt;하지만 해결되지 않은 이 애로사항을 속으로 애타게 해결하고자 하는 분들이 많았을 것이라 본다.&lt;br /&gt;
때문에 이러한 사이트들이 이후에 생긴 게 아닐까?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://dolgo.net/&quot;&gt;돌고넷&lt;/a&gt; (http://dolgo.net)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://hashcode.co.kr&quot;&gt;Hashcode&lt;/a&gt; (http://hashcode.co.kr)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow-in-korean.github.io/&quot;&gt;StackOverflow in Korean&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/tour&quot;&gt;Welcome to Stack Overflow&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;StackOverflow 줄여서 SO라고들 많이 표현한다&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn2&quot;&gt;&lt;p&gt;이렇게 느끼게 된 이유는 무엇일까? 아마도 모른다는 것을 모르는 단계에서, 모르는걸 알게 된 단계로 바뀌어서 그런 걸까!&lt;a href=&quot;#fnref2&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn3&quot;&gt;&lt;p&gt;눈팅시절 가입도 안하고 비로그인 상태에서 스택오버플로우를 이용했었다&lt;a href=&quot;#fnref3&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn4&quot;&gt;&lt;p&gt;굳이 Profile 로 들어가서 확인하지 않아도 스택오버플로우의 최상단 배너에 명성도를 확인할 수 있다&lt;a href=&quot;#fnref4&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Sun, 11 Dec 2016 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/etc/2016/12/11/StackOverflow.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/etc/2016/12/11/StackOverflow.html</guid>
        
        
        <category>etc</category>
        
      </item>
    
      <item>
        <title>R에서 모델적합에 사용되는 formula 인자식 사용부분에 대한 고찰</title>
        <description>&lt;p&gt;R을 이용한 모델링을 할 때 &lt;code&gt;formula&lt;/code&gt; 인자값을 어떤 식으로 입력해야 하는지 정리해 볼 필요가 있다.&lt;br /&gt;
대표적으로 &lt;code&gt;lm()&lt;/code&gt; 함수의 첫 번째 인자에 대한 입력값을 예로 들 수 있을 것이다.&lt;br /&gt;
이 인자값에는 약속에 의해 정해진 기호(operator)를 이용하여 모델의 뼈대를 설정할 수 있다.&lt;br /&gt;
몇가지의 기호만 알고 이를 조합한다면 일반적인 뼈대를 구성하는데 문제가 생기진 않을 것이다.&lt;/p&gt;
&lt;p&gt;(본 글에서 사용될 기초데이터는 &lt;code&gt;mtcars&lt;/code&gt; 이다.)&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;head&lt;/span&gt;(mtcars)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##                    mpg cyl disp  hp drat    wt  qsec vs am gear carb
## Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4
## Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4
## Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1
## Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1
## Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2
## Valiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;기호&quot;&gt;&amp;quot;~&amp;quot; 기호&lt;/h2&gt;
&lt;p&gt;기본적으로 &lt;code&gt;formula&lt;/code&gt; 인자값의 입력은 종속변수를 앞에 쓰고 독립변수를 뒤에 쓰게 되는데&lt;br /&gt;
종속변수와 독립변수를 구분 짓는 기호는 &amp;quot;~&amp;quot; 이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;lm&lt;/span&gt;(mpg ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;wt, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; mtcars)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = mpg ~ wt, data = mtcars)
## 
## Coefficients:
## (Intercept)           wt  
##      37.285       -5.344&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위의 단순선형회귀적합 코드를 살펴보자.&lt;br /&gt;
&lt;code&gt;lm()&lt;/code&gt; 함수의 첫 번째 인자입력값을 보면 &lt;code&gt;mpg ~ wt&lt;/code&gt; 로 되어있다.&lt;br /&gt;
왼쪽 맨 앞의 &lt;code&gt;mpg&lt;/code&gt; 는 종속변수로 지정하고, 오른쪽 뒤에 있는 &lt;code&gt;wt&lt;/code&gt; 는 독립변수로 지정하겠다는 의미가 된다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;기호-1&quot;&gt;&amp;quot;+&amp;quot; 기호&lt;/h2&gt;
&lt;p&gt;독립변수를 &lt;code&gt;wt&lt;/code&gt; 뿐만 아니라 &lt;code&gt;cyl&lt;/code&gt; 변수까지 고려하는 다중회귀분석을 하고 싶다면 &amp;quot;+&amp;quot; 기호를 이용해 고려대상이 되는 변수를 추가시킬 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;lm&lt;/span&gt;(mpg ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;wt +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;cyl, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; mtcars)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = mpg ~ wt + cyl, data = mtcars)
## 
## Coefficients:
## (Intercept)           wt          cyl  
##      39.686       -3.191       -1.508&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그런데 만약 자신이 가지고 있는 데이터셋에 종속변수를 설명시킬 독립변수들이 이미 모두 포진되어있는 상태라면, 그리고 그 독립변수들을 모두 고려한 다중회귀적합을 시키고 싶다면 어떻게 해야 할까?&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;lm&lt;/span&gt;(mpg ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;cyl +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;disp +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;hp +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;drat +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;wt +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;qsec +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;vs +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;am +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;gear +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;carb, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; mtcars)  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = mpg ~ cyl + disp + hp + drat + wt + qsec + vs + 
##     am + gear + carb, data = mtcars)
## 
## Coefficients:
## (Intercept)          cyl         disp           hp         drat  
##    12.30337     -0.11144      0.01334     -0.02148      0.78711  
##          wt         qsec           vs           am         gear  
##    -3.71530      0.82104      0.31776      2.52023      0.65541  
##        carb  
##    -0.19942&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이런 식으로 고려대상이 되는 독립변수의 명칭을 모두 적은 다음&lt;br /&gt;
사이사이에 &amp;quot;+&amp;quot; 기호를 무식하게 넣어주어야 하는 상황이다.&lt;br /&gt;
하지만 위의 코딩은 매우 비효율적 🙄 손이 아파질 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;기호-2&quot;&gt;&amp;quot;.&amp;quot; 기호&lt;/h2&gt;
&lt;p&gt;이를 대비해 특수하게 약속된 &amp;quot;.&amp;quot; 기호를 이용하면 좋다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;lm&lt;/span&gt;(mpg ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;., &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; mtcars)  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = mpg ~ ., data = mtcars)
## 
## Coefficients:
## (Intercept)          cyl         disp           hp         drat  
##    12.30337     -0.11144      0.01334     -0.02148      0.78711  
##          wt         qsec           vs           am         gear  
##    -3.71530      0.82104      0.31776      2.52023      0.65541  
##        carb  
##    -0.19942&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;quot;.&amp;quot; 기호는 &amp;quot;전부&amp;quot; 의 의미를 가진다.&lt;br /&gt;
위의 코드는 종속변수로 이미 배정된 mpg 이외의 모든 변수를 독립변수로 고려하라 라는 의미가 된다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;기호-3&quot;&gt;&amp;quot;-&amp;quot; 기호&lt;/h2&gt;
&lt;p&gt;&amp;quot;+&amp;quot; 기호의 반대는 &amp;quot;-&amp;quot; 이다. 의미 역시 반대이다.&lt;br /&gt;
고려대상에서 추가하는 &amp;quot;+&amp;quot; 와 다르게 &amp;quot;-&amp;quot; 는 고려대상에서 제외시킨다.&lt;br /&gt;
&amp;quot;.&amp;quot; 기호를 통해 모든 독립변수를 배정했는데, 여기서 &lt;code&gt;cyl&lt;/code&gt; 변수만은 독립변수에서 제외하고 싶을 경우&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;lm&lt;/span&gt;(mpg ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;. -&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;cyl, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; mtcars)  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = mpg ~ . - cyl, data = mtcars)
## 
## Coefficients:
## (Intercept)         disp           hp         drat           wt  
##    10.96007      0.01283     -0.02191      0.83520     -3.69251  
##        qsec           vs           am         gear         carb  
##     0.84244      0.38975      2.57743      0.71155     -0.21958&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이렇게 &amp;quot;-&amp;quot; 기호를 활용하면 된다.&lt;/p&gt;
&lt;p&gt;한 가지 덧붙이자면 회귀적합시 기본적으로 절편(intercept)을 고려하는 회귀적합을 하게 되는데, 절편이 0인 모델로 적합하고 싶은 경우 절편항을 제외시켜야 할 것이다.&lt;br /&gt;
&amp;quot;-&amp;quot; 기호를 아래와 같이 이용하면 된다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;lm&lt;/span&gt;(mpg ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;. -&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; mtcars)  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = mpg ~ . - 1, data = mtcars)
## 
## Coefficients:
##      cyl      disp        hp      drat        wt      qsec        vs  
##  0.35083   0.01354  -0.02055   1.24158  -3.82613   1.19140   0.18972  
##       am      gear      carb  
##  2.83222   1.05426  -0.26321&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;결과를 확인해 보면 항시 언급되었던 절편항 &amp;quot;(Intercept)&amp;quot; 이 없어진 것을 확인할 수 있다.&lt;br /&gt;
참고로 아래와 같이 해도 절편항을 제외한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;lm&lt;/span&gt;(mpg ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;. +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; mtcars)  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = mpg ~ . + 0, data = mtcars)
## 
## Coefficients:
##      cyl      disp        hp      drat        wt      qsec        vs  
##  0.35083   0.01354  -0.02055   1.24158  -3.82613   1.19140   0.18972  
##       am      gear      carb  
##  2.83222   1.05426  -0.26321&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;기호-4&quot;&gt;&amp;quot;:&amp;quot; 기호&lt;/h2&gt;
&lt;p&gt;회귀적합에서 상호작용에 대해 고려한다면 &amp;quot;:&amp;quot; 기호를 이용하여 상호작용항을 부여할 수 있다.&lt;br /&gt;
만약 종속변수 &lt;code&gt;mpg&lt;/code&gt; 에 대해 설명하는 독립변수를 &lt;code&gt;wt&lt;/code&gt;, &lt;code&gt;cyl&lt;/code&gt; 2개 설정하고,&lt;br /&gt;
이 두 변수의 상호작용까지 고려하고자 한다면 이렇게 하면 된다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;lm&lt;/span&gt;(mpg ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;wt +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;cyl +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;wt:cyl, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; mtcars)  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = mpg ~ wt + cyl + wt:cyl, data = mtcars)
## 
## Coefficients:
## (Intercept)           wt          cyl       wt:cyl  
##     54.3068      -8.6556      -3.8032       0.8084&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그런데 고려대상인 독립변수가 3개 이상, 그리고 독립변수의 조합별 상호작용을 고려하게 된다면 골치가 아플 수 있다.&lt;br /&gt;
예를 들어 &lt;code&gt;mpg&lt;/code&gt; 에 대해 설명하는 독립변수를 &lt;code&gt;wt&lt;/code&gt;, &lt;code&gt;cyl&lt;/code&gt;, &lt;code&gt;gear&lt;/code&gt; 3개이고, 3개의 모든 조합에 대해 상호작용을 고려한다면 &lt;code&gt;formula&lt;/code&gt; 인자값이 아래처럼 매우 길게 된다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;lm&lt;/span&gt;(mpg ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;wt +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;cyl +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;gear +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;wt:cyl +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;wt:gear +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;cyl:gear +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;wt:cyl:gear, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; mtcars)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = mpg ~ wt + cyl + gear + wt:cyl + wt:gear + cyl:gear + 
##     wt:cyl:gear, data = mtcars)
## 
## Coefficients:
## (Intercept)           wt          cyl         gear       wt:cyl  
##     47.3853     -10.4502      -0.8957       2.2704       0.5459  
##     wt:gear     cyl:gear  wt:cyl:gear  
##      0.3527      -0.8794       0.1001&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;기호-5&quot;&gt;&amp;quot;*&amp;quot; 기호&lt;/h2&gt;
&lt;p&gt;상호작용항을 고려하되 각 개별항과 상호작용항이 될 수 있는 모든 조합을 알아서 배정시키는&lt;br /&gt;
약속된 기호가 바로 &amp;quot;*&amp;quot; 이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;lm&lt;/span&gt;(mpg ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;wt *&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;cyl *&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;gear, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; mtcars)  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = mpg ~ wt * cyl * gear, data = mtcars)
## 
## Coefficients:
## (Intercept)           wt          cyl         gear       wt:cyl  
##     47.3853     -10.4502      -0.8957       2.2704       0.5459  
##     wt:gear     cyl:gear  wt:cyl:gear  
##      0.3527      -0.8794       0.1001&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위의&lt;br /&gt;
&lt;code&gt;mpg ~ wt * cyl * gear&lt;/code&gt;&lt;br /&gt;
는&lt;br /&gt;
&lt;code&gt;mpg ~ wt + cyl + gear + wt:cyl + wt:gear + cyl:gear + wt:cyl:gear&lt;/code&gt;&lt;br /&gt;
와 동일한 것이다.&lt;br /&gt;
따라서 실행된 코드의 출력결과도 비교해 보면 같은 것을 확인할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;i-함수&quot;&gt;&lt;code&gt;I()&lt;/code&gt; 함수&lt;/h2&gt;
&lt;p&gt;만약 분석자 나름대로 다변수들의 정보를 하나로 압축시킨 파생변수로 회귀적합을 하고 싶다면 어떻게 해야 할까?&lt;br /&gt;
예를 들어 &lt;code&gt;hp&lt;/code&gt; 변수값과 루트를 씌운 &lt;code&gt;wt&lt;/code&gt;변수값을 더하고 &lt;code&gt;carb&lt;/code&gt; 변수의 값을 뺀 값을 독립변수로 설정하여 단순회귀적합을 하고 싶다고 가정해보자. (일부러 의미 없이 복잡하게 설정해 봄)&lt;/p&gt;
&lt;p&gt;일단 떠오르는 방법은 &lt;code&gt;mtcars&lt;/code&gt; 에 새로운 변수열을 만들어 위의 상황대로&lt;/p&gt;
&lt;p&gt;hp + sqrt(wt) - carb&lt;/p&gt;
&lt;p&gt;를 계산한 새로운 변수를 만들어 이 변수열과 회귀적합을 하면 될 것이다.&lt;br /&gt;
하지만 &lt;code&gt;I()&lt;/code&gt; 함수를 알게 된다면 새로운 변수를 직접 만들 필요가 없다. 이렇게 하면 된다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;lm&lt;/span&gt;(mpg ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;I&lt;/span&gt;(hp +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;sqrt&lt;/span&gt;(wt) -&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;carb), &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; mtcars)  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = mpg ~ I(hp + sqrt(wt) - carb), data = mtcars)
## 
## Coefficients:
##             (Intercept)  I(hp + sqrt(wt) - carb)  
##                30.20584                 -0.06945&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그런데 한 가지 의문이 생길 수 있다.&lt;br /&gt;
만약 &lt;code&gt;I()&lt;/code&gt; 함수를 이용하지 않고 &lt;code&gt;formula&lt;/code&gt; 에 &lt;code&gt;hp + sqrt(wt) - carb&lt;/code&gt; 의 날것의 형태로 입력하면 되지 않을까? 라는 의문이다.&lt;br /&gt;
실행해보면 다음과 같다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;lm&lt;/span&gt;(mpg ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;hp +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;sqrt&lt;/span&gt;(wt) -&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;carb, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; mtcars)  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = mpg ~ hp + sqrt(wt) - carb, data = mtcars)
## 
## Coefficients:
## (Intercept)           hp     sqrt(wt)  
##    50.42823     -0.02908    -14.70273&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;우리가 줄곧 배운 &lt;code&gt;formula&lt;/code&gt; 의 입력값은 특정한 기호에 의해 약속된 문법을 따른다.&lt;br /&gt;
따라서 &lt;code&gt;hp + sqrt(wt) - carb&lt;/code&gt; 의 형태는 우리가 원하는 파생변수를 만들어 적합시키지 않는다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;hp&lt;/code&gt; 값에 &lt;code&gt;sqrt(wt)&lt;/code&gt; 값이 더해진 후 &lt;code&gt;carb&lt;/code&gt; 변수값이 차감된 것을 원하지만,&lt;br /&gt;
독립변수에 &lt;code&gt;hp&lt;/code&gt;, &lt;code&gt;sqrt(wt)&lt;/code&gt; 가 따로따로 고려되고 &lt;code&gt;carb&lt;/code&gt; 변수가 독립변수로 제외됨을 명시할 뿐이다.&lt;/p&gt;
&lt;p&gt;다시 &lt;code&gt;I()&lt;/code&gt; 함수를 이용한 결과로 돌아가 보면 &lt;code&gt;I()&lt;/code&gt; 의 쓰임은 결국 &lt;code&gt;formula&lt;/code&gt; 인자의 약속된 문법을 escape 하는 역할로 볼 수도 있겠다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;formula&lt;/code&gt; 인자에 입력할 값의 사용방법과 기호의 의미를 정리해 보았다.&lt;br /&gt;
위의 내용 외에도 더 많은 팁과 기호들의 조합을 생각해 볼 수 있을 것이다.&lt;/p&gt;
</description>
        <pubDate>Tue, 06 Dec 2016 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2016/12/06/formula_usage.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2016/12/06/formula_usage.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>R에서 factor 형 자료 처리를 위한 forcats package 에 대해</title>
        <description>&lt;br&gt;&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/forcats_1.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;개요&quot;&gt;개요&lt;/h2&gt;
&lt;p&gt;R에서 범주형 변수를 다룰 때 factor 형을 이용한다.&lt;br /&gt;
범주형 자료는 연속형 자료와는 다르게 그 자체의 고유한 의미를 가진다는 특성때문에 정성적인 관리가 필요한 편이다.&lt;br /&gt;
애초에 많은 관심을 필요로 하고 있다고 볼 수 있다.&lt;br /&gt;
이러한 이유로 범주형 자료를 접근하고 핸들링하는 많은 함수들이 R에 존재한다.&lt;/p&gt;
&lt;p&gt;최근에는 factors 의 알파벳 순서를 교묘히(?) 바꾸어 네이밍한 &lt;a href=&quot;https://cran.r-project.org/web/packages/forcats/forcats.pdf&quot;&gt;forcats package&lt;/a&gt; 가 CRAN 에 등록되었는데, &lt;del&gt;고양이를 위한 패키지가 아니라&lt;/del&gt; factor형 핸들링을 위한 함수들이 제공되는 패키지이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The goal of the &lt;strong&gt;forcats&lt;/strong&gt; package is to provide a suite of useful tools that solve common problems with factors.&lt;br /&gt;
- &lt;a href=&quot;https://github.com/tidyverse/forcats&quot;&gt;forcats package 의 README.md 중&lt;/a&gt;에서&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;패키지-설치&quot;&gt;패키지 설치&lt;/h2&gt;
&lt;p&gt;CRAN 에 등록되어 있으므로&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;install.packages&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;forcats&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;로 설치할 수 있다.&lt;/p&gt;
&lt;p&gt;major 버전은 아직 0 이므로 계속적으로 개발될 가능성이 있는 상태이다.&lt;br /&gt;
개발버전을 사용하고 싶다면 Github 를 통해 패키지를 설치해도 되겠다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;co&quot;&gt;# Or the the development version from GitHub:&lt;/span&gt;
devtools::&lt;span class=&quot;kw&quot;&gt;install_github&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;tidyverse/forcats&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;getting-started&quot;&gt;Getting started&lt;/h2&gt;
&lt;p&gt;forcats package 의 함수들은 &amp;quot;fct_&amp;quot; 로 시작한다.&lt;br /&gt;
이후의 단어가 함수쓰임의 의미를 담고 있다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;table&gt;
&lt;colgroup&gt;
&lt;col style=&quot;width: 11%&quot; /&gt;
&lt;col style=&quot;width: 88%&quot; /&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr class=&quot;header&quot;&gt;
&lt;th style=&quot;text-align: left;&quot;&gt;함수명칭&lt;/th&gt;
&lt;th style=&quot;text-align: left;&quot;&gt;내용&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;fct_anon&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;Anonymise factor levels&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;fct_c&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;Concatenate factors, unioning levels.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;fct_collapse&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;Collapse factors into groups.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;fct_count&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;Count entries in a factor&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;fct_drop&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;Drop unnused levels&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;fct_expand&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;Add additional levels to a factor&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;fct_explicit_na&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;Make missing values explicit&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;fct_infreq&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;Reorders levels in order of first appearance or frequency.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;fct_inorder&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;Reorders levels in order of first appearance or frequency.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;fct_lump&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;Lump together least/most common levels into &amp;quot;other&amp;quot;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;fct_recode&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;Change the levels of a factor&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;fct_relevel&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;Change the order of levels in a factor&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;fct_reorder&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;Reorder the levels of a function according to another variable&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;fct_reorder2&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;Reorder the levels of a function according to another variable&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;fct_rev&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;Reverse the levels of a factor&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;fct_shift&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;Shift the order of levels of a factor&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;fct_shuffle&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;Randomly permute the levels of a factor&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;fct_unify&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;Unify the levels in a list of factors&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;fct_unique&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;Unique values of a factor&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;접두사 &amp;quot;fct_&amp;quot; 가 코딩할 때 불편할 수도 있겠다 싶지만, 오히려 &amp;quot;fct_&amp;quot; 가 있음으로 변수형자료를 핸들링하는 것임을 정확하게 인지할 수 있는 tag같은 역할을 하는 것 같기도 해서 나는 개인적으로 좋다. &lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;여하튼 이 함수들 중 자주 사용하는 것을 몇 개 언급해보고자 한다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;fct_recode&quot;&gt;&lt;code&gt;fct_recode()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;factor 형 자료를 다룰 때 가장 번거로운 것 중 하나는 요인의 성격을 보존한 채 오직 명칭만 변경하는 과정이다.&lt;/p&gt;
&lt;p&gt;예를들면&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;ex &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;factor&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;L&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;M&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;small&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;small&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;L&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;M&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;L&amp;quot;&lt;/span&gt;), 
    &lt;span class=&quot;dt&quot;&gt;levels =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;small&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;M&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;L&amp;quot;&lt;/span&gt;))
ex&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] L     M     small small L     M     L    
## Levels: small M L&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위와 같은 &lt;code&gt;ex&lt;/code&gt; factor 형 자료의 요인들은 &amp;quot;small&amp;quot;, &amp;quot;M&amp;quot;, &amp;quot;L&amp;quot; 3개가 있다.&lt;br /&gt;
흠.. 그런데 요인의 명칭이 뭔가 맘에 들지 않는다(고 가정하자).&lt;br /&gt;
특히 &amp;quot;small&amp;quot; 을 &amp;quot;S&amp;quot; 로 바꾸기만 하면 좋을 것 같아&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;levels&lt;/span&gt;(ex)[&lt;span class=&quot;kw&quot;&gt;levels&lt;/span&gt;(ex) ==&lt;span class=&quot;st&quot;&gt; &amp;quot;small&amp;quot;&lt;/span&gt;] &amp;lt;-&lt;span class=&quot;st&quot;&gt; &amp;quot;S&amp;quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;와 같은 코딩을 필자 이전까지 해왔었다.&lt;br /&gt;
전통적인 방식이지만 어찌 보면 무식하고 조악한 코딩일 수도 있겠다.&lt;/p&gt;
&lt;p&gt;forcats package 에선 위의 예시처럼 요인명칭을 변경할 일이 있을 때&lt;br /&gt;
수준들의 위치를 인덱싱해 수동적으로 바꾸는 방법 대신 &lt;code&gt;fct_recode()&lt;/code&gt; 라는 함수를 통해 바꿀 수 있는 방법을 제공한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;fct_recode&lt;/span&gt;(ex, &lt;span class=&quot;dt&quot;&gt;S =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;small&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] L M S S L M L
## Levels: S M L&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;잠깐 딴 길로 세보자.&lt;br /&gt;
함수로써 제공한다는 것은 의외로 큰 의미가 있는데&lt;br /&gt;
R을 제대로 사용하시는 분들이라면 이 의미는 가볍게 알 것이다.&lt;br /&gt;
&lt;code&gt;fct_recode()&lt;/code&gt; 함수 이외의 forcats package 내에 함수들은 모두 혼자서 외롭게 활용될 일은 거의 없을 것이다.&lt;br /&gt;
아래 코드는 dplyr package 와 함께 &lt;code&gt;fct_recode()&lt;/code&gt; 함수를 좀 더 실용적으로 사용해 본 예라고 할 수 있겠다. (참고로 &lt;code&gt;gss_cat&lt;/code&gt; 는 forcats 패키지에 내장되어있는 데이터셋이다)&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;co&quot;&gt;# Origin&lt;/span&gt;
gss_cat %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;count&lt;/span&gt;(partyid)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 10 &amp;lt;U+00D7&amp;gt; 2
##               partyid     n
##                &amp;lt;fctr&amp;gt; &amp;lt;int&amp;gt;
## 1           No answer   154
## 2          Don&amp;#39;t know     1
## 3         Other party   393
## 4   Strong republican  2314
## 5  Not str republican  3032
## 6        Ind,near rep  1791
## 7         Independent  4119
## 8        Ind,near dem  2499
## 9    Not str democrat  3690
## 10    Strong democrat  3490&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;co&quot;&gt;# Change level values&lt;/span&gt;
gss_cat %&amp;gt;%
&lt;span class=&quot;st&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;mutate&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;partyid =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;fct_recode&lt;/span&gt;(partyid,
    &lt;span class=&quot;st&quot;&gt;&amp;quot;Republican, strong&amp;quot;&lt;/span&gt;    =&lt;span class=&quot;st&quot;&gt; &amp;quot;Strong republican&amp;quot;&lt;/span&gt;,
    &lt;span class=&quot;st&quot;&gt;&amp;quot;Republican, weak&amp;quot;&lt;/span&gt;      =&lt;span class=&quot;st&quot;&gt; &amp;quot;Not str republican&amp;quot;&lt;/span&gt;,
    &lt;span class=&quot;st&quot;&gt;&amp;quot;Independent, near rep&amp;quot;&lt;/span&gt; =&lt;span class=&quot;st&quot;&gt; &amp;quot;Ind,near rep&amp;quot;&lt;/span&gt;,
    &lt;span class=&quot;st&quot;&gt;&amp;quot;Independent, near dem&amp;quot;&lt;/span&gt; =&lt;span class=&quot;st&quot;&gt; &amp;quot;Ind,near dem&amp;quot;&lt;/span&gt;,
    &lt;span class=&quot;st&quot;&gt;&amp;quot;Democrat, weak&amp;quot;&lt;/span&gt;        =&lt;span class=&quot;st&quot;&gt; &amp;quot;Not str democrat&amp;quot;&lt;/span&gt;,
    &lt;span class=&quot;st&quot;&gt;&amp;quot;Democrat, strong&amp;quot;&lt;/span&gt;      =&lt;span class=&quot;st&quot;&gt; &amp;quot;Strong democrat&amp;quot;&lt;/span&gt;
  )) %&amp;gt;%
&lt;span class=&quot;st&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;count&lt;/span&gt;(partyid)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 10 &amp;lt;U+00D7&amp;gt; 2
##                  partyid     n
##                   &amp;lt;fctr&amp;gt; &amp;lt;int&amp;gt;
## 1              No answer   154
## 2             Don&amp;#39;t know     1
## 3            Other party   393
## 4     Republican, strong  2314
## 5       Republican, weak  3032
## 6  Independent, near rep  1791
## 7            Independent  4119
## 8  Independent, near dem  2499
## 9         Democrat, weak  3690
## 10      Democrat, strong  3490&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;fct_lump&quot;&gt;&lt;code&gt;fct_lump()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;lump 영단어의 뜻은 &amp;quot;덩어리&amp;quot;, &amp;quot;한 무더기&amp;quot; 정도이다.&lt;br /&gt;
파편들을 모아 한 덩어리로 만들어 주는 &lt;code&gt;fct_lump()&lt;/code&gt;, 곰곰이 생각해 보면 &amp;quot;파편들을 모아 한 덩어리로 만드는&amp;quot; 일은 꽤 많다.&lt;br /&gt;
이런 예제를 생각하면 바로 이해가 될 것 같다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;d2 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;gss_cat %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;count&lt;/span&gt;(partyid) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;arrange&lt;/span&gt;(n)

&lt;span class=&quot;kw&quot;&gt;pie&lt;/span&gt;(d2$n, d2$partyid)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/forcats_2.png&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;응답 비율이 매우 낮은 요인들은 &amp;quot;Don&#39;t know&amp;quot;, &amp;quot;No answer&amp;quot;, &amp;quot;Other party&amp;quot; 등이 있다.&lt;br /&gt;
응답 비율이 너무 낮아서 pie chart 에 잘 보이지 않고 겹쳐저 있다.&lt;br /&gt;
그리고 응답 비율이 너무 낮은것은 때로는 의미가 없어 &amp;quot;etc&amp;quot; 와 같은 기타항목으로 처리하곤 하는데&lt;br /&gt;
이때 &amp;quot;Don&#39;t know&amp;quot;, &amp;quot;No answer&amp;quot;, &amp;quot;Other party&amp;quot; 에 해당되는 요인들을 기타 항목으로 덩어리를 만들기 위해선 뜻밖에 많은 고민이 필요할 수 있다.&lt;/p&gt;
&lt;p&gt;우리가 알고 있는 &lt;code&gt;fct_recode()&lt;/code&gt; 함수로 이를 해결할 수도 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;d2 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;gss_cat %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;mutate&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;partyid =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;fct_recode&lt;/span&gt;(partyid, 
        &lt;span class=&quot;st&quot;&gt;&amp;quot;etc&amp;quot;&lt;/span&gt; =&lt;span class=&quot;st&quot;&gt; &amp;quot;Don&amp;#39;t know&amp;quot;&lt;/span&gt;,
        &lt;span class=&quot;st&quot;&gt;&amp;quot;etc&amp;quot;&lt;/span&gt; =&lt;span class=&quot;st&quot;&gt; &amp;quot;No answer&amp;quot;&lt;/span&gt;,
        &lt;span class=&quot;st&quot;&gt;&amp;quot;etc&amp;quot;&lt;/span&gt; =&lt;span class=&quot;st&quot;&gt; &amp;quot;Other party&amp;quot;&lt;/span&gt;
    )) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;count&lt;/span&gt;(partyid) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;arrange&lt;/span&gt;(n)

&lt;span class=&quot;kw&quot;&gt;pie&lt;/span&gt;(d2$n, d2$partyid)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/forcats_3.png&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;응답 비율이 낮은 요인들을 &amp;quot;etc&amp;quot; 라는 명칭으로 바꾸면 된다.&lt;/p&gt;
&lt;p&gt;음.. 그런데 좋은 해결책으로도 보일 수 있겠지만 이방법은 비효율적인 문제가 역시 있다.&lt;br /&gt;
일단 &amp;quot;Don&#39;t know&amp;quot;, &amp;quot;No answer&amp;quot;, &amp;quot;Other party&amp;quot; 3개의 요인이 응답 비율이 낮은 것임을 사후적으로 인지해야 하고,&lt;br /&gt;
이후 &amp;quot;etc&amp;quot; 라는 명칭으로 바꾸는 것은 뭔가 일을 2번하는 느낌을 받을 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fct_lump()&lt;/code&gt; 함수는 이처럼 &amp;quot;etc&amp;quot; 라는 덩어리를 아주 간단하게 만들어 준다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;d2 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;gss_cat %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;mutate&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;partyid =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;fct_lump&lt;/span&gt;(partyid, &lt;span class=&quot;dt&quot;&gt;n =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;other_level =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;etc&amp;quot;&lt;/span&gt;)) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;count&lt;/span&gt;(partyid) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;arrange&lt;/span&gt;(n)

&lt;span class=&quot;kw&quot;&gt;pie&lt;/span&gt;(d2$n, d2$partyid)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/forcats_4.png&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fct_lump(partyid, n = 7, other_level = &amp;quot;etc&amp;quot;)&lt;/code&gt; 를 살펴보면 &lt;code&gt;n&lt;/code&gt; 인자를 7로 설정하여 7개의 주항목 요인 외에는 &amp;quot;etc&amp;quot; 라는 명칭으로 자동으로 바꿔준다.&lt;br /&gt;
따라서 pie chart를 보면 소수의견인 &amp;quot;Don&#39;t know&amp;quot;, &amp;quot;No answer&amp;quot;, &amp;quot;Other party&amp;quot; 요인들이 &amp;quot;etc&amp;quot; 로 통합된 것을 확인할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.r-bloggers.com/forcats-0-1-0-%F0%9F%90%88%F0%9F%90%88%F0%9F%90%88%F0%9F%90%88/&quot;&gt;forcats 0.1.0 🐈🐈🐈🐈&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;Rstudio IDE 를 사용하고 있다면 &lt;kbd&gt;tap&lt;/kbd&gt;을 이용한 자동완성을 이용하면 그렇게 불편하지도 않다&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Sun, 13 Nov 2016 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2016/11/13/forcats_package.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2016/11/13/forcats_package.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>Mac 에서 Alfred(알프레드) 검색쿼리 등록을 통한 간편검색</title>
        <description>&lt;a href=&quot;https://www.alfredapp.com/&quot;&gt;&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/alfred_1.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Mac에서 Spotlight 대용으로 &lt;a href=&quot;https://www.alfredapp.com/&quot;&gt;Alfred&lt;/a&gt; 를 사용 중이며 최대한 다양한 기능들을 이용해 보고 있었다.&lt;br /&gt;
개인적으로 가장 생산성이 높은, 그리고 자주 사용하는 기능은 검색쿼리를 등록해 한방에 검색하는 편의를 가장 많이 느끼고 있었다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;alfred-검색쿼리-기능&quot;&gt;Alfred 검색쿼리 기능&lt;/h2&gt;
&lt;p&gt;부연설명을 하자면 아래와 같다.&lt;br /&gt;
만약 영어를 잘하고 싶어서 네이버에 &amp;quot;영어를 잘하는 법&amp;quot; 이라는 검색어로 검색을 원할 때 보통 아래와 같은 과정일 것이다. &lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;네이버 웹페이지가 뜨는 것을 기다린 후, &lt;code&gt;영어를 잘하는 법&lt;/code&gt; 으로 검색바에 타자를 치고 엔터를 누름&lt;/strong&gt; &lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;그런데 여기서 네이버라는 특정 검색 서비스 웹페이지를 들어가는 과정이 번거로울 수 있다.&lt;br /&gt;
네이버를 Alfred 에 검색 키워드로 등록하고 (예를 들어 &lt;code&gt;na&lt;/code&gt; 라고 등록한다면) 검색쿼리 설정을 해놓으면 &lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;kbd&gt;⌥&lt;/kbd&gt; + &lt;kbd&gt;Space&lt;/kbd&gt; 로 Alfred 실행 후 &lt;code&gt;na 영어를 잘하는 법&lt;/code&gt; 타자 치고 엔터를 누름&lt;/strong&gt; &lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;이란 과정으로 검색을 간편하게 할 수 있을 것이다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;alfred-검색쿼리-등록방법-alfred-v3.1.1-을-기준&quot;&gt;Alfred 검색쿼리 등록방법 (Alfred v3.1.1 을 기준)&lt;/h2&gt;
&lt;p&gt;등록방법을 구구절절 쓰는 것 보다 스크린캐스트를 보는 것이 좋을 것 같다.&lt;br /&gt;
아래 영상처럼 하면 된다.&lt;br /&gt;
이 영상은 Alfred 에 Github 검색쿼리를 등록한 후 테스트하는 영상이 되겠다.&lt;/p&gt;
&lt;iframe width=&quot;100%&quot; height=&quot;400&quot; src=&quot;https://www.youtube.com/embed/eG_Z5INGfsM&quot; frameborder=&quot;0&quot; allowfullscreen&gt;
&lt;/iframe&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;alfred-검색쿼리-예시&quot;&gt;Alfred 검색쿼리 예시&lt;/h2&gt;
&lt;p&gt;최근에 나는 Alfred 가 3.X 버전을 출시하면서 이전 1.X 버전을 생각 없이 지웠는데&lt;br /&gt;
아쉽게도 1.X 버전에 커스터마이징 된 환경들이 싹 날라가 버렸다. 😓&lt;/p&gt;
&lt;p&gt;특히 검색쿼리를 다시 찾고 세팅하는 것이 번거로웠는데&lt;br /&gt;
이참에 글로 쫙 정리해놓아야 겠다는 생각이 들었다.&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.naver.com/&quot;&gt;Naver&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;http://search.naver.com/search.naver?query={query}&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://endic.naver.com/?sLn=kr&quot;&gt;Naver 영어사전&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;http://endic.naver.com/search.nhn?sLn=kr&amp;amp;query={query}&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://soundcloud.com&quot;&gt;Soundcloud&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;https://soundcloud.com/search?q={query}&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/&quot;&gt;Github&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;https://github.com/search?q={query}&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.r-bloggers.com/&quot;&gt;R-bloggers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;https://www.r-bloggers.com/search/{query}/&lt;/code&gt;&lt;/pre&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;필자가 자주 이용하는 웹페이지를 기준으로 정리했다. Alfred 에서 기본적으로 지원해주는 구글, 위키, 트위터, 페이스북등의 쿼리를 제외하고 내가 자주 사용하는 사이트들에 대한 부분이다.&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Sun, 23 Oct 2016 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/open_source_tool/2016/10/23/Alfred_SearchQuery.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/open_source_tool/2016/10/23/Alfred_SearchQuery.html</guid>
        
        
        <category>Open_Source_Tool</category>
        
      </item>
    
      <item>
        <title>R에서 ggmap, ggplot2 패키지를 이용한 지도 출력 및 경로 표현하기 간단예제</title>
        <description>&lt;p&gt;&amp;quot;map&amp;quot; 이란 단어에 &amp;quot;Google&amp;quot; 의 &amp;quot;g&amp;quot; 알파벳 2개를 덧붙인 것으로 추정이 바로 되는&lt;br /&gt;
&lt;a href=&quot;https://cran.r-project.org/web/packages/ggmap/ggmap.pdf&quot;&gt;ggmap package&lt;/a&gt; 는 &lt;a href=&quot;https://enterprise.google.com/intl/ko/maps/products/mapsapi.html&quot;&gt;Google map API&lt;/a&gt; 를 이용하여 지도자료를 불러와주는 역할을 하는 패키지이다.&lt;/p&gt;
&lt;p&gt;간략한 예제를 통해 &amp;quot;ggmap&amp;quot; 패키지의 주요 함수 &lt;code&gt;get_googlemap()&lt;/code&gt;, &lt;code&gt;ggmap()&lt;/code&gt; 2개의 사용방법을 알아본 후&lt;br /&gt;
지도위에 간단한 경로를 결합하는 간단한 예제를 실습해 보고자 한다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;우리나라-지도-호출&quot;&gt;우리나라 지도 호출&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;getmap &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;get_googlemap&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;seoul&amp;quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;ggmap&lt;/span&gt;(getmap)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/ggmap-1-1.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;위의 2줄 코드는 서울시를 중심으로 google 지도 그림을 로드시켜&lt;br /&gt;
R에 plotting 하는 코드이다.&lt;/p&gt;
&lt;p&gt;정말 간단한 로직으로 동작하는 편이다.&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;code&gt;get_googlemap()&lt;/code&gt; 함수를 통해 불러오고 싶은 곳의 장소를 문자열 값으로 첫 번째 인자에 넣어 실행해 이를 객체화 함&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ggmap()&lt;/code&gt; 함수 안에 방금 만든 객체를 입력시킨 후 실행하면 원하는 장소를 중심으로 구글 지도가 plotting 됨&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;로직이 이처럼 간단하므로 앞으로 체인연산자(chain operation)를 사용해 간단히 한 줄로 실행하겠다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;get_googlemap&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;seoul&amp;quot;&lt;/span&gt;) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;ggmap&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;ggplot2-의-함수들과-조합&quot;&gt;ggplot2 의 함수들과 조합&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ggmap()&lt;/code&gt; 으로 반환되는 결과물은 기본적으로 ggplot 기반의 결과물인데 이점을 이용하여 ggplot2 패키지의 함수와 조합해 지도 위에 새로운 정보들을 더할 수 있다.&lt;br /&gt;
&amp;quot;ggmap&amp;quot;, &amp;quot;ggplot2&amp;quot; 이 두 패키지의 조합은 다양한 Geo Visualization(지리적 시각화) 을 구사할 수 있는 잠재력이 있을거라 생각된다.&lt;br /&gt;
지금은 복잡한 실습보단 간단한 예제를 통해 맛보기를 아래처럼 해보았다.&lt;/p&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/ggmap-3-1.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;그림을 다시 자세히 보면 x축이 &amp;quot;lon&amp;quot; 이라고 적혀있고, y축은 &amp;quot;lat&amp;quot; 라고 적혀 있다.&lt;br /&gt;
&amp;quot;lon&amp;quot; 은 경도(longitude), &amp;quot;lat&amp;quot; 은 위도(latitude) 를 각각 뜻한다고 볼 수 있다.&lt;/p&gt;
&lt;p&gt;즉 위도와 경도의 데이터가 있다면 이 지도 위에 ggplot2 를 이용하여 무언가를 덧그릴 수 있을 것이다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;포인팅&quot;&gt;포인팅&lt;/h3&gt;
&lt;p&gt;의미는 크게 없지만, 서초역과 강남역 부근에 무언가 장난을 쳐보려 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;서초역 : 경도 127.007675, 위도 37.491843&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;강남역 : 경도 127.027544, 위도 37.497968&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;즉&lt;br /&gt;
(127.007675, 37.491843), (127.027544, 37.497968)&lt;br /&gt;
좌표에 점을 찍게 되면 서초역과 강남역의 위치에 다음과 같은 모습이 된다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;p1 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;get_googlemap&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;seoul&amp;quot;&lt;/span&gt;) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;ggmap

locationInfo &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;data.frame&lt;/span&gt;(
  &lt;span class=&quot;dt&quot;&gt;Name =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;서초역&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;강남역&amp;quot;&lt;/span&gt;), 
  &lt;span class=&quot;dt&quot;&gt;lon =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;fl&quot;&gt;127.007675&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;127.027544&lt;/span&gt;),
    &lt;span class=&quot;dt&quot;&gt;lat =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;fl&quot;&gt;37.491843&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;37.497968&lt;/span&gt;)
)

p1 +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;geom_point&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; locationInfo, &lt;span class=&quot;kw&quot;&gt;aes&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;x =&lt;/span&gt; lon, &lt;span class=&quot;dt&quot;&gt;y =&lt;/span&gt; lat))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/ggmap-4-1.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;잘 안 보일 수도 있지만 전 사진과 다르게 2개의 점이 추가된 것을 볼 수 있다.&lt;br /&gt;
2개의 검은 점은 각각 서초역과 강남역에 찍혔다.&lt;/p&gt;
&lt;p&gt;지도를 조금 더 확대해 볼 수도 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;p2 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;get_googlemap&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;gangnamgu&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;zoom =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt;) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;ggmap
p2&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/ggmap-5-1.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;지도의 중앙을 &amp;quot;gangnamgu&amp;quot; 즉 강남구로 설정하고 &lt;code&gt;zoom&lt;/code&gt; 인자를 12값으로 설정한 경우이다.&lt;br /&gt;
&lt;code&gt;zoom&lt;/code&gt; 인자의 디폴트 값 10 보다 큰 값을 주었으므로 조금은 확대되어 보이게 된다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;p2 +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;geom_point&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; locationInfo, &lt;span class=&quot;kw&quot;&gt;aes&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;x =&lt;/span&gt; lon, &lt;span class=&quot;dt&quot;&gt;y =&lt;/span&gt; lat))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/ggmap-6-1.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;지도를 확대하든 지도의 중심점을 옮기든 간에 서초역과 강남역에 포인팅하는 코드는 문제없이 작동한다.&lt;br /&gt;
포인팅 말고도 포인팅된 곳에 무엇이 위치해 있는지 라벨링이 되어있다면 더 보기 좋을 것이다.&lt;br /&gt;
라벨링도 ggplot2 기능 그대로 쓰던대로 쓰면 된다.&lt;br /&gt;
아래는 &lt;code&gt;geom_text()&lt;/code&gt; 를 이용해본 예이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;p2 +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;geom_point&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; locationInfo, &lt;span class=&quot;kw&quot;&gt;aes&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;x =&lt;/span&gt; lon, &lt;span class=&quot;dt&quot;&gt;y =&lt;/span&gt; lat)) +
&lt;span class=&quot;st&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;geom_text&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; locationInfo, &lt;span class=&quot;kw&quot;&gt;aes&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;label =&lt;/span&gt; Name), &lt;span class=&quot;dt&quot;&gt;size =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;vjust =&lt;/span&gt; -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/ggmap-7-1.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;경로-그리기&quot;&gt;경로 그리기&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;locationInfo &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;data.frame&lt;/span&gt;(
    &lt;span class=&quot;dt&quot;&gt;Name =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;강남&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;양재&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;양재시민의숲&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;청계산입구&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;판교&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;정자&amp;quot;&lt;/span&gt;), 
    &lt;span class=&quot;dt&quot;&gt;lon =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;fl&quot;&gt;127.028046&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;127.035140&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;127.038451&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;127.054769&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;127.111172&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;127.108367&lt;/span&gt;), 
    &lt;span class=&quot;dt&quot;&gt;lat =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;fl&quot;&gt;37.497001&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;37.483368&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;37.469655&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;37.448196&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;37.394786&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;37.366777&lt;/span&gt;)
)

locationInfo&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##           Name      lon      lat
## 1         강남 127.0280 37.49700
## 2         양재 127.0351 37.48337
## 3 양재시민의숲 127.0385 37.46966
## 4   청계산입구 127.0548 37.44820
## 5         판교 127.1112 37.39479
## 6         정자 127.1084 37.36678&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;신분당선을 기준으로 정자역에서 강남역까지 경로를 표현해 보고자 &lt;code&gt;locationInfo&lt;/code&gt; 내용을 바꾸었다.&lt;br /&gt;
이를 이용하여 신분당선의 대략적인 경로를 표현해 보도록 하겠다. &lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;p3 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;get_googlemap&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;gwacheon&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;zoom =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;11&lt;/span&gt;) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;ggmap
p3 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;p3 +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;geom_point&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; locationInfo, &lt;span class=&quot;kw&quot;&gt;aes&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;x =&lt;/span&gt; lon, &lt;span class=&quot;dt&quot;&gt;y =&lt;/span&gt; lat)) +
&lt;span class=&quot;st&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;geom_text&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; locationInfo, &lt;span class=&quot;kw&quot;&gt;aes&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;label =&lt;/span&gt; Name), &lt;span class=&quot;dt&quot;&gt;size =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;hjust =&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;1.2&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;fontface =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;bold&amp;quot;&lt;/span&gt;)
p3&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/ggmap-9-1.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;우선 과천시를 중심으로 두고 &lt;code&gt;zoom = 11&lt;/code&gt; 로 설정하여 지도를 뿌린 후&lt;br /&gt;
신분당선에 해당되는 역에 점을 찍고 라벨링을 더해보았다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;p3 +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;geom_path&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; locationInfo, &lt;span class=&quot;kw&quot;&gt;aes&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;x =&lt;/span&gt; lon, &lt;span class=&quot;dt&quot;&gt;y =&lt;/span&gt; lat), &lt;span class=&quot;dt&quot;&gt;color =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;blue&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;alpha =&lt;/span&gt; .&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;lwd =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/ggmap-10-1.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;그다음 경로를 표현하기 위해 각 점에 적당한 직선을 &lt;code&gt;geom_path()&lt;/code&gt; 를 통해 그리면 신분당선의 경로가 어떤지를 볼 수 있겠다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;기타&quot;&gt;기타&lt;/h2&gt;
&lt;p&gt;소개한 &lt;code&gt;get_googlemap()&lt;/code&gt;, &lt;code&gt;ggmap()&lt;/code&gt; 함수의 옵션들은 정말 방대한 편이다.&lt;br /&gt;
모든 것을 건드려 보진 못했지만 유용할 것으로 생각하는 기능 중&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;지도를 꽉 채워 출력하는 기능&lt;/li&gt;
&lt;li&gt;Map type 을 변경하는 기능&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이 눈에 띄었다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;extent-device-로-지도-꽉-채워-보기&quot;&gt;&lt;code&gt;extent = &amp;quot;device&amp;quot;&lt;/code&gt; 로 지도 꽉 채워 보기&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;get_googlemap&lt;/span&gt;() %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;ggmap&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/ggmap-11-1.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;code&gt;ggmap()&lt;/code&gt; 함수를 디폴트로 사용한 결과이다.&lt;br /&gt;
지도 그림만을 출력하지 못하고 x축, y축이 함께 그려지는데 상황에 따라 불필요할 수 있다.&lt;br /&gt;
온전히 지도 그림만을 출력하고 싶다면&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;get_googlemap&lt;/span&gt;() %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;ggmap&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;extent =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;device&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/ggmap-12-1.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;code&gt;extent = &amp;quot;device&amp;quot;&lt;/code&gt; 를 이용하면 되겠다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;get_googlemap-함수의-maptype-인자를-조정해-지도스타일-바꾸기&quot;&gt;&lt;code&gt;get_googlemap()&lt;/code&gt; 함수의 &lt;code&gt;maptype&lt;/code&gt; 인자를 조정해 지도스타일 바꾸기&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;get_googlemap()&lt;/code&gt; 함수의 &lt;code&gt;maptype&lt;/code&gt; 인자 값을&lt;br /&gt;
&amp;quot;terrain&amp;quot;, &amp;quot;satellite&amp;quot;, &amp;quot;roadmap&amp;quot;, &amp;quot;hybrid&amp;quot; 등으로 조절해보면&lt;/p&gt;
&lt;p&gt;&lt;em&gt;satellite 로 설정한 결과&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;p4 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;get_googlemap&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;maptype =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;satellite&amp;quot;&lt;/span&gt;) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;ggmap
p4 +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;ggtitle&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;maptype : satellite&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/ggmap-13-1.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;em&gt;terrain 로 설정한 결과&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;p5 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;get_googlemap&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;maptype =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;terrain&amp;quot;&lt;/span&gt;) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;ggmap
p5 +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;ggtitle&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;maptype : terrain&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/ggmap-14-1.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;em&gt;roadmap 로 설정한 결과&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;p6 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;get_googlemap&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;maptype =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;roadmap&amp;quot;&lt;/span&gt;) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;ggmap
p6 +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;ggtitle&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;maptype : roadmap&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/ggmap-15-1.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;em&gt;hybrid 로 설정한 결과&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;p7 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;get_googlemap&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;maptype =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;hybrid&amp;quot;&lt;/span&gt;) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;ggmap
p7 +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;ggtitle&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;maptype : hybrid&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/ggmap-16-1.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;이처럼 쓰임에 맞는 지도 스타일을 선택할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://journal.r-project.org/archive/2013-1/kahle-wickham.pdf&quot;&gt;ggmap: Spatial Visualization with ggplot2 by David Kahle and Hadley Wickham&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;참고로 지금의 신분당선은 이보다 노선이 더 많아졌다.&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Tue, 18 Oct 2016 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/data_visualization/2016/10/18/ggmap.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/data_visualization/2016/10/18/ggmap.html</guid>
        
        
        <category>R</category>
        
        <category>Data_Visualization</category>
        
      </item>
    
      <item>
        <title>R에서 ggplot2 패키지를 이용한 간단한 Choropleth Map 구현하기</title>
        <description>&lt;h2 id=&quot;단계-구분도---choropleth-map&quot;&gt;단계 구분도 - Choropleth Map&lt;/h2&gt;
&lt;p&gt;데이터 시각화를 주제로 모습을 자주 보이는 단계 구분도 (Choropleth Map)에 대해서 알아보고자 한다.&lt;br /&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Choropleth_map&quot;&gt;Choropleth map&lt;/a&gt;은 지역당 특정주제의 통계치를 활용해 시각적인 요소를 가미하여 나타낸 지도로서, 예시를 하나 들자면 국가별 인구의 밀도를 수치에 따라 색깔의 농도를 달리하여 나타내는 지도로 들 수 있다.&lt;/p&gt;
&lt;p&gt;그림으로 표현하면 다음과 같다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/choro1.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://gisutd.tistory.com/7&quot;&gt;꽤 괜찮은 데이터 지도(data map)를 그려주는 Natural Breaks란?&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이런 단계구분도를 R을 이용해 구현해 본 예제는 아래와 같다.&lt;/p&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/choro2.png&quot; /&gt;
&lt;/center&gt;
&lt;blockquote&gt;
&lt;p&gt;R Graphics Cookbook [Programming Insight] - 300page&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;r을-이용한-간단한-예제-실습&quot;&gt;R을 이용한 간단한 예제 실습&lt;/h2&gt;
&lt;p&gt;위 예제로 든 것을 실제로 만들어 보며 실습을 해보았다.&lt;br /&gt;
R의 여러 패키지의 도움을 빌렸다.&lt;br /&gt;
&amp;quot;maps&amp;quot;, &amp;quot;dplyr&amp;quot;, &amp;quot;&amp;quot;ggplot2&amp;quot; 3개의 패키지 도움을 빌리기 위해 로드한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;co&quot;&gt;# install.packages(&amp;quot;maps&amp;quot;)&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# install.packages(&amp;quot;dplyr&amp;quot;)&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# install.packages(&amp;quot;ggplot2&amp;quot;)&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;ggplot2&amp;quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;maps&amp;quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;dplyr&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&amp;quot;maps&amp;quot; 패키지에는 지도를 그리기 위한 위도, 경도 및 이에 매칭되는 나라에 대한 정보를 데이터프레임셋으로 만들 수 있도록 해주는데,&lt;br /&gt;
모든 나라의 지도정보가 담겨있으므로 Choropleth map 으로 그리고 싶은 나라를 서브세팅하여 전처리하는 것이 가능하다.&lt;br /&gt;
그래픽 엔진으로는 &amp;quot;ggplot2&amp;quot; 패키지를 선택해 Choropleth map을 구현해 볼 것이며,&lt;br /&gt;
&amp;quot;dplyr&amp;quot; 패키지는 데이터 전처리의 간편함수들을 이용하기 위함이다.&lt;/p&gt;
&lt;p&gt;바로 위에 예시로 그린 나라는 미국이다.&lt;br /&gt;
미국만을 서브세팅 하여 그리는 예제만 해보고자 한다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;map_data()&lt;/code&gt; 는 해당지도의 경도, 위도, 지역, 지역명, 지도의 다각형을 그릴 수 있게 해 주는 서브정보들이 담겨있는 데이터프레임을 반환시켜주는데 ggplot2 패키지의 함수임을 유의하며 사용했다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;states_map &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;map_data&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;state&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;map_data 의 첫 번째 인자를 &lt;code&gt;&amp;quot;state&amp;quot;&lt;/code&gt; 로 하여 미국의 주 시에 대한 정보의 데이터프레임을 &lt;code&gt;states_map&lt;/code&gt; 명칭의 객체로 저장했다.&lt;br /&gt;
참고로 &lt;code&gt;&amp;quot;state&amp;quot;&lt;/code&gt; 는 미국의 주, &lt;code&gt;&amp;quot;world&amp;quot;&lt;/code&gt; 는 전세계, &lt;code&gt;&amp;quot;france&amp;quot;&lt;/code&gt; 는 프랑스 지도 정보가 반환된다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;head&lt;/span&gt;(states_map, &lt;span class=&quot;dt&quot;&gt;n =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##         long      lat group order  region subregion
## 1  -87.46201 30.38968     1     1 alabama      &amp;lt;NA&amp;gt;
## 2  -87.48493 30.37249     1     2 alabama      &amp;lt;NA&amp;gt;
## 3  -87.52503 30.37249     1     3 alabama      &amp;lt;NA&amp;gt;
## 4  -87.53076 30.33239     1     4 alabama      &amp;lt;NA&amp;gt;
## 5  -87.57087 30.32665     1     5 alabama      &amp;lt;NA&amp;gt;
## 6  -87.58806 30.32665     1     6 alabama      &amp;lt;NA&amp;gt;
## 7  -87.59379 30.30947     1     7 alabama      &amp;lt;NA&amp;gt;
## 8  -87.59379 30.28655     1     8 alabama      &amp;lt;NA&amp;gt;
## 9  -87.67400 30.27509     1     9 alabama      &amp;lt;NA&amp;gt;
## 10 -87.81152 30.25790     1    10 alabama      &amp;lt;NA&amp;gt;
## 11 -87.88026 30.24644     1    11 alabama      &amp;lt;NA&amp;gt;
## 12 -87.92037 30.24644     1    12 alabama      &amp;lt;NA&amp;gt;
## 13 -87.95475 30.24644     1    13 alabama      &amp;lt;NA&amp;gt;
## 14 -88.00632 30.24071     1    14 alabama      &amp;lt;NA&amp;gt;
## 15 -88.01778 30.25217     1    15 alabama      &amp;lt;NA&amp;gt;
## 16 -88.01205 30.26936     1    16 alabama      &amp;lt;NA&amp;gt;
## 17 -87.99486 30.27509     1    17 alabama      &amp;lt;NA&amp;gt;
## 18 -87.95475 30.27509     1    18 alabama      &amp;lt;NA&amp;gt;
## 19 -87.90318 30.28082     1    19 alabama      &amp;lt;NA&amp;gt;
## 20 -87.82870 30.28655     1    20 alabama      &amp;lt;NA&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;데이터의 앞부분 일부를 보니,&lt;br /&gt;
&amp;quot;alabama&amp;quot; 지역의 다각형을 그리기 위한 경도(long), 위도(lat) 정보가 있는 것을 볼 수 있다.&lt;br /&gt;
물론 alabama 만 있는 것이 아니라 수많은 미국의 주 region 이 존재하는 데이터이다.&lt;br /&gt;
이를 ggplot2 패키지를 이용해 구체화 시키는 코드를 아래와 같이 작성해 보았다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;ggplot&lt;/span&gt;(states_map, &lt;span class=&quot;kw&quot;&gt;aes&lt;/span&gt;(long, lat, &lt;span class=&quot;dt&quot;&gt;group =&lt;/span&gt; group)) +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;geom_polygon&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;color =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;black&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;fill =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;gray&amp;quot;&lt;/span&gt;) +
&lt;span class=&quot;st&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;coord_map&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;polyconic&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/choro3.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;code&gt;ggplot()&lt;/code&gt; 의 첫번째 인자에는 본체 데이터를 입력하고, 두번째 인자에 &lt;code&gt;aes(x = long, y = lat)&lt;/code&gt; 을 지정하여 위도, 경도를 각각 x축과 y축에 매칭시킨다.&lt;br /&gt;
다음으로 &lt;code&gt;geom_polygon()&lt;/code&gt; 와 &lt;code&gt;coord_map()&lt;/code&gt; 함수를 통해 다각형을 그리는 명령을 넣어 구체화 시키면 ggplot2 packages를 이용한 결과물이 위와 같이 나오게 된다.&lt;/p&gt;
&lt;p&gt;그런데 위의 결과물은 단지 지도의 형태만을 볼 수 있고,&lt;br /&gt;
주시내별 어떠한 정보도 담겨있지 않은 공통된 회색이기 때문에&lt;br /&gt;
choropleth map 이라고 할 수 없는 상태이다.&lt;br /&gt;
주시내별 어떠한 정보를 담기 위하여 R의 내장데이터인 &lt;code&gt;USArrests&lt;/code&gt; 를 활용해 보았다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;head&lt;/span&gt;(USArrests)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##            Murder Assault UrbanPop Rape
## Alabama      13.2     236       58 21.2
## Alaska       10.0     263       48 44.5
## Arizona       8.1     294       80 31.0
## Arkansas      8.8     190       50 19.5
## California    9.0     276       91 40.6
## Colorado      7.9     204       78 38.7&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;USArrests&lt;/code&gt; 객체는 미국의 주시내별 폭력∙범죄율 정보를 담고 있는 data.frame 빌트인 객체이다.&lt;br /&gt;
이를 이용하여 미국의 어떠한 마을에 범죄율이 강하고 적은지를 쉽게 확인할 수 있는 choropleth map 을 만들어 보면 의미 있는 결과물이 나올 것이라 예상된다.&lt;br /&gt;
앞에서 사용했던 미국 주시내별 지도위치정보를 담은 데이터프레임셋 &lt;code&gt;states_map&lt;/code&gt; 를 다시 가지고 와서&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;states_map &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;map_data&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;state&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;region 변수와 내장데이터셋 &lt;code&gt;USArrests&lt;/code&gt; 의 region 변수를 &lt;code&gt;merge()&lt;/code&gt; 함수를 이용해 병합해 보았다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;crime_map &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;data.frame&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;region =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;tolower&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;rownames&lt;/span&gt;(USArrests)), USArrests) %&amp;gt;%
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;merge&lt;/span&gt;(states_map, &lt;span class=&quot;dt&quot;&gt;by =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;region&amp;quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;head&lt;/span&gt;(crime_map)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##    region Murder Assault UrbanPop Rape      long      lat group order
## 1 alabama   13.2     236       58 21.2 -87.46201 30.38968     1     1
## 2 alabama   13.2     236       58 21.2 -87.48493 30.37249     1     2
## 3 alabama   13.2     236       58 21.2 -87.95475 30.24644     1    13
## 4 alabama   13.2     236       58 21.2 -88.00632 30.24071     1    14
## 5 alabama   13.2     236       58 21.2 -88.01778 30.25217     1    15
## 6 alabama   13.2     236       58 21.2 -87.52503 30.37249     1     3
##   subregion
## 1      &amp;lt;NA&amp;gt;
## 2      &amp;lt;NA&amp;gt;
## 3      &amp;lt;NA&amp;gt;
## 4      &amp;lt;NA&amp;gt;
## 5      &amp;lt;NA&amp;gt;
## 6      &amp;lt;NA&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이렇게 만들어진 &lt;code&gt;crime_map&lt;/code&gt; 객체의 헤더부분을 살펴보면&lt;br /&gt;
&lt;code&gt;region&lt;/code&gt; 변수에 따른 &lt;code&gt;Murder&lt;/code&gt;, &lt;code&gt;Assault&lt;/code&gt;, &lt;code&gt;UrbanPop&lt;/code&gt;, &lt;code&gt;Rape&lt;/code&gt; 변수정보들이 붙여진 것을 확인할 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;arrange&lt;/span&gt;(crime_map, order) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;ggplot&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;aes&lt;/span&gt;(long, lat, &lt;span class=&quot;dt&quot;&gt;group =&lt;/span&gt; group, &lt;span class=&quot;dt&quot;&gt;fill =&lt;/span&gt; Murder)) +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;geom_polygon&lt;/span&gt;() +
&lt;span class=&quot;st&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;coord_map&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;polyconic&amp;quot;&lt;/span&gt;) +
&lt;span class=&quot;st&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;scale_fill_continuous&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;low =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;pink&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;high =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;black&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/choro4.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;code&gt;arrange()&lt;/code&gt; 를 이용하여 order 변수 순으로 정렬을 해주었는데,&lt;br /&gt;
정렬을 시키는 이유는 올바른 다각형을 그리기 위함이다.&lt;br /&gt;
병합작업 시 원래 순서대로 정렬되어있던 것이 헝클어졌기 때문에 필요한 전처리 작업이다.&lt;br /&gt;
(정렬작업을 하지 않는다면 도저히 무슨 그림인지 알 수 없는 결과물이 나온다)&lt;/p&gt;
&lt;p&gt;이후 &lt;code&gt;ggplot()&lt;/code&gt; 에 &lt;code&gt;fill&lt;/code&gt; 인자를 &lt;code&gt;Murder&lt;/code&gt; 변수로 지정하여 미국의 주시내별 살인범죄수에 따라 색깔의 농도가 진해지는 결과물을 출력하면 되겠다.&lt;br /&gt;
위의 결과물과 맨 첫 번째 소개했던 결과물이 같은 것을 확인할 수 있다.&lt;/p&gt;
</description>
        <pubDate>Fri, 14 Oct 2016 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/data_visualization/2016/10/14/Choropleth_map_basic.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/data_visualization/2016/10/14/Choropleth_map_basic.html</guid>
        
        
        <category>R</category>
        
        <category>Data_Visualization</category>
        
      </item>
    
      <item>
        <title>R에서 lubridate package 에 대해</title>
        <description>&lt;br&gt;&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/lubridate.png&quot;&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cran.r-project.org/web/packages/lubridate/lubridate.pdf&quot;&gt;lubridate package&lt;/a&gt; 는 Garrett Grolemund 와 Hadley Wickham 외 8명의 힘이 더해져 만들어진 날짜처리 생산성 패키지이다.&lt;/p&gt;
&lt;p&gt;날짜(Date) &amp;amp; 시각(Time) 데이터는 전 세계 사람들에 의해 보편적으로 정해진 규칙이 있는데, 이 규칙을 정확하게 알지 못하고 데이터를 처리할 때 혼돈이 일어날 수 있다.&lt;br /&gt;
의외로 위에서 말한 규칙들은 따지고 보면 따져볼수록 많고 복잡하여 인간이 실수할 수 있을 여지가 높다.&lt;br /&gt;
흠 이런 예제랄까?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;어느 연도가 윤년이어서 2월 29일이 있는지 없는지 신경 쓰지 않으면 알 수 없다.&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;4월 31일 데이터셋 정의 (그런 날짜는 존재하지 않는데도 불구하고)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이런 것 외에도 우리가 접할 수 있는 여러 가지 상황을 가정 해 볼 수 있는데&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;분석 시 기준 Timezone 이 변경될 경우&lt;/li&gt;
&lt;li&gt;날짜와 시각이 조합된 데이터의 산술연산이 필요할 경우&lt;/li&gt;
&lt;li&gt;(정말 특이한 사례지만) &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%9D%BC%EA%B4%91_%EC%A0%88%EC%95%BD_%EC%8B%9C%EA%B0%84%EC%A0%9C&quot;&gt;일광절약시간제&lt;/a&gt;에 해당되는 Time index 가 존재할 경우&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;등등 날짜시각 데이터셋에 대한 처리 시 우리를 괴롭힐 만한 요소들은 차고 넘친다.&lt;/p&gt;
&lt;p&gt;이 실수들과 장애물들을 사전에 방지하기 위한 다양한 R 패키지가 제공되고 있다.&lt;br /&gt;
내가 아는 것을 기준으론 &lt;a href=&quot;https://cran.r-project.org/web/packages/xts/xts.pdf&quot;&gt;xts&lt;/a&gt;, &lt;a href=&quot;https://cran.r-project.org/web/packages/zoo/zoo.pdf&quot;&gt;zoo&lt;/a&gt;, lubridate, &lt;a href=&quot;https://cran.r-project.org/web/packages/chron/chron.pdf&quot;&gt;chron&lt;/a&gt; 의 패키지 정도를 알고 있으되, 자주 사용하는 패키지는 xts 이었다.&lt;/p&gt;
&lt;p&gt;이번에 살펴볼 &lt;a href=&quot;https://cran.r-project.org/web/packages/lubridate/lubridate.pdf&quot;&gt;lubridate package&lt;/a&gt; 는 lubricate(기름을 치다, 기름을 바르다, 원활히 하다) 의 &amp;quot;lubri&amp;quot; 와 &amp;quot;date&amp;quot; 를 합성시킨 것으로 추측되는데 이처럼 날짜시각 데이터를 원활하게 가공하는 데 도움을 주기 위한 목적으로 특화된 느낌을 받는다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;span class=&quot;math display&quot;&gt;&lt;em&gt;l&lt;/em&gt;&lt;em&gt;u&lt;/em&gt;&lt;em&gt;b&lt;/em&gt;&lt;em&gt;r&lt;/em&gt;&lt;em&gt;i&lt;/em&gt; + &lt;em&gt;d&lt;/em&gt;&lt;em&gt;a&lt;/em&gt;&lt;em&gt;t&lt;/em&gt;&lt;em&gt;e&lt;/em&gt;&lt;/span&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;xts, zoo 패키지 조합 역시 강력하지만 강력한 만큼 친숙함은 주지 못한 것 같다.&lt;br /&gt;
이러한 단점을 보완하고자 부가적으로 알아야 하겠다고 마음먹게 된 패키지 중 하나이었고,&lt;br /&gt;
R studio 의 Hadley Wickham 에 의해 유지보수 되고 있다고 해서 그 때문에 공부를 시작하기도 한 것 같다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Lubridate is an R package that makes it easier to work with dates and times.&lt;br /&gt;
- &lt;a href=&quot;https://cran.r-project.org/web/packages/lubridate/vignettes/lubridate.html&quot;&gt;Do more with dates and times in R with lubridate 1.3.0&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;얼마나 기존방법보다 쉬운지를 내가 겪었던 시행착오와 곁들여&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(lubridate)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;를 실행 후 한 번 탐색해 보겠다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;dates-times-객체-만들기&quot;&gt;dates &amp;amp; times 객체 만들기&lt;/h2&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;date-객체-만들기&quot;&gt;Date 객체 만들기&lt;/h3&gt;
&lt;p&gt;R에서 2011년 6월 4일 날짜 데이터를 만들려면 가장 기본적인 방법이 아래의 코드일 것이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;as.Date&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;2011-06-04&amp;quot;&lt;/span&gt;)
## [1] &amp;quot;2011-06-04&amp;quot;
&lt;span class=&quot;kw&quot;&gt;as.Date&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;2011-6-4&amp;quot;&lt;/span&gt;)
## [1] &amp;quot;2011-06-04&amp;quot;
&lt;span class=&quot;kw&quot;&gt;as.Date&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;2011/06/04&amp;quot;&lt;/span&gt;)
## [1] &amp;quot;2011-06-04&amp;quot;
## 
## as.Date(&amp;quot;20110604&amp;quot;) # error&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;R의 가장 전통적인 날짜 데이터 class 는 Date 일 것이다.&lt;br /&gt;
마지막 코드 &lt;code&gt;as.Date(&amp;quot;20110604&amp;quot;)&lt;/code&gt; 와 같이 에러가 나는 코드도 한번 작성해 보았는데&lt;br /&gt;
이처럼 날짜 데이터셋을 만들기 위해 문자열을 input 하는 방식으로 사용할 경우 문자열을 어떠한 양식에 따라 작성할 것인지도 사람마다 제각각이고 그에 따라 코드가 실행되지 않는 경우가 발생할 것이다.&lt;br /&gt;
그 양식 중 &lt;code&gt;&amp;quot;20110604&amp;quot;&lt;/code&gt; 와 같이 딜리미터가 없는 문자열은 &lt;code&gt;as.Date()&lt;/code&gt; 가 날짜로 변환할 때&lt;br /&gt;
어디가 year 이고 month 이며 day 인지 알 수 없어한다.&lt;/p&gt;
&lt;p&gt;또한&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;as.Date&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;06-04-2011&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;0006-04-20&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;처럼 미국식 날짜 표기법을 사용할 경우에도 마찬가지 문제가 발생한다.&lt;/p&gt;
&lt;p&gt;이번엔 lubridate package 의 &amp;quot;y&amp;quot;, &amp;quot;m&amp;quot;, &amp;quot;d&amp;quot; 심볼을 이용한 함수들을 이용해 보겠다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;ymd&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;2011/06/04&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;2011-06-04&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;quot;y&amp;quot;, &amp;quot;m&amp;quot;, &amp;quot;d&amp;quot; 심볼이라고 소개했는데 각각 year, month, day 로 이해할 수 있고&lt;br /&gt;
이 심볼의 순서를 바꾸어도 먹히는 함수들이 사전에 준비되어 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;mdy&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;06/04/2011&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;2011-06-04&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;quot;06/04/2011&amp;quot; 은 2011년 6월 4일을 미국식으로 날짜 표기한 것인데, 이를 제대로 인식하기 위해서 심볼들의 순서를 그에 맞춘 함수를 이용하면 되겠다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;dmy&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;04/06/2011&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;2011-06-04&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;문자열 양식에는 어느정도의 관용이 있는지 살펴보았다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;ymd&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;2011/06/04&amp;quot;&lt;/span&gt;)
## [1] &amp;quot;2011-06-04&amp;quot;
&lt;span class=&quot;kw&quot;&gt;ymd&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;2011-06-04&amp;quot;&lt;/span&gt;)
## [1] &amp;quot;2011-06-04&amp;quot;
&lt;span class=&quot;kw&quot;&gt;ymd&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;20110604&amp;quot;&lt;/span&gt;)
## [1] &amp;quot;2011-06-04&amp;quot;
&lt;span class=&quot;kw&quot;&gt;ymd&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;110604&amp;quot;&lt;/span&gt;)
## [1] &amp;quot;2011-06-04&amp;quot;
&lt;span class=&quot;kw&quot;&gt;ymd&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;11.06.04&amp;quot;&lt;/span&gt;)
## [1] &amp;quot;2011-06-04&amp;quot;
&lt;span class=&quot;kw&quot;&gt;ymd&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;11,06,04&amp;quot;&lt;/span&gt;)
## [1] &amp;quot;2011-06-04&amp;quot;
&lt;span class=&quot;kw&quot;&gt;ymd&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;11_06.04&amp;quot;&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# ?&lt;/span&gt;
## [1] &amp;quot;2011-06-04&amp;quot;
&lt;span class=&quot;kw&quot;&gt;ymd&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;2011  06  04&amp;quot;&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# ㅋㅋ?&lt;/span&gt;
## [1] &amp;quot;2011-06-04&amp;quot;
&lt;span class=&quot;kw&quot;&gt;ymd&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;2011!?06??!04&amp;quot;&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# !?&lt;/span&gt;
## [1] &amp;quot;2011-06-04&amp;quot;
&lt;span class=&quot;kw&quot;&gt;ymd&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;2011 =06??04&amp;quot;&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# -_-?&lt;/span&gt;
## [1] &amp;quot;2011-06-04&amp;quot;
&lt;span class=&quot;kw&quot;&gt;ymd&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;11 No 06 way 04&amp;quot;&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# No way!&lt;/span&gt;
## [1] &amp;quot;2011-06-04&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;lubridate package 설명서에는&lt;br /&gt;
&lt;strong&gt;heterogeneous format(불균일한 양식)&lt;/strong&gt;에 대한 다양한 준비들이 되어있음을 강조한 문구가 담겨 있는 걸 보았다.&lt;br /&gt;
이처럼 인간의 실수는 웬만하면 커버할 듯한 위용이다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;dates-times-객체-만들기-1&quot;&gt;Dates + Times 객체 만들기&lt;/h3&gt;
&lt;p&gt;&amp;quot;2011년 6월 4일&amp;quot; 에 구체적인 시각까지 더해서&lt;br /&gt;
&amp;quot;2011년 6월 4일 13시 30분 50초&amp;quot; 를 R에서 만들어 보겠다.&lt;/p&gt;
&lt;p&gt;시각까지 더해진 정보는 Date class 로 정보를 담을 수 없다.&lt;br /&gt;
즉 &lt;code&gt;as.Date()&lt;/code&gt; 함수로 2011년 6월 4일 13시 30분 50초 정보를 만들 수 없다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;as.Date&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;2011-06-04 13:30:50&amp;quot;&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# 시각정보가 사라짐&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;2011-06-04&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이때부턴 포직스(POSIX) 클래스를 대중적으로 이용하는것으로 알고 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;as.POSIXct&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;2011-06-04 13:30:50&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;2011-06-04 13:30:50 KST&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이번엔 lubridate package 의 경우이다.&lt;br /&gt;
lubridate package 에는 &amp;quot;y&amp;quot;, &amp;quot;m&amp;quot;, &amp;quot;d&amp;quot; 심볼 뿐만 아니라 &amp;quot;h&amp;quot;, &amp;quot;m&amp;quot;, &amp;quot;s&amp;quot; 역시 준비되어 있다.&lt;br /&gt;
각각 hour, minute, second 로 이해할 수 있다.&lt;br /&gt;
위의 설명했던 대로 &amp;quot;y&amp;quot;, &amp;quot;m&amp;quot;, &amp;quot;d&amp;quot; 와 &amp;quot;h&amp;quot;, &amp;quot;m&amp;quot;, &amp;quot;s&amp;quot; 를 잘 조합하여 사용하면&lt;br /&gt;
비교적 편하게 &amp;quot;2011년 6월 4일 13시 30분 50초&amp;quot; 정보를 담을 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;ymd_hms&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;2011-06-04 13:30:50&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;2011-06-04 13:30:50 UTC&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;as.POSIXct()&lt;/code&gt; 와 비교해볼 때 날짜시각 객체를 만드는 방법이 별반 틀릴 것이 없다.&lt;br /&gt;
하지만 조금 더 융통성이 있게 사용할 수 있는 점들이 몇 가지 눈에 띈다.&lt;/p&gt;
&lt;p&gt;만약 분, 초 단위의 정보가 없는 경우 &amp;quot;2011년 6월 4일 13시&amp;quot; 의 정보가 투입된다고 가정하면 어떨까?&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;ymd_h&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;2011-06-04 13&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;2011-06-04 13:00:00 UTC&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ymd_hms()&lt;/code&gt; 에서 &amp;quot;m&amp;quot;, &amp;quot;s&amp;quot; 심볼을 제외한 &lt;code&gt;ymd_h()&lt;/code&gt; 함수를 이용해 파싱하면 된다.&lt;br /&gt;
하지만 &lt;code&gt;as.POSIXct()&lt;/code&gt; 으로 &lt;code&gt;&amp;quot;2011-06-04 13&amp;quot;&lt;/code&gt; 를 파싱하는 방법은 조금 고민을 해야하거나 투입되는 문자열 자체를 사전에 건드려야 하는 과정이 필요하다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;as.POSIXct&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;2011-06-04 13&amp;quot;&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# No&lt;/span&gt;
## [1] &amp;quot;2011-06-04 KST&amp;quot;
&lt;span class=&quot;kw&quot;&gt;as.POSIXct&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;2011-06-04 13:00:00&amp;quot;&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# Yes&lt;/span&gt;
## [1] &amp;quot;2011-06-04 13:00:00 KST&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이런 예시로 볼 때 lubridate package 는 사용자 관점으로 친숙한 도구들이 여럿 준비되어 있다.&lt;br /&gt;
이외에도 heterogeneous format 에 대한 대비 역시 날짜 + 시각 데이터에도 적용된다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;부분정보-추출-extracting-information&quot;&gt;부분정보 추출 (Extracting information)&lt;/h2&gt;
&lt;p&gt;lubridate package 에는 부분정보를 추출하기 위한 간편 함수들이 여럿 준비되어 있다.&lt;br /&gt;
&lt;code&gt;second()&lt;/code&gt;, &lt;code&gt;minute()&lt;/code&gt;, &lt;code&gt;hour()&lt;/code&gt;, &lt;code&gt;day()&lt;/code&gt;, &lt;code&gt;wday()&lt;/code&gt;, &lt;code&gt;yday()&lt;/code&gt;, &lt;code&gt;week()&lt;/code&gt;, &lt;code&gt;month()&lt;/code&gt;, &lt;code&gt;year()&lt;/code&gt; 처럼 함수명칭도 상식적으로 이해하기 쉬운 것들이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;ld1 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;ymd_hms&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;2011-06-04 13:30:50&amp;quot;&lt;/span&gt;)

&lt;span class=&quot;kw&quot;&gt;year&lt;/span&gt;(ld1)
## [1] 2011
&lt;span class=&quot;kw&quot;&gt;month&lt;/span&gt;(ld1)
## [1] 6
&lt;span class=&quot;kw&quot;&gt;day&lt;/span&gt;(ld1)
## [1] 4
&lt;span class=&quot;kw&quot;&gt;wday&lt;/span&gt;(ld1)
## [1] 7
&lt;span class=&quot;kw&quot;&gt;yday&lt;/span&gt;(ld1)
## [1] 155
&lt;span class=&quot;kw&quot;&gt;hour&lt;/span&gt;(ld1)
## [1] 13
&lt;span class=&quot;kw&quot;&gt;minute&lt;/span&gt;(ld1)
## [1] 30
&lt;span class=&quot;kw&quot;&gt;second&lt;/span&gt;(ld1)
## [1] 50&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;특히 month, wday 의 경우 &lt;code&gt;label&lt;/code&gt; 인자를 가지고 있는데 이를 &lt;code&gt;TRUE&lt;/code&gt; 로 설정할 경우에&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;month&lt;/span&gt;(ld1, &lt;span class=&quot;dt&quot;&gt;label =&lt;/span&gt; T)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] Jun
## 12 Levels: Jan &amp;lt; Feb &amp;lt; Mar &amp;lt; Apr &amp;lt; May &amp;lt; Jun &amp;lt; Jul &amp;lt; Aug &amp;lt; Sep &amp;lt; ... &amp;lt; Dec&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;wday&lt;/span&gt;(ld1, &lt;span class=&quot;dt&quot;&gt;label =&lt;/span&gt; T)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] Sat
## Levels: Sun &amp;lt; Mon &amp;lt; Tues &amp;lt; Wed &amp;lt; Thurs &amp;lt; Fri &amp;lt; Sat&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;월, 요일의 명칭을 factor 로 볼 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;부분정보-수정&quot;&gt;부분정보 수정&lt;/h3&gt;
&lt;p&gt;&amp;quot;2011년 6월 4일 13:30:50&amp;quot; 로 저장되어있던 &lt;code&gt;ld1&lt;/code&gt; 에 대해 시각(hour)을 10시로 바꾸려면 어떻게 하여야 할까?&lt;br /&gt;
내가볼 때 가장 간단한 방법은 부분정보 추출시 사용했던 간편함수들과 assign 연산자를 조합시켜 변경하는 방법이다.&lt;br /&gt;
아래처럼 사용하면 된다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;hour&lt;/span&gt;(ld1) &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;
ld1&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;2011-06-04 10:30:50 UTC&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;update()&lt;/code&gt; 제너릭 함수를 사용할 수도 있는데, 엄밀히 말하면 &lt;code&gt;update.POSIXt()&lt;/code&gt; 를 이용하는 방법다.&lt;br /&gt;
아래 코드는 &lt;code&gt;update()&lt;/code&gt; 함수를 이용해 10시로 변경된 &lt;code&gt;ld1&lt;/code&gt; 을 다시 13로 되돌리는 코드이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;ld1 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;update&lt;/span&gt;(ld1, &lt;span class=&quot;dt&quot;&gt;hour =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;13&lt;/span&gt;)
ld1&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;2011-06-04 13:30:50 UTC&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;POSIXlt class 인 경우엔 &lt;code&gt;$&lt;/code&gt; 와 assign operator 를 조합해 사용할 수 있는데 이 또한 매력적인 방법이라 생각된다.&lt;br /&gt;
하지만 아쉽게도 &lt;code&gt;ld1&lt;/code&gt; 는 POSIXct class 이므로 &lt;code&gt;$&lt;/code&gt; 가 바로 먹히지는 않는다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;ld1$hour &lt;span class=&quot;co&quot;&gt;# error&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;굳이 &lt;code&gt;$&lt;/code&gt; 과 assign operator 를 조합해 사용하고 싶다면 &lt;code&gt;as.POSIXlt()&lt;/code&gt; 를 한번 거쳐야 할 것이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;ld2 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;as.POSIXlt&lt;/span&gt;(ld1)
ld2$hour &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;
ld2&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;2011-06-04 10:30:50 UTC&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;날짜시각에-대한-산술연산&quot;&gt;날짜시각에 대한 산술연산&lt;/h2&gt;
&lt;p&gt;lubridate 와 같은 패키지를 공부하는 목적 중 가장 중요한 특징이 아닐까 싶다.&lt;br /&gt;
날짜 + 시각에 대한 산술연산은 매우 민감하고도, 생각보다 짜증 나는 문제이다.&lt;/p&gt;
&lt;p&gt;사과 30개가 있는데, 사과 2개를 더하면 32개가 된다.&lt;br /&gt;
1월 30일인데, 2틀을 더하면(지나면) 32일이 될까?&lt;br /&gt;
개인적으론 32일이 되어버렸으면 좋겠지만 32일이란 건 존재하지 않는다. 2월 1일이 된다.&lt;/p&gt;
&lt;p&gt;나처럼 단순무식한 것을 좋아하는 사람에겐 날짜 + 시각에 대한 산술연산은 많은 피로도를 줄 수 있다.&lt;br /&gt;
lubridate package 는 이를 예방할 수 있는 강력한 함수들이 많이 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;ymd&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;2016-01-30&amp;quot;&lt;/span&gt;) +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;days&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;2016-02-01&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위의 코드는 1월 30일인데, 2틀을 더하면(지나면)&lt;br /&gt;
의 문제를 풀어주는 코드이다.&lt;/p&gt;
&lt;p&gt;특정기간이 지나면 무슨일이 되는지 이렇게 산술연산이 가능하다.&lt;/p&gt;
&lt;p&gt;지금까지 단일시점 한개의 날짜시각 데이터를 가지고 놀았는데&lt;br /&gt;
이런 식으로 R의 Vectorization 특징을 활용하여 복수개의 시점을 만들 수도 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;ymd&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;2016-01-30&amp;quot;&lt;/span&gt;) -&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;days&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;2016-01-29&amp;quot; &amp;quot;2016-01-28&amp;quot; &amp;quot;2016-01-27&amp;quot; &amp;quot;2016-01-26&amp;quot; &amp;quot;2016-01-25&amp;quot;
##  [6] &amp;quot;2016-01-24&amp;quot; &amp;quot;2016-01-23&amp;quot; &amp;quot;2016-01-22&amp;quot; &amp;quot;2016-01-21&amp;quot; &amp;quot;2016-01-20&amp;quot;
## [11] &amp;quot;2016-01-19&amp;quot; &amp;quot;2016-01-18&amp;quot; &amp;quot;2016-01-17&amp;quot; &amp;quot;2016-01-16&amp;quot; &amp;quot;2016-01-15&amp;quot;
## [16] &amp;quot;2016-01-14&amp;quot; &amp;quot;2016-01-13&amp;quot; &amp;quot;2016-01-12&amp;quot; &amp;quot;2016-01-11&amp;quot; &amp;quot;2016-01-10&amp;quot;
## [21] &amp;quot;2016-01-09&amp;quot; &amp;quot;2016-01-08&amp;quot; &amp;quot;2016-01-07&amp;quot; &amp;quot;2016-01-06&amp;quot; &amp;quot;2016-01-05&amp;quot;
## [26] &amp;quot;2016-01-04&amp;quot; &amp;quot;2016-01-03&amp;quot; &amp;quot;2016-01-02&amp;quot; &amp;quot;2016-01-01&amp;quot; &amp;quot;2015-12-31&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;잠깐 &lt;code&gt;days()&lt;/code&gt; 함수명칭을 살펴보자.&lt;br /&gt;
위에서 부분정보 추출 간편함수중 &lt;code&gt;day()&lt;/code&gt; 가 있었는데 마지막에 &amp;quot;s&amp;quot; 가 붙음으로써 쓰임이 달라진 것을 볼 수 있다.&lt;br /&gt;
&lt;code&gt;days()&lt;/code&gt; 뿐만 아니라 &lt;code&gt;seconds()&lt;/code&gt;, &lt;code&gt;minutes()&lt;/code&gt;, &lt;code&gt;hours()&lt;/code&gt;, &lt;code&gt;weeks()&lt;/code&gt;, &lt;code&gt;years()&lt;/code&gt;, &lt;code&gt;milliseconds()&lt;/code&gt;, &lt;code&gt;microseconds()&lt;/code&gt;, &lt;code&gt;nanoseconds()&lt;/code&gt;, &lt;code&gt;picoseconds()&lt;/code&gt; 의 함수들이 이와 같은 산술연산에서 사용할 수 있는 패밀리이다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cran.r-project.org/web/packages/lubridate/vignettes/lubridate.html&quot;&gt;Do more with dates and times in R with lubridate 1.3.0&lt;/a&gt; 에서 꽤 감명깊은(?) 예제를 발견했는데&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;ymd&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;2013-01-31&amp;quot;&lt;/span&gt;) +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;months&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;11&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;2013-01-31&amp;quot; NA           &amp;quot;2013-03-31&amp;quot; NA           &amp;quot;2013-05-31&amp;quot;
##  [6] NA           &amp;quot;2013-07-31&amp;quot; &amp;quot;2013-08-31&amp;quot; NA           &amp;quot;2013-10-31&amp;quot;
## [11] NA           &amp;quot;2013-12-31&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위 결과를 통해&lt;br /&gt;
월 중에 31일이 존재하지 않는 월이 어디인지를 알 수 있게 된다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;lubridate-와-dplyr-간의-조합&quot;&gt;lubridate 와 dplyr 간의 조합&lt;/h2&gt;
&lt;p&gt;lubridate 이든 xts 이든 간에&lt;br /&gt;
결국은 이러한 Time index 정보들이 담긴 Table 형태에 정보들을 가공하고 처리하게 될 가능성이 매우 높다.&lt;br /&gt;
dplyr package 와 조합해 현업에서 어떻게 시너지를 일으킬 지를&lt;br /&gt;
보잘것없는 예제를 통해 조금이나마 확인해 보고 싶다.&lt;br /&gt;
lubridate package 에 내장된 데이터셋 &lt;code&gt;lakers&lt;/code&gt; 를 이용해 보았다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(dplyr)
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt;(lakers)

lakers &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;lakers %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;tbl_df
lakers&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 34,624 &amp;lt;U+00D7&amp;gt; 13
##        date opponent game_type  time period      etype  team
##       &amp;lt;int&amp;gt;    &amp;lt;chr&amp;gt;     &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;  &amp;lt;int&amp;gt;      &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;
## 1  20081028      POR      home 12:00      1  jump ball   OFF
## 2  20081028      POR      home 11:39      1       shot   LAL
## 3  20081028      POR      home 11:37      1    rebound   LAL
## 4  20081028      POR      home 11:25      1       shot   LAL
## 5  20081028      POR      home 11:23      1    rebound   LAL
## 6  20081028      POR      home 11:22      1       shot   LAL
## 7  20081028      POR      home 11:22      1       foul   POR
## 8  20081028      POR      home 11:22      1 free throw   LAL
## 9  20081028      POR      home 11:00      1       foul   LAL
## 10 20081028      POR      home 10:53      1       shot   POR
## # ... with 34,614 more rows, and 6 more variables: player &amp;lt;chr&amp;gt;,
## #   result &amp;lt;chr&amp;gt;, points &amp;lt;int&amp;gt;, type &amp;lt;chr&amp;gt;, x &amp;lt;int&amp;gt;, y &amp;lt;int&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;잘 보면 &lt;code&gt;date&lt;/code&gt;, &lt;code&gt;time&lt;/code&gt; 변수가 서로 나뉘어 있다.&lt;br /&gt;
이를 지금까지 배운 lubridate 함수들을 이용하여 통합시켜 관리해보고 싶었다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;lakers &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;lakers %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;mutate&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;date =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;paste&lt;/span&gt;(date, time) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;ymd_hm) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;rename&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;time_index =&lt;/span&gt; date) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt;(-time)

lakers&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 34,624 &amp;lt;U+00D7&amp;gt; 12
##             time_index opponent game_type period      etype  team
##                 &amp;lt;dttm&amp;gt;    &amp;lt;chr&amp;gt;     &amp;lt;chr&amp;gt;  &amp;lt;int&amp;gt;      &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;
## 1  2008-10-28 12:00:00      POR      home      1  jump ball   OFF
## 2  2008-10-28 11:39:00      POR      home      1       shot   LAL
## 3  2008-10-28 11:37:00      POR      home      1    rebound   LAL
## 4  2008-10-28 11:25:00      POR      home      1       shot   LAL
## 5  2008-10-28 11:23:00      POR      home      1    rebound   LAL
## 6  2008-10-28 11:22:00      POR      home      1       shot   LAL
## 7  2008-10-28 11:22:00      POR      home      1       foul   POR
## 8  2008-10-28 11:22:00      POR      home      1 free throw   LAL
## 9  2008-10-28 11:00:00      POR      home      1       foul   LAL
## 10 2008-10-28 10:53:00      POR      home      1       shot   POR
## # ... with 34,614 more rows, and 6 more variables: player &amp;lt;chr&amp;gt;,
## #   result &amp;lt;chr&amp;gt;, points &amp;lt;int&amp;gt;, type &amp;lt;chr&amp;gt;, x &amp;lt;int&amp;gt;, y &amp;lt;int&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위의 코드를 설명하면&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;code&gt;date&lt;/code&gt;, &lt;code&gt;time&lt;/code&gt; 두변수를 붙인 문자열에 대해 &lt;code&gt;ymd_hm()&lt;/code&gt; 함수로 넘긴 후&lt;/li&gt;
&lt;li&gt;&lt;code&gt;time_index&lt;/code&gt; 라는 변수에 담고,&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;date&lt;/code&gt;, &lt;code&gt;time&lt;/code&gt; 두 변수를 제외한 것이다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이렇게 알맞게 변형된 &lt;code&gt;lakers&lt;/code&gt; 를 이용해 좀 더 의미가 있을만한 탐색을 해보겠다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;group-by-연산&quot;&gt;Group by 연산&lt;/h3&gt;
&lt;p&gt;첫번째는 Group by 연산이다.&lt;br /&gt;
월별 평균을 &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; 변수에 대해서 계산해보겠다.&lt;br /&gt;
이때 우리가 알고있는 &lt;code&gt;month()&lt;/code&gt; 함수를 이용하면 아주 간편하게 할 수 있겠다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;lakers %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;group_by&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;month&lt;/span&gt;(time_index)) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;summarize&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;mean_x =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;mean&lt;/span&gt;(x, &lt;span class=&quot;dt&quot;&gt;na.rm =&lt;/span&gt; T), &lt;span class=&quot;dt&quot;&gt;mean_y =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;mean&lt;/span&gt;(y, &lt;span class=&quot;dt&quot;&gt;na.rm =&lt;/span&gt; T))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 7 &amp;lt;U+00D7&amp;gt; 3
##   `month(time_index)`   mean_x   mean_y
##                 &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;
## 1                   1 25.49382 13.89279
## 2                   2 25.01759 13.17499
## 3                   3 25.51587 13.20571
## 4                   4 25.38344 13.46396
## 5                  10 24.92188 13.12500
## 6                  11 25.47463 13.36926
## 7                  12 25.05895 13.48262&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;연별 평균을 계산하고 싶다면 &lt;code&gt;year()&lt;/code&gt; 이용하면 된다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;lakers %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;group_by&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;year&lt;/span&gt;(time_index)) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;summarize&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;mean_x =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;mean&lt;/span&gt;(x, &lt;span class=&quot;dt&quot;&gt;na.rm =&lt;/span&gt; T), &lt;span class=&quot;dt&quot;&gt;mean_y =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;mean&lt;/span&gt;(y, &lt;span class=&quot;dt&quot;&gt;na.rm =&lt;/span&gt; T))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 2 &amp;lt;U+00D7&amp;gt; 3
##   `year(time_index)`   mean_x   mean_y
##                &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;
## 1               2008 25.23402 13.40776
## 2               2009 25.36407 13.44319&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;filter&quot;&gt;Filter&lt;/h3&gt;
&lt;p&gt;두번째는 &lt;code&gt;filter()&lt;/code&gt; 를 이용해 분석에 사용할 기간을 서브세팅 해보는 예제를 만들어 보고 싶었다.&lt;br /&gt;
아래 코드는 &amp;quot;2008-10-28 12:00:00&amp;quot; 이전의 기간을 서브세팅 하는 코드이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;lakers %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;filter&lt;/span&gt;(time_index &amp;lt;=&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;ymd_hms&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;2008-10-28 12:00:00&amp;quot;&lt;/span&gt;))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 416 &amp;lt;U+00D7&amp;gt; 12
##             time_index opponent game_type period      etype  team
##                 &amp;lt;dttm&amp;gt;    &amp;lt;chr&amp;gt;     &amp;lt;chr&amp;gt;  &amp;lt;int&amp;gt;      &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;
## 1  2008-10-28 12:00:00      POR      home      1  jump ball   OFF
## 2  2008-10-28 11:39:00      POR      home      1       shot   LAL
## 3  2008-10-28 11:37:00      POR      home      1    rebound   LAL
## 4  2008-10-28 11:25:00      POR      home      1       shot   LAL
## 5  2008-10-28 11:23:00      POR      home      1    rebound   LAL
## 6  2008-10-28 11:22:00      POR      home      1       shot   LAL
## 7  2008-10-28 11:22:00      POR      home      1       foul   POR
## 8  2008-10-28 11:22:00      POR      home      1 free throw   LAL
## 9  2008-10-28 11:00:00      POR      home      1       foul   LAL
## 10 2008-10-28 10:53:00      POR      home      1       shot   POR
## # ... with 406 more rows, and 6 more variables: player &amp;lt;chr&amp;gt;,
## #   result &amp;lt;chr&amp;gt;, points &amp;lt;int&amp;gt;, type &amp;lt;chr&amp;gt;, x &amp;lt;int&amp;gt;, y &amp;lt;int&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;잘 보면 기존에 레코드는 34624 개 였지만, 서브세팅 된 후 레코드는 416 개로 줄어든 것을 확인할 수 있다.&lt;/p&gt;
&lt;p&gt;만약 &amp;quot;2008-10-28 12:00:00&amp;quot; ~ &amp;quot;2009-03-09 00:33:00&amp;quot; 의 기간에 대해서 서브세팅을 하고싶다면 어떻게 하여야 할까?&lt;br /&gt;
물론 &lt;code&gt;filter()&lt;/code&gt; 안에 조건을 하나 더 넣으면 된다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;lakers %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;filter&lt;/span&gt;(time_index &amp;gt;=&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;ymd_hms&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;2008-10-28 12:00:00&amp;quot;&lt;/span&gt;), time_index &amp;lt;=&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;ymd_hms&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;2009-03-09 00:33:00&amp;quot;&lt;/span&gt;))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 25,554 &amp;lt;U+00D7&amp;gt; 12
##             time_index opponent game_type period     etype  team
##                 &amp;lt;dttm&amp;gt;    &amp;lt;chr&amp;gt;     &amp;lt;chr&amp;gt;  &amp;lt;int&amp;gt;     &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;
## 1  2008-10-28 12:00:00      POR      home      1 jump ball   OFF
## 2  2008-10-29 12:00:00      LAC      away      1 jump ball   OFF
## 3  2008-10-29 11:36:00      LAC      away      1      shot   LAL
## 4  2008-10-29 11:24:00      LAC      away      1      shot   LAC
## 5  2008-10-29 11:24:00      LAC      away      1   rebound   LAL
## 6  2008-10-29 11:08:00      LAC      away      1      shot   LAL
## 7  2008-10-29 10:58:00      LAC      away      1      shot   LAC
## 8  2008-10-29 10:57:00      LAC      away      1   rebound   LAL
## 9  2008-10-29 10:41:00      LAC      away      1      shot   LAL
## 10 2008-10-29 10:40:00      LAC      away      1   rebound   LAC
## # ... with 25,544 more rows, and 6 more variables: player &amp;lt;chr&amp;gt;,
## #   result &amp;lt;chr&amp;gt;, points &amp;lt;int&amp;gt;, type &amp;lt;chr&amp;gt;, x &amp;lt;int&amp;gt;, y &amp;lt;int&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그런데 lubridate package 에는 기간(Time intervals) 에 대해 조금 더 세련된 방법으로 처리할 수 있는 함수들을 제공해 주고 있다.&lt;br /&gt;
&lt;code&gt;interval()&lt;/code&gt; 함수와 &lt;code&gt;%within%&lt;/code&gt; 연산자를 이용하면 조금 더 직관적인 서브세팅을 할 수 있다.&lt;br /&gt;
아래처럼 말이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;inter &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;interval&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;ymd_hms&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;2008-10-28 12:00:00&amp;quot;&lt;/span&gt;), &lt;span class=&quot;kw&quot;&gt;ymd_hms&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;2009-03-09 00:33:00&amp;quot;&lt;/span&gt;))
lakers %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;filter&lt;/span&gt;(time_index %within%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;inter)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 25,554 &amp;lt;U+00D7&amp;gt; 12
##             time_index opponent game_type period     etype  team
##                 &amp;lt;dttm&amp;gt;    &amp;lt;chr&amp;gt;     &amp;lt;chr&amp;gt;  &amp;lt;int&amp;gt;     &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;
## 1  2008-10-28 12:00:00      POR      home      1 jump ball   OFF
## 2  2008-10-29 12:00:00      LAC      away      1 jump ball   OFF
## 3  2008-10-29 11:36:00      LAC      away      1      shot   LAL
## 4  2008-10-29 11:24:00      LAC      away      1      shot   LAC
## 5  2008-10-29 11:24:00      LAC      away      1   rebound   LAL
## 6  2008-10-29 11:08:00      LAC      away      1      shot   LAL
## 7  2008-10-29 10:58:00      LAC      away      1      shot   LAC
## 8  2008-10-29 10:57:00      LAC      away      1   rebound   LAL
## 9  2008-10-29 10:41:00      LAC      away      1      shot   LAL
## 10 2008-10-29 10:40:00      LAC      away      1   rebound   LAC
## # ... with 25,544 more rows, and 6 more variables: player &amp;lt;chr&amp;gt;,
## #   result &amp;lt;chr&amp;gt;, points &amp;lt;int&amp;gt;, type &amp;lt;chr&amp;gt;, x &amp;lt;int&amp;gt;, y &amp;lt;int&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2개의 조건을 자질구레하게 정의하는것 보단&lt;br /&gt;
&lt;code&gt;interval()&lt;/code&gt; 를 사용한 후자의 방법이 훨씬 직관적일 수 있겠다.&lt;/p&gt;
&lt;p&gt;참고로 덧붙이면 &lt;code&gt;interval()&lt;/code&gt; 함수대신 &lt;code&gt;%--%&lt;/code&gt; 연산자를 써도 된다.&lt;br /&gt;
&lt;code&gt;%--%&lt;/code&gt; 를 &amp;quot;~&amp;quot; 처럼 생각하면 편할 것 같다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;inter &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;ymd_hms&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;2008-10-28 12:00:00&amp;quot;&lt;/span&gt;) %--%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;ymd_hms&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;2009-03-09 00:33:00&amp;quot;&lt;/span&gt;)
lakers %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;filter&lt;/span&gt;(time_index %within%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;inter)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 25,554 &amp;lt;U+00D7&amp;gt; 12
##             time_index opponent game_type period     etype  team
##                 &amp;lt;dttm&amp;gt;    &amp;lt;chr&amp;gt;     &amp;lt;chr&amp;gt;  &amp;lt;int&amp;gt;     &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;
## 1  2008-10-28 12:00:00      POR      home      1 jump ball   OFF
## 2  2008-10-29 12:00:00      LAC      away      1 jump ball   OFF
## 3  2008-10-29 11:36:00      LAC      away      1      shot   LAL
## 4  2008-10-29 11:24:00      LAC      away      1      shot   LAC
## 5  2008-10-29 11:24:00      LAC      away      1   rebound   LAL
## 6  2008-10-29 11:08:00      LAC      away      1      shot   LAL
## 7  2008-10-29 10:58:00      LAC      away      1      shot   LAC
## 8  2008-10-29 10:57:00      LAC      away      1   rebound   LAL
## 9  2008-10-29 10:41:00      LAC      away      1      shot   LAL
## 10 2008-10-29 10:40:00      LAC      away      1   rebound   LAC
## # ... with 25,544 more rows, and 6 more variables: player &amp;lt;chr&amp;gt;,
## #   result &amp;lt;chr&amp;gt;, points &amp;lt;int&amp;gt;, type &amp;lt;chr&amp;gt;, x &amp;lt;int&amp;gt;, y &amp;lt;int&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;기타-간편-기능-함수들&quot;&gt;기타 간편 기능 함수들&lt;/h2&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;timezone-인자를-받을-수-있는-now&quot;&gt;Timezone 인자를 받을 수 있는 &lt;code&gt;now()&lt;/code&gt;&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;now&lt;/span&gt;()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;2016-09-18 21:35:41 KST&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;now()&lt;/code&gt; 함수는 &lt;code&gt;Sys.time()&lt;/code&gt; 와 거의 기능이 똑같다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;now&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;America/New_York&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;2016-09-18 08:35:41 EDT&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;now&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;UTC&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;단 위의 예제처럼&lt;br /&gt;
Timezone 변경에 대해서 &lt;code&gt;Sys.time()&lt;/code&gt; 과는 다르게 &lt;code&gt;now()&lt;/code&gt; 는 이를 반영한 날짜 + 시각을 반환할 수 있다는 차이가 있다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;오전-오후-am-pm&quot;&gt;오전? 오후? : &lt;code&gt;am()&lt;/code&gt;, &lt;code&gt;pm()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;현 시간이 오후인지 오전인지 확인하기 위해서&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;ld1&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;2011-06-04 13:30:50 UTC&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;hour&lt;/span&gt;(ld1) &amp;gt;=&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;와 같은 코드를 사용하기 보단&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;am&lt;/span&gt;(ld1)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] FALSE&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;pm&lt;/span&gt;(ld1)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;요런식으로 활용해 볼 수 있겠다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;시각에-대한-올림-내림-반올림&quot;&gt;시각에 대한 올림, 내림, 반올림&lt;/h3&gt;
&lt;p&gt;제목대로 시각에 대한 올림, 내림, 반올림은 생각만해도 끔찍하다.&lt;br /&gt;
&lt;code&gt;round_date()&lt;/code&gt;, &lt;code&gt;floor_date()&lt;/code&gt;, &lt;code&gt;ceiling_date()&lt;/code&gt; 함수를 활용하는게 정서상 좋을 것이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;ld1
## [1] &amp;quot;2011-06-04 13:30:50 UTC&amp;quot;

&lt;span class=&quot;kw&quot;&gt;round_date&lt;/span&gt;(ld1, &lt;span class=&quot;st&quot;&gt;&amp;quot;hour&amp;quot;&lt;/span&gt;)
## [1] &amp;quot;2011-06-04 14:00:00 UTC&amp;quot;
&lt;span class=&quot;kw&quot;&gt;round_date&lt;/span&gt;(ld1, &lt;span class=&quot;st&quot;&gt;&amp;quot;day&amp;quot;&lt;/span&gt;)
## [1] &amp;quot;2011-06-05 UTC&amp;quot;

&lt;span class=&quot;kw&quot;&gt;floor_date&lt;/span&gt;(ld1, &lt;span class=&quot;st&quot;&gt;&amp;quot;hour&amp;quot;&lt;/span&gt;)
## [1] &amp;quot;2011-06-04 13:00:00 UTC&amp;quot;
&lt;span class=&quot;kw&quot;&gt;floor_date&lt;/span&gt;(ld1, &lt;span class=&quot;st&quot;&gt;&amp;quot;day&amp;quot;&lt;/span&gt;)
## [1] &amp;quot;2011-06-04 UTC&amp;quot;

&lt;span class=&quot;kw&quot;&gt;ceiling_date&lt;/span&gt;(ld1, &lt;span class=&quot;st&quot;&gt;&amp;quot;hour&amp;quot;&lt;/span&gt;)
## [1] &amp;quot;2011-06-04 14:00:00 UTC&amp;quot;
&lt;span class=&quot;kw&quot;&gt;ceiling_date&lt;/span&gt;(ld1, &lt;span class=&quot;st&quot;&gt;&amp;quot;day&amp;quot;&lt;/span&gt;)
## [1] &amp;quot;2011-06-05 UTC&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://rpubs.com/davoodastaraky/lubridate&quot;&gt;Woking with Dates and Times with lubridate in R&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cran.r-project.org/web/packages/lubridate/vignettes/lubridate.html&quot;&gt;Do more with dates and times in R with lubridate 1.3.0&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 18 Sep 2016 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2016/09/18/lubridate_package.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2016/09/18/lubridate_package.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>회귀분석시 모델적합성에 관련된 예제로 자주 언급되는 anscombe dataset</title>
        <description>&lt;p&gt;회귀분석을 공부하게 되면&lt;br /&gt;
책이나 인터넷의 포스팅된 글에서 모델적합성의 중요성을 부각시키는 아래의 데이터 시각화 예제를 많이 보았을 것이다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/anscombe1.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;요즘에는 데이터시각화의 중요성을 부각시키는 예제로도 자주 활용되는데&lt;br /&gt;
그만큼 눈으로 직접 보는것이 힘이다.&lt;/p&gt;
&lt;p&gt;나는 종종 이 예제를 활용하고 싶을때가 많았는데&lt;br /&gt;
이 데이터셋을 구하기 전 처음에는 데이터셋의 이름을 모르고 있어서&lt;br /&gt;
직접 눈대중으로 만들려는 멍청한 짓을 한적이 있었다.&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;하지만 위에 사용된 데이터셋 이름이 &lt;a href=&quot;https://en.wikipedia.org/wiki/Anscombe%27s_quartet&quot;&gt;Anscombe&#39;s quartet&lt;/a&gt; 임을 알고는 구글링을 통해 손쉽게 얻을 수 있었다.&lt;/p&gt;
&lt;p&gt;그런데 또 뒤늦게&lt;br /&gt;
오늘 알아 챈 것이 있는데 R에서 &lt;a href=&quot;https://en.wikipedia.org/wiki/Anscombe%27s_quartet&quot;&gt;Anscombe&#39;s quartet&lt;/a&gt; 데이터셋이 빌트인 되어 있었다는 것이다.&lt;br /&gt;
데이터셋을 호출하기 위해선 &lt;code&gt;anscombe&lt;/code&gt; 만 치면 됬었다...&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;anscombe&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##    x1 x2 x3 x4    y1   y2    y3    y4
## 1  10 10 10  8  8.04 9.14  7.46  6.58
## 2   8  8  8  8  6.95 8.14  6.77  5.76
## 3  13 13 13  8  7.58 8.74 12.74  7.71
## 4   9  9  9  8  8.81 8.77  7.11  8.84
## 5  11 11 11  8  8.33 9.26  7.81  8.47
## 6  14 14 14  8  9.96 8.10  8.84  7.04
## 7   6  6  6  8  7.24 6.13  6.08  5.25
## 8   4  4  4 19  4.26 3.10  5.39 12.50
## 9  12 12 12  8 10.84 9.13  8.15  5.56
## 10  7  7  7  8  4.82 7.26  6.42  7.91
## 11  5  5  5  8  5.68 4.74  5.73  6.89&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;으악.. 허무하다..&lt;br /&gt;
&lt;code&gt;?anscombe&lt;/code&gt; 를 하고 나서 예제코드가 잘 준비된 것을 보니 지금까지 과정들이 헛수고임을 깨닫게 되었다...&lt;br /&gt;
그 충격에 이렇게 블로그 글로 포스팅을 하게 되었다. 😅&lt;/p&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;이 멍청한 짓 마저 의외로 엄청 어려워 실패 😓&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Fri, 16 Sep 2016 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/data_visualization/2016/09/16/Anscombe_dataset.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/data_visualization/2016/09/16/Anscombe_dataset.html</guid>
        
        
        <category>R</category>
        
        <category>Data_Visualization</category>
        
      </item>
    
      <item>
        <title>Timeline JS 소개 (with 나의 일본 여행계획)</title>
        <description>&lt;p&gt;10월에 친구들과 일본으로 여행을 갈 계획이다.&lt;br /&gt;
2개월이란 시간이 남아있는데 나에겐 첫 해외여행이어서 여러 가지를 신경 쓰고 준비해 보려고 한다.&lt;/p&gt;
&lt;p&gt;여행 초보인 내가 지금 고민하는 것은 여행일정표를 여행 동료들과 어떻게 공유하는 게 좋을까 고민하고 있다.&lt;br /&gt;
여행계획이라는 것이 상당히 즉흥적일 수도 있고, 시시각각 변할 수 있는 변덕쟁이이기 때문에 쉽게 수정할 수 있어야 하고, 수정된 것이 바로 적용되어 공유될 수 있어야 편리하다고 생각했다.&lt;br /&gt;
이 고민이 최근에 &lt;a href=&quot;https://timeline.knightlab.com/&quot;&gt;Timeline JS&lt;/a&gt; 라는 오픈소스를 발견하는 계기가 되었다.&lt;/p&gt;
&lt;a href=&quot;https://timeline.knightlab.com/&quot;&gt;&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/TimelineJS1.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;본 포스팅 글은 &lt;a href=&quot;https://timeline.knightlab.com/&quot;&gt;Timeline JS&lt;/a&gt; 의 간단한 소개와 사용방법을 내 여행계획과 함께 정리해 보고자 한다.&lt;br /&gt;
(※ 참고로 여행을 갈 당일이 되기까지 이글은 계속해서 변경될 것 같다!)&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;timeline-js&quot;&gt;&lt;a href=&quot;https://timeline.knightlab.com/&quot;&gt;Timeline JS&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;백문이 불여일견..&lt;br /&gt;
구구절절 소개하는 것보단 Timeline JS 로 만들 수 있는 것은 아래와 같은 애플리케이션이다.&lt;/p&gt;
&lt;iframe src=&quot;https://cdn.knightlab.com/libs/timeline3/latest/embed/index.html?source=1mgvNplYZJEfYU8q5_-ML9w4GjJcUH-CuMKSmUU4nI4k&amp;amp;font=Default&amp;amp;lang=en&amp;amp;initial_zoom=2&amp;amp;height=650&quot; width=&quot;100%&quot; height=&quot;650&quot; frameborder=&quot;0&quot;&gt;
&lt;/iframe&gt;
&lt;p&gt;이처럼 인터렉티브한 시간흐름표(Timeline)를 만들 수 있는 오픈소스 도구이다.&lt;br /&gt;
초보자를 위해 Timeline 에 대한 정보를 Google spreadsheet 에 잘 정리해 놓고 연동시키기만 하면 누구든지 만들 수 있다.&lt;br /&gt;
(전문가들을 위한 JSON 스킬을 이용하면 더 핵심적이고 다방면적인 기능들을 활용할 수 있다고 추가로 홈페이지에 소개되어 있다.)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://timeline.knightlab.com/&quot;&gt;Timeline JS&lt;/a&gt; 는 이처럼 &lt;strong&gt;연대기적 성격을 가진 정보를 쉽게 시각적으로 표현할 수 있는 훌륭한 도구&lt;/strong&gt;이다.&lt;br /&gt;
그리고 여러 장점이 있겠지만 무엇보다도 웹기반 애플리케이션이기 때문에 쉬운 공유가 가능하고, 다양한 타 애플리케이션과의 연동이 가능하다는 잠재력을 가지고 있다.&lt;/p&gt;
&lt;p&gt;위의 여행계획 정보가 담겨있는 Google spreadsheet 역시 웹을 통해 언제든지 수정, 편집이 가능하므로 Timeline 애플리케이션을 나뿐만 아니라 여행 동료들이 마음껏 수정할 수 있다.&lt;/p&gt;
&lt;p&gt;위의 Timeline 을 만들기 위해서 사용한 Google spreadsheet 는 아래와 같다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;img src=&quot;/assets/TimelineJS2.png&quot; /&gt;&lt;br&gt;&lt;/p&gt;
&lt;center&gt;
&lt;a href=&quot;https://docs.google.com/spreadsheets/d/1mgvNplYZJEfYU8q5_-ML9w4GjJcUH-CuMKSmUU4nI4k/edit#gid=0&quot; class=&quot;uri&quot;&gt;https://docs.google.com/spreadsheets/d/1mgvNplYZJEfYU8q5_-ML9w4GjJcUH-CuMKSmUU4nI4k/edit#gid=0&lt;/a&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;Timeline JS 홈페이지에서 기본적으로 &lt;a href=&quot;https://drive.google.com/previewtemplate?id=1pHBvXN7nmGkiG8uQSUB82eNlnL8xHu6kydzH_-eguHQ&amp;amp;mode=public&quot;&gt;템플릿&lt;/a&gt;을 제공해 주는데 이를 가져온 후 항목별로 나와 여행 동료들이 값을 수정한 것 이다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;tutorial&quot;&gt;Tutorial&lt;/h2&gt;
&lt;p&gt;직접 만들어 보고 싶은 욕구가 생기면?&lt;br /&gt;
행동으로 옮기기만 하면 된다.&lt;br /&gt;
&lt;a href=&quot;https://timeline.knightlab.com/&quot;&gt;Timeline JS&lt;/a&gt; 홈페이지에서 제공하는 튜토리얼 영상을 보면 내가 소개한 이야기들의 구체적인 방법들이 스크린캐스트로 담겨 있다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;iframe src=&quot;https://player.vimeo.com/video/143407878&quot; width=&quot;100%&quot; height=&quot;400&quot; frameborder=&quot;0&quot; webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;
&lt;/iframe&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 15 Aug 2016 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/open_source_tool/2016/08/15/Itinerary_Japan.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/open_source_tool/2016/08/15/Itinerary_Japan.html</guid>
        
        
        <category>Open_Source_Tool</category>
        
      </item>
    
      <item>
        <title>Blog 의 이전 (Wordpress 에서 Jekyll 로)</title>
        <description>&lt;br&gt;&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/jekyllchange.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;blog-를-이전했다&quot;&gt;Blog 를 이전했다!&lt;/h2&gt;
&lt;p&gt;기존의 블로그는 &lt;a href=&quot;https://ko.wordpress.org/&quot;&gt;Wordpress&lt;/a&gt;를 기반으로 하였고 국내 외부 호스팅 서비스를 이용하였었는데, 사실 그때의 블로그가 내생에 처음으로 만들어본 블로그이자 새로운 도전이었었다.&lt;br /&gt;
따라서 첫 블로그를 제작하는 과정이 신기하였고 들떠 있었으며, 워드프레스의 다양한 기능들과 플러그인 및 가능성들을 맛보며 두서없이 설계를 시작했었다.&lt;br /&gt;
그 과정이 상당히 재미있었는데 이 때문에 지인의 &amp;quot;Welcome to Jekyll!&amp;quot; 의 문장은 한 귀로 흘려버렸고 오로지 워드프레스 하나만을 의존하여 블로그를 기어코 완성시켰었다.&lt;/p&gt;
&lt;p&gt;지금은 어리숙한 설계 덕택에 블로그 관리 약 1년 이후, 생산성의 저하를 느끼기 시작했다.&lt;br /&gt;
그리고 이를 해결하기 위해선 많은 기능을 끼워 넣은 덕분에 높은 복잡성을 이해해야 한다는 문제를 체감하기 시작한 것이다.&lt;/p&gt;
&lt;p&gt;그리고 무엇보다도 Git 을 이전 블로그를 만들 때 전혀 알지 못했었기 때문에 버전관리의 부재 역시 치명적이었었다.&lt;br /&gt;
하지만 지금은 Git 을 알고 있고 이를 이용하여 오로지 글쓰기에 전념할 수 있는 환경을 갖출 수 있을 거란 자신감에 블로그 개편과 동시에 마침 Github 호스팅이 가능한 &lt;a href=&quot;https://jekyllrb-ko.github.io/&quot;&gt;Jekyll&lt;/a&gt; 로 갈아탈 생각까지 갖게 되었다.&lt;/p&gt;
&lt;p&gt;그리고 이렇게 블로그를 이전하고&lt;br /&gt;
템플릿에 있던 포스트 글 &amp;quot;Welcome to Jekyll!&amp;quot; 을 편집해 이 글을 작성하게 되었다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;통계-r-프로그래밍-카페와의-독립&quot;&gt;&lt;a href=&quot;http://cafe.naver.com/lovetokens&quot;&gt;통계 R 프로그래밍 카페&lt;/a&gt;와의 독립&lt;/h2&gt;
&lt;p&gt;이전 블로그는 내가 운영하는 &lt;a href=&quot;http://cafe.naver.com/lovetokens&quot;&gt;통계 R 프로그래밍 카페&lt;/a&gt;의 연결고리로서 역할이 사실 강했다.&lt;br /&gt;
그리고 그 당시 R 언어에 대해 심오하게 공부하여야겠다는 의지 또한 담겨있어서 였을까? 블로그 마저도 제목에 R 이 포함되어 블로그의 성격을 국한시켰었다.&lt;br /&gt;
하지만 지금은 상황이 다르다.&lt;br /&gt;
데이터 분석을 하기 위해 R 언어 이외에도 알아야 하는 컴퓨터 기술, 언어, 서비스, 지식, 플랫폼들은 무궁무진하게 많아지고 있고, 급진적으로 발전하며 새로운 기술이 생길 것이라는 것을..&lt;br /&gt;
내가 Jekyll 이란 새로운 기술을 이용하여 블로그를 제작하듯이 말이다.&lt;br /&gt;
내가 공부하고 연구해야 할 것을 R로만 국한했던 이전 블로그는 지금의 취지와 많이 달라졌다.&lt;br /&gt;
때문에 블로그 이전과 동시에 &amp;quot;통계 R 프로그래밍&amp;quot; 커뮤니티 카페와 독립을 꾀하고자 한다.&lt;/p&gt;
</description>
        <pubDate>Sat, 23 Jul 2016 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/diary/open_source_tool/2016/07/23/Welcome_to_Jekyll.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/diary/open_source_tool/2016/07/23/Welcome_to_Jekyll.html</guid>
        
        
        <category>Diary</category>
        
        <category>Open_Source_Tool</category>
        
      </item>
    
      <item>
        <title>R에서 특정 웹페이지의 이미지 파일 Crawling 하기</title>
        <description>&lt;h2 id=&quot;목표&quot;&gt;목표&lt;/h2&gt;
&lt;p&gt;크롤링과 같은 실전은 경험이 전무하였는데, 최근 친구의 질문 덕분에 제대로 된 크롤링 경험을 쌓을 수 있었다.&lt;br /&gt;
대단한 경험은 아니지만 나에게 있어 신선했던 경험을 공유하기 위해 정리해 본다.&lt;/p&gt;
&lt;p&gt;본 포스팅 글은 특정 웹페이지의 이미지 파일들을 내 컴퓨터 하드로 저장시키기 위한 R 코드를 작성하는것을 목표로 한다.&lt;br /&gt;
이 목표를 이룰 수 있는 완벽한 방법을 소개하는 것은 아니지만, &lt;strong&gt;최소한 http 프로토콜을 통해 접근가능한 이미지는 자동으로 다운로드할 수 있는 방법&lt;/strong&gt;이 될 것이다.&lt;br /&gt;
웹페이지의 그림파일들을 저장시키고 싶은데 그러기엔 워낙 많은 이미지 파일들이 있어 손수 저장시키기엔 부담이 있을 경우 어느정도는 대안이 될 수 있겠다.&lt;/p&gt;
&lt;p&gt;예제로 선택한 웹 사이트는 Google 의 이미지 검색에서 &amp;quot;men&amp;quot; 이런 검색어로 검색시 나타나는 웹페이지로 &lt;a href=&quot;https://www.google.co.kr/search?biw=1436&amp;amp;bih=782&amp;amp;tbm=isch&amp;amp;sa=1&amp;amp;q=men&amp;amp;oq=men&amp;amp;gs_l=img.3...4008.4572.0.5170.0.0.0.0.0.0.0.0..0.0....0...1c.1.64.img..0.0.0.id2CbaNm_HQ&quot;&gt;아래 링크&lt;/a&gt;와 같다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.google.co.kr/search?biw=1436&amp;amp;bih=782&amp;amp;tbm=isch&amp;amp;sa=1&amp;amp;q=men&amp;amp;oq=men&amp;amp;gs_l=img.3...4008.4572.0.5170.0.0.0.0.0.0.0.0..0.0....0...1c.1.64.img..0.0.0.id2CbaNm_HQ&quot; class=&quot;uri&quot;&gt;https://www.google.co.kr/search?biw=1436&amp;amp;bih=782&amp;amp;tbm=isch&amp;amp;sa=1&amp;amp;q=men&amp;amp;oq=men&amp;amp;gs_l=img.3...4008.4572.0.5170.0.0.0.0.0.0.0.0..0.0....0...1c.1.64.img..0.0.0.id2CbaNm_HQ&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;준비&quot;&gt;준비&lt;/h3&gt;
&lt;p&gt;우선 이미지 파일만을 크롤링 하는 방법에 대해서 구상할 필요가 있다.&lt;br /&gt;
크롤링 컨셉은 이렇게 잡았보았다.&lt;/p&gt;
&lt;p&gt;첫번째 : 웹페이지의 HTML 코드를 파싱하여 R 에서 가공할 수 있는 형태로 변환한다.&lt;br /&gt;
두번째 : 변환된 HTML 코드에서 &amp;lt;img&amp;gt; tag 의 src 인자값을 정규표현식을 이용해 추출한다.&lt;br /&gt;
세번째 : 준비된 src 인자값 링크들을 R 객체로 만들고 download 명령을 반복문을 이용해 내려준다.&lt;/p&gt;
&lt;p&gt;이렇게 되면 자동적으로 이미지 파일들을 선별하여 내 컴퓨터로 가져올 수 있게 될 것이다.&lt;/p&gt;
&lt;p&gt;패키지는 아래의 3개 패키지를 이용하여 코딩을 하였다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(RCurl)
&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(XML)
&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(dplyr) &lt;span class=&quot;co&quot;&gt;# Optional package (for pipe operator)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;시작&quot;&gt;시작&lt;/h2&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;img-tag-의-src-인자값-크롤링&quot;&gt;img tag 의 src 인자값 크롤링&lt;/h3&gt;
&lt;p&gt;R 내에서 웹 사이트의 html code 를 character 형식으로 가공하기 위해선 아래의 절차가 필요했다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;htmlcode &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;getURL&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;https://www.google.co.kr/search?biw=1436&amp;amp;bih=782&amp;amp;tbm=isch&amp;amp;sa=1&amp;amp;q=men&amp;amp;oq=men&amp;amp;gs_l=img.3...4008.4572.0.5170.0.0.0.0.0.0.0.0..0.0....0...1c.1.64.img..0.0.0.id2CbaNm_HQ&amp;quot;&lt;/span&gt;) %&amp;gt;%
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;htmlParse %&amp;gt;%
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;capture.output&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;getURL()&lt;/code&gt; 함수는 RCurl package 의 함수이다.&lt;br /&gt;
함수에 url 을 입력하는 형태로 사용하며, 웹피이지의 html 코드를 그대로 가져오는 역할을 한다.&lt;br /&gt;
단 단락이 나뉘어 있지 않은, 이쁘지 않은 형태 그대로 가져오기 때문에 추후에 정규표현식을 이용한 패턴추출시 어려운 점이 생긴다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;htmlParse()&lt;/code&gt; 함수는 XML package 의 함수인데 html 의 구문을 어느정도 이해한 후 단락을 나눠주는 역할을 한다.&lt;br /&gt;
단 이 함수를 통해 반환되는 결과물은 class 가 특이한 형태로 반환된다.&lt;br /&gt;
우리는 대단한 것을 하지 않을 것이므로 일반적인 character 형태로 다시 되돌리기 위해 &lt;code&gt;capture.output()&lt;/code&gt; 함수를 한번 더 거친 결과물을 &lt;code&gt;htmlcode&lt;/code&gt; 객체로 할당했다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;htmlcode&lt;/code&gt; 의 head 부분만 살펴보면 html 의 시작을 알리는 &amp;quot;&amp;lt;!DOCTYPE html&amp;gt;&amp;quot; 이 첫번째 단락에 있는것을 볼 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;head&lt;/span&gt;(htmlcode)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;&amp;lt;!DOCTYPE html&amp;gt;&amp;quot;                                                                                   
## [2] &amp;quot;&amp;lt;html itemscope=\&amp;quot;\&amp;quot; itemtype=\&amp;quot;http://schema.org/SearchResultsPage\&amp;quot; lang=\&amp;quot;ko\&amp;quot;&amp;gt;&amp;quot;                
## [3] &amp;quot;&amp;lt;head&amp;gt;&amp;quot;                                                                                            
## [4] &amp;quot;&amp;lt;meta content=\&amp;quot;text/html; charset=UTF-8\&amp;quot; http-equiv=\&amp;quot;Content-Type\&amp;quot;&amp;gt;&amp;quot;                           
## [5] &amp;quot;&amp;lt;meta content=\&amp;quot;/images/branding/googleg/1x/googleg_standard_color_128dp.png\&amp;quot; itemprop=\&amp;quot;image\&amp;quot;&amp;gt;&amp;quot;
## [6] &amp;quot;&amp;lt;link href=\&amp;quot;/images/branding/product/ico/googleg_lodp.ico\&amp;quot; rel=\&amp;quot;shortcut icon\&amp;quot;&amp;gt;&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;R에서 접근 가능한 html code 가 준비 되었으므로 이젠 정규표현식을 통해 우리가 필요로하는 이미지 주소링크를 추출한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Step1) 우선 img 테그 전체를 소비&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;img_tag_pattern &amp;lt;-&lt;span class=&quot;st&quot;&gt; &amp;quot;&amp;lt;img.*?&amp;gt;&amp;quot;&lt;/span&gt;
img_tag &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;htmlcode %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;regmatches&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;regexpr&lt;/span&gt;(img_tag_pattern, .))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Step2) 소비된 img tag 중에서 src argument 값을 소비&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;src_href_pattern &amp;lt;-&lt;span class=&quot;st&quot;&gt; &amp;quot;(?&amp;lt;=src=&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\\\&amp;quot;&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;).*?(?=&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\\\&amp;quot;&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;)&amp;quot;&lt;/span&gt;
src_href &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;img_tag %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;regmatches&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;regexpr&lt;/span&gt;(src_href_pattern, ., &lt;span class=&quot;dt&quot;&gt;perl =&lt;/span&gt; T))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;각각의 정규표현식을 설명하면 첫번째 단계의 &lt;code&gt;&amp;lt;img.*?&amp;gt;&lt;/code&gt; 은 img tag 전체를 선택하는 패턴이며,&lt;br /&gt;
두번째 단계의 &lt;code&gt;(?&amp;lt;=src=\\\&amp;quot;).*?(?=\\\&amp;quot;)&lt;/code&gt; 는 src 인자값을 선택하되 양옆의 &amp;quot;&amp;quot; 큰따옴표는 소비하지 않는 패턴이다. (R의 grep 함수에서 정규표현식의 이스케이프가 제대로 동작하지 않는다면 &lt;code&gt;perl = TRUE&lt;/code&gt; 를 통해 해결이 가능하기도 하다.)&lt;/p&gt;
&lt;p&gt;단계를 크개 2개로 나누어 정규표현식을 짠 이유는 img tag 중에서 src 인자값을 추출하여야 이미지링크 문자열만 뽑을 수 있기 때문이다.&lt;/p&gt;
&lt;p&gt;이렇게 준비된 결과 &lt;code&gt;src_href&lt;/code&gt; 를 살펴보면 다음과 같다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;src_href&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;/textinputassistant/tia.png&amp;quot;                                                                                       
##  [2] &amp;quot;https://encrypted-tbn1.gstatic.com/images?q=tbn:ANd9GcTaailzt78W3ZQh40T90r1Rka4_l_c5GJofA-cljDIemIJBGxoHOUlz-vA&amp;quot;   
##  [3] &amp;quot;https://encrypted-tbn1.gstatic.com/images?q=tbn:ANd9GcQVaheNF9b4uR3SPGSyoWMl0g-yosunwqNQ9f4Mx2dEYnvjsaBND7-SSEEb&amp;quot;  
##  [4] &amp;quot;https://encrypted-tbn1.gstatic.com/images?q=tbn:ANd9GcT2JkzFeiNIE1yWYzlaRa64eqUEvlBPIKvto5a7DkDOYzZE6Eoq8HnNszTF&amp;quot;  
##  [5] &amp;quot;https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcRGUd7FTthseKrn5SDOAF6c_4fk35-FfC7M3D8z37pWlGLcgna3JOwDC39hkw&amp;quot;
##  [6] &amp;quot;https://encrypted-tbn2.gstatic.com/images?q=tbn:ANd9GcTguxDqYAOCbfYYxrO3y_pMI-pVyuqQ4PKnyIgGG3A_k4XYXCgB5Ktl-Ncq&amp;quot;  
##  [7] &amp;quot;https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcSqDHBvQ4hOssWtMnPZkv2YYG1DDJ2c7d-vYIpwq8rLju55EUExxUpBv-6I&amp;quot;  
##  [8] &amp;quot;https://encrypted-tbn2.gstatic.com/images?q=tbn:ANd9GcRS8Q8WGPZhpTSTTV6AS5WhUNZqzMMGhq-LsgmHkgWOeVXDSsrRLt7ldYo&amp;quot;   
##  [9] &amp;quot;https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSK0ydbRXqqpR-1VJmI-P1F2BRbdTD4s33sSPky6lqnwnGsBIEbr_OlVia_&amp;quot;  
## [10] &amp;quot;https://encrypted-tbn2.gstatic.com/images?q=tbn:ANd9GcRozDkozg5BJIFTLSo1jkeNt_sM_bIW5q51excQJ46dQgAamfA5sVErKvg2&amp;quot;  
## [11] &amp;quot;https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcScFxYNMLxdvnuAwXU0uVcBNZnGNtWjQDW-EhU5isVp7edlxYM0cluR5AI&amp;quot;   
## [12] &amp;quot;https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcSWGwGpQFC7qTNpvjtJ-d56E3NgKoVDxPZcDGKpMHqitRKk6NOwPG1ZU9Q&amp;quot;   
## [13] &amp;quot;https://encrypted-tbn2.gstatic.com/images?q=tbn:ANd9GcS0WJGngmvgtyZL7aOsQiMIw24_51lktpSxlaVCRyIqYnAW-timSUCYYl8&amp;quot;   
## [14] &amp;quot;https://encrypted-tbn1.gstatic.com/images?q=tbn:ANd9GcSG4dEKuBVm59c9boqlKtBbcNFwJhwYngw76ipqK2pgBb5V_KTxcr_SrdBiVw&amp;quot;
## [15] &amp;quot;https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQX-3l2ybOEZnmSsoTEtHXeEtWSba2fuqi0rhhewUxPk0ctOTxh5ReJT4pz&amp;quot;  
## [16] &amp;quot;https://encrypted-tbn1.gstatic.com/images?q=tbn:ANd9GcQ4Aa-lZ0I-vBtUIMFUb_Vxh0LaqU4QqJw2TmnsPzF49XTZFMkOAri25SI&amp;quot;   
## [17] &amp;quot;https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTL9IlaaakTewmIvevJH0mR144GE-3V9QfKM8IBRzhVgiOA6yqQHDXpOec&amp;quot;   
## [18] &amp;quot;https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcSS5FOUYkzv2yJqS04ALZUf-1uVOU7CkIKFOdYLnWBoVSlyc7ciLtJqo60&amp;quot;   
## [19] &amp;quot;https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQ1jbAvG16sf5gRa2ygBlDuX3PilS9dvQYSDsshlWwu5GHyQ0of9eW90e53nA&amp;quot;
## [20] &amp;quot;https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTfgFxGMB1iHCLCSV2_NdMi6UQ1CuBwHdmSaFRITCEjDcX2NiSO59-jtj2n&amp;quot;  
## [21] &amp;quot;https://encrypted-tbn1.gstatic.com/images?q=tbn:ANd9GcQ702D4y236w_gsb3hAyl5JZvKnW7YlGYnh-Zi2T-QgxzhIb738U4P3tA&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 결과를 볼 때 추가적인 전처리가 더 필요할 수 있을거라 예상된다.&lt;br /&gt;
예를들어 &amp;quot;http:&amp;quot; 로 시작하는것만 소비해야 정상적인 이미지 파일 다운로드가 가능할 것이다.&lt;br /&gt;
첫번째 링크 /textinputassistant/tia.png 는 루트에서 직접적으로 가져오는 링크 이므로 우리가 접근할 수 있는 이미지가 아니다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;src_href &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;src_href[-&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;download-image-file&quot;&gt;download image file&lt;/h3&gt;
&lt;p&gt;이후의 예제는 20개의 준비된 이미지 파일링크를 반복문을 돌려 자신의 하드로 가져오는 코드이다.&lt;br /&gt;
우선 한개의 파일을 다운로드 하는방법부터 살펴보면&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;download.file&lt;/span&gt;(src_href[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;], &lt;span class=&quot;st&quot;&gt;&amp;quot;./output/test_image1&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위의 코드는 https://encrypted-tbn1.gstatic.com/images?q=tbn:ANd9GcTaailzt78W3ZQh40T90r1Rka4_l_c5GJofA-cljDIemIJBGxoHOUlz-vA 링크의 이미지파일을 워킹디릭토리의 output 폴더에 &amp;quot;test_image1&amp;quot; 라는 파일로 저장시키는 코드이다. &lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이를 이용해서 반복문을 통해 20개 모든 이미지를 다운로드하는 코드를 짜면&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;for(i in src_href %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;length %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;seq){
    &lt;span class=&quot;kw&quot;&gt;download.file&lt;/span&gt;(src_href[i], &lt;span class=&quot;kw&quot;&gt;paste0&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;./output/image_&amp;quot;&lt;/span&gt;, i))
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;output 폴더에 &amp;quot;image_1&amp;quot;, ... , &amp;quot;image_20&amp;quot; 개의 이미지가 잘 저장되어 있는지 확인해보면 되겠다!&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;/assets/Crawling_1.png&quot; /&gt;
&lt;/figure&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;단 여기서 각 외부의 이미지파일 형식이 무엇인지 알 수 없으므로, 로컬로 저장시에 포맷을 지정하지 못하는 문제가 있다.&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Sat, 23 Jul 2016 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2016/07/23/Crawling_image.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2016/07/23/Crawling_image.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>석사논문 감사의 글</title>
        <description>&lt;p&gt;완성된 석사 논문 책자를 받고 나서 상당히 아쉬움이 남는다.&lt;br /&gt;
바로 감사의 글을 논문에 포함하지 않고 빠른 행정처리를 위해 논문을 제출했다는 것이다.&lt;br /&gt;
제출한 논문을 다시 가져와서 감사의 글을 강제로 집어넣을 수도 없는 노릇이다.&lt;br /&gt;
그래서 아쉽지만, 감사의 글을 이곳에 남기고자 한다.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;감사의 글&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;어떠한 계기 때문에 석사과정을 밟기로 각오하고 이 길을 선택했는지 지금 와서 생각해보면 구체화 시키기가 쉽지 않다. 솔직히 말해서 잘 모르겠다. 전반적으로 볼 때 난 자연스럽게 여기까지 오게 되었다.&lt;br /&gt;
모든 것이 이러한 식으로 물 흐르듯 화살 같은 속도의 시간이란 버스에 탑승하여 또 어딘가 모르는 곳에 하차하고, 탑승하는 것을 되풀이하다가 또 한 번 도심 속에 하차했다.&lt;br /&gt;
하지만 분명 대학교를 입학하고 대학원 진학을 희망하던 그때 당시의 선택에 기로에는 여러 가지 사건들과 주변 사람들의 대화 및 조언들이 복합되어 나의 책임하 선택한 나의 길이었다.&lt;br /&gt;
그리고 면밀하게 기억을 돌이켜 보면 볼수록 수많은 작은 파도들이 있었고 부딪힘이 있었다. 이러한 파도들이 지금의 나를 만든 것이라 생각한다.&lt;br /&gt;
감사의 글을 적게 된 이유도 길고 거대했던 여정 사이에 숨겨졌던 파도들을 상기시키기 위함이다.&lt;/p&gt;
&lt;p&gt;나는 어느 시점부터인가 오픈소스에 대한 학문적 열정이 커졌다.&lt;br /&gt;
이런 열정을 느낄 수 있게 해준, 미흡했던 시절 나에게 오픈소스 중 R이란 언어를 직∙간접적으로 처음 소개했던 이석호 지도 교수님께 감사드리고 싶다.&lt;br /&gt;
지금 생각해 보면 교수님은 항상 나도 모르게 제자에게 슬며시 간접적으로 영향력을 행사하는데 특별한 능력을 가지신듯 하다.&lt;/p&gt;
&lt;p&gt;지금도 그렇지만 믿을 수 없을 만큼 많은 사람들이 내가 운영 중인 블로그에 방문하고 지속해서 지지해 주고 있다는 것을 느낀다.&lt;br /&gt;
이러한 관심이 나의 학문적 열정이란 불씨를 꺼트리지 않게 해준 양초와 같았다.&lt;br /&gt;
계속해서 아이디어를 공유하고 조화시킬 수 있는 익명의 많은 분들이 있어 나의 사고방식은 이전보다 확실히 성숙해졌다.&lt;/p&gt;
&lt;p&gt;익명의 분들 중 개인적으로 알게 된 운명적인 분들 역시 감사의 마음을 드리고 싶다.&lt;br /&gt;
서로 직면해서 이야기를 나눈 것은 2번밖에 없지만, 장문의 이메일을 주고받으며 오픈소스뿐만 아니라 컴퓨터에 전반적인 지식과 광범위한 데이터 과학의 세계로 나를 인도해준 고석범 대표님이 지금 많이 생각난다. 정말 감사드리고 싶다.&lt;br /&gt;
R에 대해 아직 만족스러울 정도로 배운것이 아닌 당시 나의 어떤 모습이 마음에 들어서 책을 같이 편찬하자 제의하신지 모르겠으나, 내생에 처음이자 마지막이 될 법한 도서편찬의 기회를 주신 박찬성 실장님께 감사의 마음을 전하고 싶다.&lt;br /&gt;
나에게 또 다른 기회와 새로운 비즈니스 경험을 선사해 주신, 앞으로 계속적으로 감사의 마음이 들 것 같은 박진호 전무님께도 감사의 마음을 표시하고 싶다.&lt;/p&gt;
&lt;p&gt;사실 내 안의 아집은 남들이 일으키는 파도에 대한 방파제이었다.&lt;br /&gt;
이 방파제를 뚫고 나에게 메시지를 주기 위하여 계속해서 파도를 일으켜 준 한국외국어대 통계학과 교수님들과, 직접적으로 도움과 후원을 해준 랩실, 그리고 대학원 동기 및 선후배 분들에 대한 그 고마움을 그 당시 느끼지 못했다.&lt;br /&gt;
나는 상대적으로 보면 확실히 정적인 사람이고 요즘 말로 리액션이 약한 사람이다.&lt;br /&gt;
따라서 리액션 대신 진심 어린 지금의 글을 통해 조금이나마 나의 고마움에 대한 표시를 남기고 전달하고자 한다.&lt;/p&gt;
</description>
        <pubDate>Fri, 01 Jul 2016 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/diary/2016/07/01/Thanks_GS.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/diary/2016/07/01/Thanks_GS.html</guid>
        
        
        <category>Diary</category>
        
      </item>
    
      <item>
        <title>R에서 data.frame 과 data.table 에 대해 join 작업을 이용한 벤치마킹</title>
        <description>&lt;p&gt;R에서 최근에 많이 하는 작업이 있다.&lt;br /&gt;
바로 data.frame 기반으로 데이터를 인아웃풋 한 코드들을 모두 data.table 로 코드 스위칭하는 작업이다.&lt;br /&gt;
data.table 의 빠른처리속도는 이전부터 명성이 자자했지만 게으름으로 인해 고집스럽게 쓰지 않았었다.&lt;br /&gt;
하지만 인내심의 한계에 다다르고 빠른 속도를 직접 체감하고 나서 뒤늦게 도입하기 시작한 것 같다.&lt;/p&gt;
&lt;p&gt;구글링을 통해서도 다양한 data.table 의 showcase 들이 있고, 퍼포먼스를 확인할 수 있는 예제코드를 구하기 쉽다.&lt;br /&gt;
나도 그러한 예제코드를 만들어 보았고 공유해 보고자 한다.&lt;br /&gt;
나는 data.frame 과 data.table 에 대해서 병합작업을 이용해 벤치마킹 하는 코드 프로그램을 아래와 같이 작성해 보았다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(data.table)
&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(dplyr)
&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(rbenchmark)

N=&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;^&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;

df &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;data.frame&lt;/span&gt;(
    &lt;span class=&quot;dt&quot;&gt;ID =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;seq&lt;/span&gt;(N),
    &lt;span class=&quot;dt&quot;&gt;group =&lt;/span&gt; LETTERS %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;sample&lt;/span&gt;(N, T),
    &lt;span class=&quot;dt&quot;&gt;Var1 =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;rnorm&lt;/span&gt;(N, &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;^&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;),
    &lt;span class=&quot;dt&quot;&gt;Var2 =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;rpois&lt;/span&gt;(N, &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;)
    ) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;tbl_df
df2 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;data.frame&lt;/span&gt;(
    &lt;span class=&quot;dt&quot;&gt;ID =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;seq&lt;/span&gt;(N) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;rev,
    &lt;span class=&quot;dt&quot;&gt;Var3 =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;rnorm&lt;/span&gt;(N, -&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;^&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)
    ) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;sample_n&lt;/span&gt;(N*.&lt;span class=&quot;dv&quot;&gt;9&lt;/span&gt;) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;tbl_df

dt &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;data.table&lt;/span&gt;(df); &lt;span class=&quot;kw&quot;&gt;setkey&lt;/span&gt;(dt, ID)
dt2 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;data.table&lt;/span&gt;(df2); &lt;span class=&quot;kw&quot;&gt;setkey&lt;/span&gt;(dt2, ID)

&lt;span class=&quot;kw&quot;&gt;benchmark&lt;/span&gt;(
    join_res_df &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;left_join&lt;/span&gt;(df, df2),
    join_res_dt &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;left_join&lt;/span&gt;(dt, dt2), &lt;span class=&quot;dt&quot;&gt;replications =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt;
)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위의 코드를 간략히 설명해 보면&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;예제로-사용할-data.frame-data.table-객체-만들기&quot;&gt;예제로 사용할 data.frame, data.table 객체 만들기&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(data.table)
&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(dplyr)
&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(rbenchmark)

N=&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;^&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;

df &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;data.frame&lt;/span&gt;(
    &lt;span class=&quot;dt&quot;&gt;ID =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;seq&lt;/span&gt;(N),
    &lt;span class=&quot;dt&quot;&gt;group =&lt;/span&gt; LETTERS %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;sample&lt;/span&gt;(N, T),
    &lt;span class=&quot;dt&quot;&gt;Var1 =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;rnorm&lt;/span&gt;(N, &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;^&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;),
    &lt;span class=&quot;dt&quot;&gt;Var2 =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;rpois&lt;/span&gt;(N, &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;)
    ) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;tbl_df
df2 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;data.frame&lt;/span&gt;(
    &lt;span class=&quot;dt&quot;&gt;ID =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;seq&lt;/span&gt;(N) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;rev,
    &lt;span class=&quot;dt&quot;&gt;Var3 =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;rnorm&lt;/span&gt;(N, -&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;^&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)
    ) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;sample_n&lt;/span&gt;(N*.&lt;span class=&quot;dv&quot;&gt;9&lt;/span&gt;) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;tbl_df

dt &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;data.table&lt;/span&gt;(df); &lt;span class=&quot;kw&quot;&gt;setkey&lt;/span&gt;(dt, ID)
dt2 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;data.table&lt;/span&gt;(df2); &lt;span class=&quot;kw&quot;&gt;setkey&lt;/span&gt;(dt2, ID)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1,000,000 개의 데이터셋과 이중에서 90% 인 900,000 개의 새로운 변수를 가진 데이터셋을 서로 join 하기 위해 (의미가 별로 없는) 데이터프레임 &lt;code&gt;df&lt;/code&gt;, &lt;code&gt;df2&lt;/code&gt; 객체를 만드는 코드이다.&lt;br /&gt;
join 으로 붙여져야 하는 대상은 &amp;quot;Var3&amp;quot; 으로 명칭된 변수 &lt;span class=&quot;math inline&quot;&gt;−10&lt;/span&gt; 을 평균으로 하는 정규분포 난수이다.&lt;/p&gt;
&lt;p&gt;이후 class 만 data.table 로 바꾼 &lt;code&gt;dt&lt;/code&gt;, &lt;code&gt;dt2&lt;/code&gt; 동일내용의 객체를 준비했다.&lt;br /&gt;
data.table 에선 key variable 를 사전에 지정할 수 있는데 바로 data.table 의 &lt;code&gt;setkey()&lt;/code&gt; 함수를 통해 가능하다.&lt;br /&gt;
key 변수는 공통의 &amp;quot;ID&amp;quot; 변수를 선택하였다.&lt;br /&gt;
&lt;code&gt;setkey()&lt;/code&gt; 함수를 이용한 이와같은 key 변수 지정은 추후 join 작업의 편의성을 증대시켜주고 처리속도의 작은 개선을 기대할 수 있게 해준다.&lt;br /&gt;
무엇보다 현업시 key variable 에 대한 상기를 지속적으로 해야하는 상황에서 이렇게 명시해 줄 수 있는 도구가 있는것은 긍정적이라고 할 수 있다.&lt;br /&gt;
key variable 세팅이 제대로 되었는지가 궁금하다면 &lt;code&gt;tables()&lt;/code&gt; 함수를 통해 눈으로 확인 할 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;tables&lt;/span&gt;()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##      NAME      NROW NCOL MB COLS               KEY
## [1,] dt   1,000,000    4 20 ID,group,Var1,Var2 ID 
## [2,] dt2    900,000    2 11 ID,Var3            ID 
## Total: 31MB&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;출력결과의 맨 우측 Key 항목에 &amp;quot;ID&amp;quot; 가 있는것을 보아 제대로 세팅이 된 것을 볼 수 있다.&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;join&quot;&gt;Join&lt;/h2&gt;
&lt;p&gt;본격적으로 병합(Join)을 시작한다.&lt;br /&gt;
join 방법은 무난한 left join 을 실시하기 위해 dplyr package 에 있는 &lt;code&gt;left_join()&lt;/code&gt; 함수를 이용 했다.&lt;/p&gt;
&lt;p&gt;data.frame 에 대한 join 과&lt;br /&gt;
data.table 에 대한 join 수행시간을 간편하게 측정하기위해 rbenchmark package 의 &lt;code&gt;benchmark()&lt;/code&gt; 함수를 이용했다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;benchmark&lt;/span&gt;(
    join_res_df &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;left_join&lt;/span&gt;(df, df2, &lt;span class=&quot;dt&quot;&gt;by=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&amp;quot;ID&amp;quot;&lt;/span&gt;),
    join_res_dt &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;left_join&lt;/span&gt;(dt, dt2, &lt;span class=&quot;dt&quot;&gt;by=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&amp;quot;ID&amp;quot;&lt;/span&gt;), &lt;span class=&quot;dt&quot;&gt;replications =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt;
)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##                                           test replications elapsed
## 1 join_res_df &amp;lt;- left_join(df, df2, by = &amp;quot;ID&amp;quot;)           20  19.608
## 2 join_res_dt &amp;lt;- left_join(dt, dt2, by = &amp;quot;ID&amp;quot;)           20   7.667
##   relative user.self sys.self user.child sys.child
## 1    2.557    18.395    1.114          0         0
## 2    1.000     6.782    0.848          0         0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위의 코드는 &lt;code&gt;join_res_df &amp;lt;- left_join(df, df2, by=&amp;quot;ID&amp;quot;)&lt;/code&gt; 와 &lt;code&gt;join_res_dt &amp;lt;- left_join(dt, dt2, by=&amp;quot;ID&amp;quot;)&lt;/code&gt; 코드를 의도적으로 20번 반복 수행해 걸린 시간을 측정해주게 된다.&lt;br /&gt;
현 예제에 대한 시간측정결과 elapsed 항목을 볼 때 data.table 에 대한 join 작업의 수행속도가 data.frame 보다 약 10배 빠른 것을 볼 수 있다!&lt;/p&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;&lt;code&gt;setkey()&lt;/code&gt; 함수를 통해 key variable 를 세팅하지 않았던 단계에 &lt;code&gt;tables()&lt;/code&gt; 를 실행시키면 Key 항목은 빈칸이었을 것 이다.&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Mon, 27 Jun 2016 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2016/06/27/Benchmarking_DF_vs_DT.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2016/06/27/Benchmarking_DF_vs_DT.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>R에서 S3 최소재현예제</title>
        <description>&lt;blockquote&gt;
&lt;p&gt;Hands-On Programming with R (Garrett Grolemund)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;책에서 설명된 S3 에 의하면&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;제너릭 함수 (generic function)&lt;/li&gt;
&lt;li&gt;메서드 (method)&lt;/li&gt;
&lt;li&gt;클래스 (class)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;3개의 기반 디스패치를 가리켜 S3라고 한다.&lt;/p&gt;
&lt;p&gt;하지만 저런용어가 쉽게 와닿지 않는 상태에서 이해하기란 쉽지 않았다.&lt;br /&gt;
때문에 R의 S3 가 무엇인지 빠르게 체감할 수 있는 나만의 아주 간단한 self 코드를 만들어 보았다.&lt;br /&gt;
최소재현예제 이므로 코드실행에 5분만 투자한다면 큰 체감을 얻을 수 있을것으로 예상된다.&lt;br /&gt;
어떠한 부가설명도 없는 코드를 아래와 같이 공유하고자 한다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;generic-function&quot;&gt;Generic function&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;lovetoken &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;function(x){
  &lt;span class=&quot;kw&quot;&gt;UseMethod&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;lovetoken&amp;quot;&lt;/span&gt;)
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;method&quot;&gt;Method&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;lovetoken.default &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;function(x){
  x
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;lovetoken.class1 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;function(x){
  &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;sum&lt;/span&gt;(x), &lt;span class=&quot;kw&quot;&gt;mean&lt;/span&gt;(x))
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;lovetoken.class2 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;function(x){
  &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt;(x), &lt;span class=&quot;kw&quot;&gt;sd&lt;/span&gt;(x))
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;class&quot;&gt;Class&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;test &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;lovetoken&lt;/span&gt;(test) &lt;span class=&quot;co&quot;&gt;# `lovetoken.default(test)` 를 실행하는 것과 동일&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##  [1]  0  1  2  3  4  5  6  7  8  9 10&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt;(test) &amp;lt;-&lt;span class=&quot;st&quot;&gt; &amp;quot;class1&amp;quot;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;lovetoken&lt;/span&gt;(test) &lt;span class=&quot;co&quot;&gt;# `lovetoken.class1(test)` 를 실행하는 것과 동일&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] 55  5&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt;(test) &amp;lt;-&lt;span class=&quot;st&quot;&gt; &amp;quot;class2&amp;quot;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;lovetoken&lt;/span&gt;(test) &lt;span class=&quot;co&quot;&gt;# `lovetoken.class2(test)` 를 실행하는 것과 동일&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] 11.000000  3.316625&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt;(test) &amp;lt;-&lt;span class=&quot;st&quot;&gt; &amp;quot;unknown&amp;quot;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;lovetoken&lt;/span&gt;(test) &lt;span class=&quot;co&quot;&gt;# `lovetoken.default(test)` 를 실행하는 것과 동일&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##  [1]  0  1  2  3  4  5  6  7  8  9 10
## attr(,&amp;quot;class&amp;quot;)
## [1] &amp;quot;unknown&amp;quot;&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sun, 12 Jun 2016 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2016/06/12/S3.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2016/06/12/S3.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>R에서 구분구적법 적분과정 시뮬레이션 및 integrate() 함수 알아보기</title>
        <description>&lt;p&gt;내가 고등학교 이과생으로서 지낸 2학년 기억을 돌이켜 보면 적분의 방법은 이렇게 배웠던 것 같다.&lt;br /&gt;
넓이 계산이 쉬운 사각형을 함수와 x축 사이에 강제로 끼워 맞춤으로써 넓이를 근사시키는 과정을 밟았고,&lt;br /&gt;
특히 x축 기준 사각형을 등간격으로 잘게 잘게 쪼개는 과정을 무한대로 취함으로써 적분 값을 완벽히 근사시키는 법으로 구한다고 말이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(ggplot2)

fun &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;function(x) x^&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; -&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;*x^&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;13&lt;/span&gt;*x +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt;

fun_forarea &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;function(x){
    res &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;fun&lt;/span&gt;(x)
    res[ x&amp;lt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; |&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;x&amp;gt;&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; ] &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;NA&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;(res)
}

P &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;ggplot&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;data.frame&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;x =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(-&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;)), &lt;span class=&quot;kw&quot;&gt;aes&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;x =&lt;/span&gt; x)) +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;stat_function&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;fun =&lt;/span&gt; fun) +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;stat_function&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;fun =&lt;/span&gt; fun_forarea, &lt;span class=&quot;dt&quot;&gt;geom =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;area&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;fill =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;#3E5CFF&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;alpha =&lt;/span&gt; .&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;geom_hline&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;yintercept =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;theme_bw&lt;/span&gt;()

P&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;br&gt;&lt;img src=&quot;/assets/integrate-1.png&quot; /&gt;&lt;br&gt;
&lt;/center&gt;
&lt;center&gt;
&lt;br&gt;&lt;video   controls loop&gt;&lt;source src=&quot;/assets/integrate_ani-.webm&quot; /&gt;
&lt;p&gt;
video of chunk integrate_ani
&lt;/p&gt;
&lt;/video&gt;
&lt;br&gt;
&lt;/center&gt;
&lt;p&gt;이러한 형태로 넓이를 구하기 힘든 곡선모형의 넓이를 구하기 위해&lt;br /&gt;
충분히 작은 n개의 기본도형으로 나누어 끼워 맞춘 후 넓이를 구한 것을 &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;S&lt;/em&gt;&lt;sub&gt;&lt;em&gt;n&lt;/em&gt;&lt;/sub&gt;&lt;/span&gt; 이라 할 때&lt;br /&gt;
기본도형을 더 작은 단위로 하여 &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;n&lt;/em&gt;&lt;/span&gt; 을 극한으로 보냄으로써 넓이를 근사시키는 것을 &lt;strong&gt;구분구적법&lt;/strong&gt;이라 한다.&lt;br /&gt;
즉 구분구적법은 &lt;span class=&quot;math inline&quot;&gt;lim&lt;sub&gt;&lt;em&gt;n&lt;/em&gt; → ∞&lt;/sub&gt;&lt;em&gt;S&lt;/em&gt;&lt;sub&gt;&lt;em&gt;n&lt;/em&gt;&lt;/sub&gt;&lt;/span&gt; 을 계산하는 과정이다.&lt;/p&gt;
&lt;p&gt;컴퓨터는 미분이든 적분이든 사람이 손으로 풀듯이 드라마틱하게 계산할 수 있는 능력이 없을 것이다.&lt;br /&gt;
구분구적법에 기반한 프로그래밍적인 계산을 통해 적분 값을 계산하게 될 것인데&lt;br /&gt;
R에서는 &lt;code&gt;intergrate()&lt;/code&gt; 함수를 이용하여 적분 값을 계산할 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;integrate&lt;/span&gt;(fun, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## 87.08333 with absolute error &amp;lt; 9.7e-13&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;구분구적법은 기본도형을 최대한 잘게 쪼개는 과정이 필요한데&lt;br /&gt;
이를 무한히 반복하는 것을 컴퓨터에게 시킨다면&lt;br /&gt;
stop 조건이 없을 경우 멈추지 않을것이다.&lt;br /&gt;
그렇다고 n을 무한으로 보내지 못하고 중간에 stop 하게 되면 적분값의 오차는 반드시 생길수 밖에 없을것이다.&lt;br /&gt;
추정하건대 &lt;code&gt;integrate()&lt;/code&gt; 함수를 실행시키고 출력되는 &amp;quot;absolute error&amp;quot; 문구가 출력된 이유가 이것 때문일 것이라 생각한다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;integrate()&lt;/code&gt; 함수 사용방법은 간편하다.&lt;br /&gt;
계산을 하고 싶은 함수를 첫 번째 인자에 넘겨주고,&lt;br /&gt;
폐구간에 대한 정보를 &lt;code&gt;lower&lt;/code&gt;, &lt;code&gt;upper&lt;/code&gt; 인자에 넘겨주기만 하면 적분 값을 계산해 준다.&lt;/p&gt;
</description>
        <pubDate>Mon, 06 Jun 2016 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2016/06/06/integate_function.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2016/06/06/integate_function.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>R에서 중심극한의 정리를 animation plotting 을 통해 시뮬레이션 하기</title>
        <description>&lt;p&gt;통계 비전공자에게 중심극한의 정리를 설명해야 했던 적이 있었는데,&lt;br /&gt;
심오한 이론들을 증명하며 설명하느니 한번 보여주는 것이 더 큰 공감을 얻게될 것 같아 animation plot 을 준비한적이 있다.&lt;br /&gt;
본 포스팅 글은 R markdown 포맷에서 코드청크옵션 &lt;code&gt;fig.show = &amp;quot;animate&amp;quot;&lt;/code&gt; 을 통해 animation plot 을 준비하는 것이 가능하다는 것을 소개하고 그 예시로 중심극한정리 시뮬레이션을 통해 설명할 것이다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;중심극한정리-central-limit-theorem-에-대해서&quot;&gt;중심극한정리 (Central Limit Theorem) 에 대해서&lt;/h2&gt;
&lt;p&gt;중심극한정리는 표본의 크기가 커짐에 따라 표본평균의 분포가 점점 정규분포로 닮아(근사) 짐을 의미하는 이론이다.&lt;br /&gt;
그리고 표본은 어떠한 분포 타입에 나온 것이더라 하더라도 상관없이 중심극한정리에 해당되는것을 특징으로 한다.&lt;br /&gt;
여기서 헷갈리는 것이 있을 수 있는데, 표본평균은 단하나의 값으로 분포가 될 수 있느냐 라는 질문이 생길 수 있다.&lt;br /&gt;
이 궁금증은 표본 자체가 확률변수라는 것으로써 이해할 수 있다.&lt;br /&gt;
표본 자체가 확률변수이므로 이를 종합하여 평균한 값 하나일지라도 분명 확률변수이며 이는 분포로써 설명이 가능하다.&lt;br /&gt;
하지만 시뮬레이션에서 사용할 표본평균은 단 한 개 가지고는 분포를 시각적으로 볼 수 없는 노릇이다.&lt;br /&gt;
따라서 표본평균들을 여러 개 발생시킬 것이다.&lt;/p&gt;
&lt;p&gt;정리하면 시뮬레이션 시 특정 분포에 대해 많은 표본을 뽑은 후 표본평균계산 후 이를 반복해서 다양한 표본평균들을 준비해 히스토그램으로 분포를 확인할 것이다.&lt;br /&gt;
또한 표본의 크기가 커짐에 따라 정규분포로 닮아진다는 것을 점근적으로 보여주는 것이 시뮬레이션의 큰 의미라고 볼 수 있다.&lt;/p&gt;
&lt;p&gt;우선 현 시뮬레이션에선&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;특정분포를 포아송분포 &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;X&lt;/em&gt; ∼ &lt;em&gt;P&lt;/em&gt;&lt;em&gt;o&lt;/em&gt;&lt;em&gt;i&lt;/em&gt;&lt;em&gt;s&lt;/em&gt;&lt;em&gt;s&lt;/em&gt;&lt;em&gt;o&lt;/em&gt;&lt;em&gt;n&lt;/em&gt;(&lt;em&gt;λ&lt;/em&gt; = 10)&lt;/span&gt; 으로&lt;/li&gt;
&lt;li&gt;표본개수는 n=500 으로 통일하고&lt;/li&gt;
&lt;li&gt;표본평균들을 1,000개 준비하기 위해 위 과정을 1000번 반복&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;할 것이다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;단편-시뮬레이션&quot;&gt;단편 시뮬레이션&lt;/h2&gt;
&lt;p&gt;위에서 설명한 시뮬레이션은 아래코드를 통해 확인 가능하다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;res &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;replicate&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1000&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;expr=&lt;/span&gt;{
    n &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;500&lt;/span&gt;
    sample &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;rpois&lt;/span&gt;(n, &lt;span class=&quot;dt&quot;&gt;lambda =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;mean&lt;/span&gt;(sample)
})&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위 코드를 통해 1000개의 표본평균들이 &lt;code&gt;res&lt;/code&gt; 객체에 담겨있게된다.&lt;br /&gt;
정규분포로 근사되었는지 분포를 확인하는건 2가지 방법을 통해 해보고자 한다.&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;히스토그램과 밀도추정선을 덧그린 plot&lt;/li&gt;
&lt;li&gt;Quantile-Quantile Plots&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;hist&lt;/span&gt;(res, &lt;span class=&quot;dt&quot;&gt;freq =&lt;/span&gt; F)
&lt;span class=&quot;kw&quot;&gt;lines&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;density&lt;/span&gt;(res), &lt;span class=&quot;dt&quot;&gt;lty =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;col =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;blue&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/CLT1-1.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;1번에 해당되는 히스토그램이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;qqnorm&lt;/span&gt;(res)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/CLT2-1.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;2번에 해당하는 소위 QQplot 이다.&lt;/p&gt;
&lt;p&gt;분명 결과물을 통해선 포아송분포에서 뽑은 표본들의 평균의 분포가 정규분포에 근사하는 것을 체감할 수는 있다.&lt;br /&gt;
하지만 나는 이것보다 분포의 개수가 많으면 많아질수록 정규분포의 닮아짐이 높아진다는 점근적근사를 시각적으로 보여주고 싶은 것이었다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;rmarkdown-의-코드청크옵션-fig.show-animate-에-대해서&quot;&gt;Rmarkdown 의 코드청크옵션 &lt;code&gt;fig.show = &amp;quot;animate&amp;quot;&lt;/code&gt; 에 대해서&lt;/h2&gt;
&lt;p&gt;필자는 Rmarkdown 포맷을 자주 사용하여 내 지식을 전달하는 편인데 데이터분석과 융화된 글을 쓰기에 거리낌 없는 도구로 굉장한 공감을 얻었기 때문이다.&lt;br /&gt;
특히 &lt;code&gt;fig.show = &amp;quot;animate&amp;quot;&lt;/code&gt; 와 같은 코드청크 옵션은 데이터의 변질에 따른 plot output 의 변화를 보여주기에 간편한 기능을 제공해서 적극적으로 애용 중이다.&lt;/p&gt;
&lt;p&gt;위의 예시를 이어서 설명하자면 단편적인 시뮬레이션을 통해 정규분포에 근사하는 것을 체감시켰지만,&lt;br /&gt;
이보다 더 중요한 것을 설명하기 위해 표본개수 즉 표본평균을 계산한 반복회수가 증가함으로써 일어나는 정규근사 정도를 animation plotting 통해 보여줄 것이다.&lt;/p&gt;
&lt;p&gt;아래처럼 말이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(numbers) &lt;span class=&quot;co&quot;&gt;# for fibonacci function&lt;/span&gt;

ani_N &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;()
for(i in &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt;) ani_N[i&lt;span class=&quot;dv&quot;&gt;-4&lt;/span&gt;] &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;fibonacci&lt;/span&gt;(i)
ani_N&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##  [1]      5      8     13     21     34     55     89    144    233    377
## [11]    610    987   1597   2584   4181   6765  10946  17711  28657  46368
## [21]  75025 121393 196418 317811 514229 832040&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;for(N in ani_N){
    res &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;replicate&lt;/span&gt;(N, &lt;span class=&quot;dt&quot;&gt;expr=&lt;/span&gt;{
        n &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;500&lt;/span&gt;
        sample &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;rpois&lt;/span&gt;(n, &lt;span class=&quot;dt&quot;&gt;lambda =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;)
        &lt;span class=&quot;kw&quot;&gt;mean&lt;/span&gt;(sample)
    })
    &lt;span class=&quot;kw&quot;&gt;hist&lt;/span&gt;(res, &lt;span class=&quot;dt&quot;&gt;freq =&lt;/span&gt; F, &lt;span class=&quot;dt&quot;&gt;ylim =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;), &lt;span class=&quot;dt&quot;&gt;xlim =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;9&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;11&lt;/span&gt;))
    &lt;span class=&quot;kw&quot;&gt;lines&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;density&lt;/span&gt;(res), &lt;span class=&quot;dt&quot;&gt;lty =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;col =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;blue&amp;quot;&lt;/span&gt;)
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;video   controls loop&gt;
&lt;source src=&quot;/assets/CLT1_ani-.webm&quot; /&gt;
&lt;p&gt;
video of chunk CLT1_ani
&lt;/p&gt;
&lt;/video&gt;
&lt;/center&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;for(N in ani_N){
    res &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;replicate&lt;/span&gt;(N, &lt;span class=&quot;dt&quot;&gt;expr=&lt;/span&gt;{
        n &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;500&lt;/span&gt;
        sample &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;rpois&lt;/span&gt;(n, &lt;span class=&quot;dt&quot;&gt;lambda =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;)
        &lt;span class=&quot;kw&quot;&gt;mean&lt;/span&gt;(sample)
    })
    &lt;span class=&quot;kw&quot;&gt;qqnorm&lt;/span&gt;(res, &lt;span class=&quot;dt&quot;&gt;xlim =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(-&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;), &lt;span class=&quot;dt&quot;&gt;ylim =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;9&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;11&lt;/span&gt;))
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;video   controls loop&gt;
&lt;source src=&quot;/assets/CLT2_ani-.webm&quot; /&gt;
&lt;p&gt;
video of chunk CLT2_ani
&lt;/p&gt;
&lt;/video&gt;
&lt;/center&gt;
&lt;p&gt;위의 B장에서 수행했던 코드의 본체는 부수적인 차이만 존재할 뿐 거의 흡사하다.&lt;br /&gt;
차이점은 시뮬레이션 본체코드를 for 문을 통해 &lt;code&gt;ani_N&lt;/code&gt; 의 피보나치수열로 반복회수를 조정한것이며,&lt;br /&gt;
시각화 코드인 &lt;code&gt;hist()&lt;/code&gt;, &lt;code&gt;qqnorm()&lt;/code&gt; 함수에 &lt;code&gt;xlim&lt;/code&gt;, &lt;code&gt;ylim&lt;/code&gt; 인자값들을 부여해 범위를 고정시켰다는 차이가 있다.&lt;br /&gt;
그리고 본장에서 설명하고자 하는 차이점은 사실 R코드가 아닌 Rmarkdown 코드청크옵션에 내막이 있다.&lt;br /&gt;
verbatim 모드로 Rmarkdown 코드청크 전체를 보여주면 아래와 같다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;co&quot;&gt;# ```{r fig.show = &amp;quot;animate&amp;quot;, interval = .4}&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# for(N in ani_N){&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#   res &amp;lt;- replicate(N, expr={&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#       n &amp;lt;- 500&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#       sample &amp;lt;- rpois(n, lambda = 10)&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#       mean(sample)&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#   })&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#   hist(res, freq = F, ylim = c(0, 7), xlim = c(9, 11))&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#   lines(density(res), lty=2, col=&amp;quot;blue&amp;quot;)&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# }&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# ```&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;사실 코드청크에 &lt;code&gt;fig.show = &amp;quot;animate&amp;quot;, interval = .4&lt;/code&gt; 와 같은 옵션이 존재하지 않는다면&lt;br /&gt;
&lt;code&gt;ani_N&lt;/code&gt; 의 마지막 값에 대한 중심극한 시뮬레이션 histogram 결과만 나올것이다.&lt;br /&gt;
실제 수행된 코드는 &lt;code&gt;ani_N&lt;/code&gt; 에 담겨있는 수열들의 값대로 히스토그램을 그리겠지만 결국 출력되는건 마지막 값에 해당되는 단편 시뮬레이션 plot output 이다.&lt;/p&gt;
&lt;p&gt;하지만 코드청크에 &lt;code&gt;fig.show = &amp;quot;animate&amp;quot;&lt;/code&gt; 를 부여하면 중간중간에 출력되는 plot output 을 임시로 모두 저장하게된다.&lt;br /&gt;
이후 코드청크의 &lt;code&gt;interval&lt;/code&gt; 옵션값만큼의 간격으로 저장된 plot output 프레임들을 순차적으로 인코딩하여 영상을 만든다!&lt;br /&gt;
지금은 interval 값을 0.4초로 지정했는데 프레임 넘김을 더 빠르게 하고싶은 경우 이값을 작게 조정하여 희망하는 속도로 맞출 수 있다.&lt;br /&gt;
그리하여 피보나치수열 대로 표본이 증가하면 증가할수록 정규분포로 근사되는것을 시각적으로 볼 수 있게 되는 것이다.&lt;/p&gt;
&lt;p&gt;QQplot animation 도 마찬가지 형태이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;co&quot;&gt;# ```{r fig.show = &amp;quot;animate&amp;quot;, interval = .4}&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# for(N in ani_N){&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#   res &amp;lt;- replicate(N, expr={&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#       n &amp;lt;- 500&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#       sample &amp;lt;- rpois(n, lambda = 10)&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#       mean(sample)&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#   })&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#   qqnorm(res, xlim = c(-4, 4), ylim = c(9, 11))&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# }&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# ```&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;요구사항&quot;&gt;요구사항&lt;/h2&gt;
&lt;p&gt;단 이렇게 영상으로 인코딩하는 작업을 하기 위해서 운영체계별로 요구하는 플러그인이 다를 수 있다.&lt;br /&gt;
필자는 OSX 에서 이 글을 작성한 것이며 &lt;a href=&quot;https://www.ffmpeg.org/&quot;&gt;ffmpeg&lt;/a&gt; 설치가 요구되었었다.&lt;/p&gt;
&lt;p&gt;그리고 이것이 요구사항일지는 모르겠지만 코드수행시간이란 비용 이외에 animation plot 영상을 인코딩하는 시간 역시 필요하다.&lt;br /&gt;
위의 예제처럼 간단한 수준의 짧은 영상을 만드는 것은 인코딩시간이 조금 걸리지만,&lt;br /&gt;
그렇지 않으면 많은 인내심이 요구될 수 있다.&lt;/p&gt;
</description>
        <pubDate>Thu, 26 May 2016 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/data_visualization/2016/05/26/CLT.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/data_visualization/2016/05/26/CLT.html</guid>
        
        
        <category>R</category>
        
        <category>Data_Visualization</category>
        
      </item>
    
      <item>
        <title>R에서 수익률 구해보며 lag(), diff() 함수 알아보기</title>
        <description>&lt;p&gt;시계열 데이터의 수익률을 계산하는 일들이 많아지면서&lt;br /&gt;
복잡한 모듈들을 만들 때 아래의 함수들과 패키지가 얼마나 유용한지 몰랐었다.&lt;/p&gt;
&lt;p&gt;오늘 정리해보고자 하는 함수는 3가지이며, 부가적으로 시계열 데이터셋에 날짜의 전처리 부담을 줄여주는 xts package 를 조금씩 이용해보려 한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(xts)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;예제-데이터-만들기&quot;&gt;예제 데이터 만들기&lt;/h2&gt;
&lt;p&gt;오늘 날짜를 기준으로 약 한 달 전 까지의 코스닥 지수를 예제 데이터로 이용해 보고자 한다. (본 포스팅 글의 오늘 날짜는 스크립트를 작성한 기준 날짜를 기준으로 한다)&lt;br /&gt;
R에서는 특정 주가지수를 자동으로 불러올 수 있는 유용한 패키지가 있는데 바로 quantmod package이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(quantmod)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;quantmod package는 앞서 말한 xts package와 종속관계 이므로 quantmod package를 로드하면 같이 함께 로드된다. (zoo package 도 마찬가지 이다.)&lt;br /&gt;
여하튼 KOSPI 지수를 받기 위한 코드는 아래와 같다. &lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;today &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;Sys.Date&lt;/span&gt;()
kq &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;getSymbols&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;^kq11&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;from =&lt;/span&gt; today&lt;span class=&quot;dv&quot;&gt;-30&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;to =&lt;/span&gt; today, &lt;span class=&quot;dt&quot;&gt;auto.assign =&lt;/span&gt; F)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##     As of 0.4-0, &amp;#39;getSymbols&amp;#39; uses env=parent.frame() and
##  auto.assign=TRUE by default.
## 
##  This  behavior  will be  phased out in 0.5-0  when the call  will
##  default to use auto.assign=FALSE. getOption(&amp;quot;getSymbols.env&amp;quot;) and 
##  getOptions(&amp;quot;getSymbols.auto.assign&amp;quot;) are now checked for alternate defaults
## 
##  This message is shown once per session and may be disabled by setting 
##  options(&amp;quot;getSymbols.warning4.0&amp;quot;=FALSE). See ?getSymbols for more details.&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;kq; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt;(kq)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##            KQ11.Open KQ11.High KQ11.Low KQ11.Close KQ11.Volume
## 2016-04-18    695.78    695.98   693.00     695.34      706800
## 2016-04-19    697.31    701.80   696.22     701.68      684100
## 2016-04-20    703.55    704.44   699.85     699.86      737300
## 2016-04-21    702.21    702.32   698.39     701.62      834100
## 2016-04-22    702.90    703.89   700.98     703.05      702700
## 2016-04-25    705.37    705.44   702.42     703.70      700200
## 2016-04-26    705.51    705.51   700.76     702.06      778200
## 2016-04-27    704.42    704.59   699.41     699.52      757000
## 2016-04-28    702.04    703.95   699.68     699.70      665300
## 2016-04-29    699.89    700.14   695.82     699.77      645800
## 2016-05-02    700.43    700.74   690.27     690.27      681200
## 2016-05-03    693.67    699.24   693.67     698.66      819100
## 2016-05-04    698.02    698.30   693.25     694.17      826600
## 2016-05-09    696.66    697.14   690.85     691.82      630400
## 2016-05-10    693.47    700.53   693.44     700.23      570000
## 2016-05-11    704.32    704.53   701.29     703.94      637900
## 2016-05-12    702.46    706.49   699.87     705.04      614200
## 2016-05-13    705.85    705.92   703.65     704.37      617600
## 2016-05-16    705.03    705.04   701.25     701.46      660200
## 2016-05-17    703.08    703.24   693.07     695.95      712200
##            KQ11.Adjusted
## 2016-04-18        695.34
## 2016-04-19        701.68
## 2016-04-20        699.86
## 2016-04-21        701.62
## 2016-04-22        703.05
## 2016-04-25        703.70
## 2016-04-26        702.06
## 2016-04-27        699.52
## 2016-04-28        699.70
## 2016-04-29        699.77
## 2016-05-02        690.27
## 2016-05-03        698.66
## 2016-05-04        694.17
## 2016-05-09        691.82
## 2016-05-10        700.23
## 2016-05-11        703.94
## 2016-05-12        705.04
## 2016-05-13        704.37
## 2016-05-16        701.46
## 2016-05-17        695.95&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;xts&amp;quot; &amp;quot;zoo&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;다양한 메시지와 함께 우리가 보고 싶은 결과물을 xts class 객체로 반환한다.&lt;br /&gt;
&lt;code&gt;getSymbols()&lt;/code&gt; 함수의 쓰임 법에 대해서 간략히 설명하자면 조회하고자 하는 주가 심볼 문자열을 첫 번째 인자값으로 넣고 &lt;code&gt;from&lt;/code&gt;, &lt;code&gt;to&lt;/code&gt; 인자에 조회 날짜에 대한 기간 정보를 넣어줌으로써 활용이 가능하다.&lt;br /&gt;
예제데이터로 사용될 우리가 선택한 코스닥 심볼은 &#39;^kq11&#39; 이다.&lt;br /&gt;
만약 다른 것을 조회하고 싶다면 해당되는 심볼을 찾은 후 기입하면 된다. (ex. 코스피200지수의 경우 &#39;^ks11&#39;)&lt;/p&gt;
&lt;p&gt;반환된 결과물을 보면 open, high, low, close, volume, adjusted 6개의 상황별 지수가 있는데 종가지수인 close 만 관심의 대상이라 가정하고 subset 을 추출한 데이터 &lt;code&gt;data&lt;/code&gt; 를 최종 예제데이터로 삼겠다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;data &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;kq[,&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;일일-수익률-계산하기&quot;&gt;일일 수익률 계산하기&lt;/h2&gt;
&lt;p&gt;예제데이터를 이용하여 일일 수익률을 계산해 보겠다.&lt;br /&gt;
예를 들어 2016년 4월 19일의 수익률을 계산하기 위해선 해당 시차 지수 701.68 을 직전날시차 지수 695.34 로 나눠 준 후 1을 빼면 된다.&lt;br /&gt;
이것을 모든 날에 대해 일괄적으로 행하여야 한다.&lt;br /&gt;
이를 간편하게 계산하기 위해 &lt;code&gt;lag()&lt;/code&gt; 함수가 유용할 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;data&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##            KQ11.Close
## 2016-04-18     695.34
## 2016-04-19     701.68
## 2016-04-20     699.86
## 2016-04-21     701.62
## 2016-04-22     703.05
## 2016-04-25     703.70
## 2016-04-26     702.06
## 2016-04-27     699.52
## 2016-04-28     699.70
## 2016-04-29     699.77
## 2016-05-02     690.27
## 2016-05-03     698.66
## 2016-05-04     694.17
## 2016-05-09     691.82
## 2016-05-10     700.23
## 2016-05-11     703.94
## 2016-05-12     705.04
## 2016-05-13     704.37
## 2016-05-16     701.46
## 2016-05-17     695.95&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;lag&lt;/span&gt;(data)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##            KQ11.Close
## 2016-04-18         NA
## 2016-04-19     695.34
## 2016-04-20     701.68
## 2016-04-21     699.86
## 2016-04-22     701.62
## 2016-04-25     703.05
## 2016-04-26     703.70
## 2016-04-27     702.06
## 2016-04-28     699.52
## 2016-04-29     699.70
## 2016-05-02     699.77
## 2016-05-03     690.27
## 2016-05-04     698.66
## 2016-05-09     694.17
## 2016-05-10     691.82
## 2016-05-11     700.23
## 2016-05-12     703.94
## 2016-05-13     705.04
## 2016-05-16     704.37
## 2016-05-17     701.46&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;날짜에 대한 처리 없이 알아서 주가 데이터가 하루 미루어진다.&lt;br /&gt;
&lt;code&gt;lag()&lt;/code&gt; 함수의 두번째 인자는 &lt;code&gt;k=1&lt;/code&gt; 로 디폴트값이 잡혀있는데, 이를 조정하는것도 가능하다.&lt;br /&gt;
&lt;code&gt;data&lt;/code&gt; 와 &lt;code&gt;lag(data)&lt;/code&gt; 를 나누고 상수 1을 뺌으로써 간단히 일일수익률을 계산할 수 있게 된다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;data/&lt;span class=&quot;kw&quot;&gt;lag&lt;/span&gt;(data)-&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##               KQ11.Close
## 2016-04-18            NA
## 2016-04-19  0.0091177924
## 2016-04-20 -0.0025937864
## 2016-04-21  0.0025148030
## 2016-04-22  0.0020381303
## 2016-04-25  0.0009245772
## 2016-04-26 -0.0023305584
## 2016-04-27 -0.0036178931
## 2016-04-28  0.0002573079
## 2016-04-29  0.0001000543
## 2016-05-02 -0.0135758888
## 2016-05-03  0.0121545957
## 2016-05-04 -0.0064265740
## 2016-05-09 -0.0033853034
## 2016-05-10  0.0121563021
## 2016-05-11  0.0052982907
## 2016-05-12  0.0015625991
## 2016-05-13 -0.0009502766
## 2016-05-16 -0.0041313131
## 2016-05-17 -0.0078550592&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;일일수익률이므로 직전시차 데이터가 존재하지 않는 4월 18일 수익률만 결측치로 나오고 이후 시차는 수익률을 잘 산출해 준다.&lt;br /&gt;
만약 &lt;code&gt;lag()&lt;/code&gt; 함수를 알지 못한다면 아래와 같은 해괴망측한 수동적인 코드로써 구현해야 했을 것이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;res &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;data
res[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;] &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;NA&lt;/span&gt;

for(i in &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;:&lt;span class=&quot;kw&quot;&gt;nrow&lt;/span&gt;(data)){
    res[i] &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;data[[i]] /&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;data[[i&lt;span class=&quot;dv&quot;&gt;-1&lt;/span&gt;]]-&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
} &lt;span class=&quot;co&quot;&gt;# T_T.....&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;로그수익률-계산하기&quot;&gt;로그수익률 계산하기&lt;/h2&gt;
&lt;p&gt;만약 일일 로그수익률을 계산하고 싶다면 현시차 주가를 직전시차주가로 나눠준 후 로그함수를 씌워주면 되는데&lt;br /&gt;
방금 알게된 &lt;code&gt;lag()&lt;/code&gt; 함수를 이용하면&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;log&lt;/span&gt;(data) -&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;lag&lt;/span&gt;(data))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##               KQ11.Close
## 2016-04-18            NA
## 2016-04-19  0.0090764763
## 2016-04-20 -0.0025971561
## 2016-04-21  0.0025116462
## 2016-04-22  0.0020360562
## 2016-04-25  0.0009241501
## 2016-04-26 -0.0023332784
## 2016-04-27 -0.0036244535
## 2016-04-28  0.0002572748
## 2016-04-29  0.0001000493
## 2016-05-02 -0.0136688838
## 2016-05-03  0.0120813217
## 2016-05-04 -0.0064473133
## 2016-05-09 -0.0033910465
## 2016-05-10  0.0120830076
## 2016-05-11  0.0052843042
## 2016-05-12  0.0015613795
## 2016-05-13 -0.0009507284
## 2016-05-16 -0.0041398706
## 2016-05-17 -0.0078860727&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;의 코드로 일일 로그수익률을 계산할 수 있다.&lt;br /&gt;
그런데 &lt;code&gt;log()&lt;/code&gt;, &lt;code&gt;lag()&lt;/code&gt; 비슷비슷한 함수들이 있어 눈에 확 띄지 않고 복잡해 보인다.&lt;br /&gt;
현재는 현시차와 직전시차의 차이값을 구하는 과정이 필요하다.&lt;br /&gt;
이 차이를 자동으로 계산해주는 함수가 &lt;code&gt;diff()&lt;/code&gt; 이다.&lt;br /&gt;
&lt;code&gt;diff()&lt;/code&gt; 함수를 이용하여 코드를 더 간결하게 해본 결과이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;diff&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;log&lt;/span&gt;(data))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##               KQ11.Close
## 2016-04-18            NA
## 2016-04-19  0.0090764763
## 2016-04-20 -0.0025971561
## 2016-04-21  0.0025116462
## 2016-04-22  0.0020360562
## 2016-04-25  0.0009241501
## 2016-04-26 -0.0023332784
## 2016-04-27 -0.0036244535
## 2016-04-28  0.0002572748
## 2016-04-29  0.0001000493
## 2016-05-02 -0.0136688838
## 2016-05-03  0.0120813217
## 2016-05-04 -0.0064473133
## 2016-05-09 -0.0033910465
## 2016-05-10  0.0120830076
## 2016-05-11  0.0052843042
## 2016-05-12  0.0015613795
## 2016-05-13 -0.0009507284
## 2016-05-16 -0.0041398706
## 2016-05-17 -0.0078860727&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;주가종목에 로그를 취한 후 현시차와 직전시차의 차이값을 &lt;code&gt;diff()&lt;/code&gt; 를 통해 계산한다.&lt;br /&gt;
따라서 &lt;code&gt;log(data) - log(lag(data))&lt;/code&gt; 과 동일한 값이 반환되는 것을 확인할 수 있다.&lt;/p&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;필자는 quantmod package와, 주가지수데이터셋을 끌어올 수 있는 함수 및 코드를 &lt;a href=&quot;http://cafe.naver.com/lovetokens/1569&quot;&gt;카페회원분의 질문글&lt;/a&gt;을 통해 처음으로 알게 되었다.&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Wed, 18 May 2016 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2016/05/18/lag_diff_function.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2016/05/18/lag_diff_function.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>R에서 소리, 음원 재생하기 - tuneR, beepr package</title>
        <description>&lt;p&gt;코드 수행시간이 비교적 길었던 R 스크립트가 있었다.&lt;br /&gt;
Run 이후 마냥 기다리긴 귀찮고, 딴짓을 하기엔 코드 수행시간이 그렇게도 길지 않은 코드여서&lt;br /&gt;
코드 수행이 끝났다는 알람을 줄 수 있는 방법을 찾고 싶었는데, 알람의 방법은 크게 2가지 정도를 원했었다.&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;문자나 메일을 받는 방법&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;비프음 등의 소리를 재생&lt;/strong&gt; 👈&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;시켜 코드 수행이 끝났다는 걸 알려주는 것 이다.&lt;br /&gt;
첫 번째 &amp;quot;문자나 메일을 받는 방법&amp;quot; 은 구체적인 방법을 찾기 힘들었는데, 두 번째 &amp;quot;비프음 등의 소리를 재생&amp;quot; 방법을 알아본 결과 패키지를 이용한 아주 간단한 방법이 있었다.&lt;br /&gt;
지금까지 알게 된 방법들을 간단히 정리해본다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;beepr-package-를-이용해-비프음-재생시키기&quot;&gt;beepr package 를 이용해 비프음 재생시키기&lt;/h2&gt;
&lt;p&gt;비프음을 재생시키기 위한 단 한 개의 함수를 제공해 주는 패키지가 있다. (역시 심플하고 가벼운 것이 최고다 😄)&lt;br /&gt;
패키지 명칭도 &amp;quot;beepr&amp;quot; 이다.&lt;br /&gt;
제공되는 함수는 &lt;code&gt;beep()&lt;/code&gt; 이다. 즉 &lt;code&gt;beepr::beep()&lt;/code&gt; 로 내가 원하는 비프음을 재생시킬 수 있었다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;install.packages&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;beepr&amp;quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(beepr)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;beepr package 설치 및 로드하고&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;beep&lt;/span&gt;()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;를 직접 실행시켜 보면 마치 전자레인지 가동이 종료될 때의 &amp;quot;ping!&amp;quot; 소리가 난다 🎵🎵&lt;/p&gt;
&lt;p&gt;&lt;code&gt;beep()&lt;/code&gt; 함수에서 제공되는 사운드는 아래처럼 11개가 있다.&lt;br /&gt;
기호에 맞게 &lt;code&gt;sound&lt;/code&gt; 인자를 조정해 사용하면 된다.&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;ping&lt;/li&gt;
&lt;li&gt;coin&lt;/li&gt;
&lt;li&gt;fanfare&lt;/li&gt;
&lt;li&gt;complete&lt;/li&gt;
&lt;li&gt;treasure&lt;/li&gt;
&lt;li&gt;ready&lt;/li&gt;
&lt;li&gt;shotgun&lt;/li&gt;
&lt;li&gt;mario&lt;/li&gt;
&lt;li&gt;wilhelm&lt;/li&gt;
&lt;li&gt;facebook&lt;/li&gt;
&lt;li&gt;sword&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;만약-특정-음원-파일을-재생시키고-싶다면-tuner-package&quot;&gt;만약 특정 음원 파일을 재생시키고 싶다면 tuneR package&lt;/h2&gt;
&lt;p&gt;소리재생에 관련된 포괄적인 패키지를 찾아본적도 있는데, 그 패키지 안에는 특정 음원 파일을 재생시키는 기능도 있을것이라 생각했다.&lt;br /&gt;
나는 tuneR 패키지가 눈에 띄었는데 이 패키지 에서 자신이 가지고 있는 음원 파일을 재생시키는 기능을 가진 &lt;code&gt;play()&lt;/code&gt; 함수가 있다. (더 정확히 말하면 Wave class 의 객체만을 실행시키는 함수이다.)&lt;/p&gt;
&lt;p&gt;그 전에 특정 음원 파일을 읽어들여 정보를 보관할 객체를 준비해야 할 필요가 있다. 음원 포맷이 mp3 이라면 &lt;code&gt;readMP3()&lt;/code&gt; 와 같은 함수가 이를 도와준다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;install.packages&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;tuneR&amp;quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(tuneR)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;역시 tuneR 패키지를 설치하고 사용할 준비를 한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;mp3 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;readMP3&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;test.wav&amp;quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;play&lt;/span&gt;(mp3)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위의 코드는 워킹디렉토리에 있는 &amp;quot;Test.mp3&amp;quot; 파일을 불러온 후 R에서 재생시키는 코드이다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;두-패키지의-차이점&quot;&gt;두 패키지의 차이점&lt;/h2&gt;
&lt;p&gt;위에 비프음을 재생시키는 beepr 패키지와 다르게 tuneR 패키지의 &lt;code&gt;play()&lt;/code&gt; 함수는 기본적으로 외부 플레이어를 이용한다는 점에서 차이점이 있다.&lt;br /&gt;
따라서 &lt;code&gt;beep()&lt;/code&gt; 는 R내에서 이용하는데 쉽지만 tuneR 패키지와 조합한 &lt;code&gt;play()&lt;/code&gt; 함수는 활성화되는 프로그램이 R 에서 외부 플레이어 애플리케이션으로 넘어가 버린다. 그리고 beepr 과 달리 tuneR 은 운영체계별로 사용법이 상이하다.&lt;/p&gt;
</description>
        <pubDate>Sat, 30 Apr 2016 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2016/04/30/playsound_in_R.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2016/04/30/playsound_in_R.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>R에서 클립보드의 내용물을 끌어오기</title>
        <description>&lt;p&gt;편하게 데이터를 R에서 불러들이기 위해 간편한 방법이 없을까?&lt;br /&gt;
보통 csv파일을 읽어들이기 위해서 csv파일이 있는 경로를 알고 그경로를 입력해 주어야 한다.&lt;br /&gt;
아래의 코드처럼 말이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;data &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;read.csv&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;./Data/Test.csv&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;워킹디렉토리에서 Data 폴더의 Test.csv 을 읽어들이는 코드이다.&lt;br /&gt;
하지만 간단히 눈앞에 있는 데이터를 R로 불러들이기 위해선 그 데이터 파일의 path 를 알아야 하는 것이 귀찮을 수 있다.&lt;br /&gt;
이러한 귀차니즘까지 발동한다면 Clipboard 를 이용하여 원하는 데이터를 로드하는 것이 현명한 것 같다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;on-windows&quot;&gt;on Windows&lt;/h2&gt;
&lt;p&gt;예를 들어 아래의 모습처럼 우리가 사용하고자 하는 Test.csv 파일이 MS office Excel 에서 열린 상황의 모습이고,&lt;br /&gt;
이것을 R에서 빨리 불러오고 싶다 가정한다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;/assets/Clipboard_Windows.png&quot; /&gt;
&lt;/figure&gt;
&lt;p&gt;다음과 같은 스텝을 따른다.&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;Test.csv 파일의 데이터셋을 전체 선택하여 &lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;C&lt;/kbd&gt; 를 한다.&lt;/li&gt;
&lt;li&gt;R로 되돌어가 &lt;code&gt;read.table(&amp;quot;clipboard&amp;quot;)&lt;/code&gt; 를 실행하여 복사했던 데이터가 제대로 불러와 졌는지 확인한다.&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;필요에 따라 &lt;code&gt;read.table()&lt;/code&gt; 함수의 &lt;code&gt;header&lt;/code&gt;, &lt;code&gt;sep&lt;/code&gt; 인자값을 바꾸어 불러온다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;직접 해본 결과의 스크린샷이다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;/assets/Clipboard_Windows2.png&quot; /&gt;
&lt;/figure&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;read.table&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;clipboard&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##     V1   V2
## 1  Var Test
## 2    a   14
## 3    b   25
## 4    d  646
## 5    e  773
## 6    g   12
## 7    n   45
## 8    h    3
## 9    s    6
## 10   x   72&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;read.table&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;clipboard&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;header =&lt;/span&gt; T)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##   Var Test
## 1   a   14
## 2   b   25
## 3   d  646
## 4   e  773
## 5   g   12
## 6   n   45
## 7   h    3
## 8   s    6
## 9   x   72&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;on-mac&quot;&gt;on Mac&lt;/h2&gt;
&lt;p&gt;맥이용자라면 윈도우의 &lt;code&gt;&amp;quot;clipboard&amp;quot;&lt;/code&gt; 와 같은 약속어로 클립보드 내용물을 불러들일 수 없는것을 확인했다.&lt;br /&gt;
&lt;code&gt;&amp;quot;clipboard&amp;quot;&lt;/code&gt; 대신 &lt;code&gt;pipe(&amp;quot;pbpaste&amp;quot;)&lt;/code&gt; 을 이용한다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;/assets/Clipboard_Mac.png&quot; /&gt;
&lt;/figure&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;read.table&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;pipe&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;pbpaste&amp;quot;&lt;/span&gt;))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##     V1   V2
## 1  Var Test
## 2    a   14
## 3    b   25
## 4    d  646
## 5    e  773
## 6    g   12
## 7    n   45
## 8    h    3
## 9    s    6
## 10   x   72&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;read.table&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;pipe&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;pbpaste&amp;quot;&lt;/span&gt;), &lt;span class=&quot;dt&quot;&gt;header =&lt;/span&gt; T)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##   Var Test
## 1   a   14
## 2   b   25
## 3   d  646
## 4   e  773
## 5   g   12
## 6   n   45
## 7   h    3
## 8   s    6
## 9   x   72&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;물론 Clipboard 로 데이터를 불러오는 것 이므로 데이터 전체가 아닌 일부분만을 복사하는 것도 가능하다. 아래의 스크린샷은 데이터의 앞 3개의 필드를 복사하여 R로 불러들여본 결과이다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;/assets/Clipboard_Mac2.png&quot; /&gt;
&lt;/figure&gt;
&lt;p&gt;이처럼 Clipboard 를 이용하게 되면 사용하고 싶은 데이터를 선택하여 R로 마치 드레그 하는 방식과 같아진다.&lt;/p&gt;
</description>
        <pubDate>Sat, 16 Apr 2016 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2016/04/16/using_clipboard.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2016/04/16/using_clipboard.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>R에서 범용적으로 진행표시줄(progress bar)을 구현할 수 있는 progress package</title>
        <description>&lt;p&gt;이전에 R에서 진행표시줄(progress bar) 을 만들기 위해 &lt;a href=&quot;http://cafe.naver.com/lovetokens/1378&quot;&gt;windows OS 에서 작동되는 &lt;code&gt;winProgressBar()&lt;/code&gt; 함수에 대해서 설명한 적&lt;/a&gt;이 있다.&lt;br /&gt;
아쉽게도 윈도우 이외 다른 운영체계에서는 이 함수가 지원되지 않는다.&lt;br /&gt;
결국 상호호환의 문제로 다른 방안을 찾아보아야 하는 상황이 일어났는데 어떠한 운영체계라 하더라도 R에서 진행표시줄을 나타내기 위한 방법을 찾아 정리해보고자 한다.&lt;/p&gt;
&lt;p&gt;지금까지 찾아본 방법중 가장 좋은 것은 progress package 를 이용하는 것 이었다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;example-code&quot;&gt;example code&lt;/h2&gt;
&lt;p&gt;이전에 포스팅한 글을 빌려 똑같은 예제를 이용해 보겠다.&lt;/p&gt;
&lt;p&gt;임의의 코드를 1000번 반복하는 for문 이며, 반복의 대상이 되는 코드의 내용물 은 상당히 복잡할 것으로 가정한다.&lt;br /&gt;
예를 들어 반복의 대상이 되는 코드를 한번 수행하는데 걸리는 시간이 iteration 에 상관없이 공통으로 0.01초 라면 for 문이 모두 돌아가기 까지 소요되는 시간은 10초가 된다.&lt;br /&gt;
이러한 가정을 정확하게 구현하는 코드가 바로 아래 같다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;for(i in &lt;span class=&quot;kw&quot;&gt;seq&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1000&lt;/span&gt;)){

    &lt;span class=&quot;kw&quot;&gt;Sys.sleep&lt;/span&gt;(&lt;span class=&quot;fl&quot;&gt;0.01&lt;/span&gt;)

}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;progress-package-를-이용해-진행표시줄-만들기&quot;&gt;progress package 를 이용해 진행표시줄 만들기&lt;/h2&gt;
&lt;p&gt;progress package 를 로드&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;progress&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;그 다음 위의 예제코드에 몇 가지 코드를 덧붙인다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;pb &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;progress_bar$&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;total =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1000&lt;/span&gt;)

for(i in &lt;span class=&quot;kw&quot;&gt;seq&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1000&lt;/span&gt;)){

    pb$&lt;span class=&quot;kw&quot;&gt;tick&lt;/span&gt;()
    &lt;span class=&quot;kw&quot;&gt;Sys.sleep&lt;/span&gt;(&lt;span class=&quot;fl&quot;&gt;0.01&lt;/span&gt;)

}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;추가된 코드는 2줄이다.&lt;/p&gt;
&lt;p&gt;우선 첫번째 progress bar 에 대한 사전정보가 담긴 객체 &lt;code&gt;pb&lt;/code&gt; 를 만든다.&lt;br /&gt;
사전정보는 iteration 의 최대값을 넣어준다.&lt;br /&gt;
즉 우리예시의 반복문은 1000회를 반복하므로 total 인자에 1000을 부여한다.&lt;br /&gt;
그렇게 만든 객체 &lt;code&gt;pb&lt;/code&gt; 를 반복문 안에 심어주고 이를 째깍째깍 거릴 수 있도록 &lt;code&gt;tick()&lt;/code&gt; 모듈을 심어준다.&lt;br /&gt;
이것이 가장 기본적인 사용방법이다.&lt;/p&gt;
&lt;p&gt;실행해보면 R console 에 다음과 같이 진행표시줄이 나타나고, 점진적으로 진행되는 에니메이션을 볼 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;터미널 에서 실행시킨 결과&lt;/em&gt;&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/Progressbar_1.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;R studio 에서 실행시킨 결과&lt;/em&gt;&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/Progressbar_2.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;추가된 2줄 코드의 문법형태가 Python을 사용하는 것처럼 닮았다.&lt;br /&gt;
R6 Object 라고 설명되어 있는데, 때문에 다양한 특별기능을 자유롭게 조절하여 사용 할 수 있는 듯 하다.&lt;br /&gt;
그 방법에 대해선 &lt;code&gt;?progress_bar&lt;/code&gt; 를 통해 확인할 수 있으며, 예제코드들을 활용하면 상황에 맞게 커스터마이징도 가능할 듯 싶다.&lt;/p&gt;
&lt;p&gt;참고로 터미널 command line, R studio 에선 실험결과 정상적으로 진행표시줄이 보이는데, 다른 환경&lt;a href=&quot;#fn2&quot; class=&quot;footnoteRef&quot; id=&quot;fnref2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;에선 진행표시줄이 안보일 수도 있나 보다.&lt;/p&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;물론 로드 이전에 패키지의 설치가 되어야 한다. &lt;code&gt;install.packages(&amp;quot;progress&amp;quot;)&lt;/code&gt; 로 가능하다.&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn2&quot;&gt;&lt;p&gt;내가 쓰고 있는 텍스트에디터 Sublime text 3 에서 R-box 플러그인을 이용한 환경에선 진행표시줄이 나타나지 않았다&lt;a href=&quot;#fnref2&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Sat, 16 Apr 2016 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2016/04/16/progressbar.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2016/04/16/progressbar.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>R에서 rjson package 의 toJSON(), fromJSON() 함수 알아보기</title>
        <description>&lt;p&gt;JSON 포맷의 데이터를 R에서 읽어 들인 후 가공하기 위해 JSON 형식을 parser 해야 하는 과정이 필요하다고 한다.&lt;br /&gt;
rjson 라는 패키지가 이를 도와주는데 이 안에 있는 함수 &lt;code&gt;toJSON()&lt;/code&gt;, &lt;code&gt;fromJSON()&lt;/code&gt; 2개를 기본적으로 이용하여 실습을 해보겠다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;준비&quot;&gt;준비&lt;/h2&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;예제-데이터&quot;&gt;예제 데이터&lt;/h3&gt;
&lt;p&gt;실습을 하기 위하여 아래와 같은 JSON 타입의 데이터가 있다고 가정해 보겠다.&lt;br /&gt;
아래의 데이터는 &lt;a href=&quot;https://ko.wikipedia.org/wiki/JSON#.EC.98.88.EC.A0.9C&quot;&gt;JSON 을 설명하는 위키백과&lt;/a&gt;의 예제데이터를 적절히 수정한 것이다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[
  {
    &amp;quot;Name&amp;quot;: &amp;quot;Test&amp;quot;,
    &amp;quot;Age&amp;quot;: 25,
    &amp;quot;Sex&amp;quot;: &amp;quot;F&amp;quot;,
    &amp;quot;Address&amp;quot;: &amp;quot;Seoul&amp;quot;,
    &amp;quot;Hobby&amp;quot;: &amp;quot;Basketball&amp;quot;
  }
]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이것을 워킹디렉토리에 &lt;code&gt;test.json&lt;/code&gt; 로 저장하고 이를 R에서 적절하게 사용하기 위해 불러와 보겠다.&lt;br /&gt;
어떠한 텍스트에디터를 이용하던 상관없다, 저장방법은 위의 JSON 형식 텍스트를 복사한 다음 &amp;quot;test.json&amp;quot; 이란 파일명으로 저장만 하면 된다.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;/assets/rjson_1.png&quot; /&gt;
&lt;/figure&gt;
&lt;p&gt;나는 Sublime text 3 라는 텍스트 에디터를 이용해 이처럼 저장하였다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;jsonlite-패키지-불러오기&quot;&gt;jsonlite 패키지 불러오기&lt;/h3&gt;
&lt;p&gt;당연히 rjson 패키지를 불러오는 것이 필요하다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;rjson&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;tojson-fromjson-함수-이용해보기&quot;&gt;&lt;code&gt;toJSON()&lt;/code&gt;, &lt;code&gt;fromJSON()&lt;/code&gt; 함수 이용해보기&lt;/h2&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;fromjson&quot;&gt;&lt;code&gt;fromJSON()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;우선 &lt;code&gt;fromJSON()&lt;/code&gt; 함수를 알아보자.&lt;br /&gt;
JSON 형 데이터를 R에서 가공할 수 있도록 형태를 변환하여 준다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;data &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;fromJSON&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;file =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;test.json&amp;quot;&lt;/span&gt;)
data&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [[1]]
## [[1]]$Name
## [1] &amp;quot;Test&amp;quot;
## 
## [[1]]$Age
## [1] 25
## 
## [[1]]$Sex
## [1] &amp;quot;F&amp;quot;
## 
## [[1]]$Address
## [1] &amp;quot;Seoul&amp;quot;
## 
## [[1]]$Hobby
## [1] &amp;quot;Basketball&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt;(data)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;list&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;list 형식으로 반환되는데 적절히 data.frame 형태로 변환하여 보면 다음과 같다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;dataframe &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;as.data.frame&lt;/span&gt;(data)
dataframe&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##   Name Age Sex Address      Hobby
## 1 Test  25   F   Seoul Basketball&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;tojson&quot;&gt;&lt;code&gt;toJSON()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;toJSON()&lt;/code&gt; 은 이와 반대의 성격을 가진다.&lt;br /&gt;
R의 객체를 특히 list, data.frame 등을 JSON 형으로 변환시킨다.&lt;br /&gt;
방금만든 &lt;code&gt;dataframe&lt;/code&gt; 객체를 다시 JSON 형태로 바꾸기 위해선,&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;toJSON&lt;/span&gt;(dataframe)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;{\&amp;quot;Name\&amp;quot;:\&amp;quot;Test\&amp;quot;,\&amp;quot;Age\&amp;quot;:25,\&amp;quot;Sex\&amp;quot;:\&amp;quot;F\&amp;quot;,\&amp;quot;Address\&amp;quot;:\&amp;quot;Seoul\&amp;quot;,\&amp;quot;Hobby\&amp;quot;:\&amp;quot;Basketball\&amp;quot;}&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;로 하면된다.&lt;/p&gt;
&lt;p&gt;rjson package 말고도 간단히 이용할 수 있는 jsonlite package 도 있는데 이 패키지의 &lt;code&gt;toJSON()&lt;/code&gt; 함수는 pretty 하게 반환하는 기능을 가지고 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;jsonlite::&lt;span class=&quot;kw&quot;&gt;toJSON&lt;/span&gt;(dataframe, &lt;span class=&quot;dt&quot;&gt;pretty =&lt;/span&gt; T)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [
##   {
##     &amp;quot;Name&amp;quot;: &amp;quot;Test&amp;quot;,
##     &amp;quot;Age&amp;quot;: 25,
##     &amp;quot;Sex&amp;quot;: &amp;quot;F&amp;quot;,
##     &amp;quot;Address&amp;quot;: &amp;quot;Seoul&amp;quot;,
##     &amp;quot;Hobby&amp;quot;: &amp;quot;Basketball&amp;quot;
##   }
## ]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;첫 서두에 있는 예제 데이터와 동일하게 출력된 것을 볼 수 있다.&lt;/p&gt;
</description>
        <pubDate>Wed, 02 Mar 2016 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2016/03/02/rjson_package.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2016/03/02/rjson_package.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>R에서 iteration 별 결과를 손쉽게 저장할 수 있는 replicate() 함수에 대해</title>
        <description>&lt;p&gt;R 에서 특정 코드를 반복해서 실행하는 방법은 for, while, repeat, apply 과 같은 반복문을 이용하면 간단히 구현할 수 있다.&lt;br /&gt;
그런데 만약 반복문의 주안점이 반복된 모든 결과들을 저장해야 한다는 것에 있다면 통상적인 반복문에선 조금 오묘한 방법을 통해 이를 구현한다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;for문을-이용한-주사위-100회-던지기&quot;&gt;for문을 이용한 주사위 100회 던지기&lt;/h2&gt;
&lt;p&gt;for 문을 이용한 간단한 예시 코드를 보면&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;res &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;()
for(i in &lt;span class=&quot;kw&quot;&gt;seq&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;)) res[i] &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;sample&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
res&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##   [1] 3 1 5 4 1 6 6 4 5 6 6 1 1 3 2 4 4 2 3 4 4 4 5 1 5 5 6 1 1 3 6 1 3 5 2
##  [36] 5 1 2 5 3 4 5 2 4 2 5 6 2 3 4 3 1 6 2 1 4 1 1 3 6 4 3 1 5 6 3 4 3 5 3
##  [71] 2 6 3 4 6 3 2 3 3 1 3 6 4 3 6 1 5 4 2 1 6 6 3 3 2 4 3 5 3 1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 코드는 주사위를 100번 던져 나온 숫자들을 &lt;code&gt;res&lt;/code&gt; 라는 객체에 벡터형태로 저장하는 코드로 볼 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;apply를-이용한-주사위-100회-던지기&quot;&gt;&lt;code&gt;apply()&lt;/code&gt;를 이용한 주사위 100회 던지기&lt;/h2&gt;
&lt;p&gt;반복문 방식을 바꿔보겠다.&lt;br /&gt;
위 예시를 &lt;code&gt;apply()&lt;/code&gt; 를 이용해본 코드이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;res &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;apply&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;matrix&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;), &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, function(x) &lt;span class=&quot;kw&quot;&gt;sample&lt;/span&gt;(x, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;))
res&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##   [1] 4 6 5 6 3 5 4 3 5 1 6 6 2 3 5 6 4 6 2 3 5 4 4 5 1 1 2 5 3 6 6 5 5 4 5
##  [36] 5 3 6 3 4 6 5 2 2 6 1 3 6 6 3 5 3 6 4 1 1 4 4 5 1 5 3 4 4 4 4 2 4 2 1
##  [71] 3 1 5 4 4 4 6 1 2 2 4 5 2 1 5 5 2 3 2 1 2 4 5 3 5 1 6 1 1 6&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;지금까지 예시로 든 두 가지 방식의 코드는 한가지 공통점이 있다.&lt;br /&gt;
반복문의 내용이 무엇이 되었던 100번의 반복으로 인해 &lt;strong&gt;어떤 무엇인가가 100번 반환될 것이고, 이에 대한 저장공간을 사전에 생각하여 준비&lt;/strong&gt;해야 한다는 것이다.&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;첫 번째 for문 반복문 예제에선 100개의 값이 저장될 &lt;code&gt;res&lt;/code&gt; 라는 빈 벡터를 사전에 준비한 &lt;code&gt;res &amp;lt;- c()&lt;/code&gt; 코드가 눈에 띈다.&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;두 번째 &lt;code&gt;apply()&lt;/code&gt; 예제에선 일괄함수적용을 위해 1, 2, 3, 4, 5, 6 의 벡터 100개가 열방향으로 bind 된 matrix 를 사전에 준비했고, 이에 대해 무작위로 추출하기 위한 &lt;code&gt;sample()&lt;/code&gt; 함수를 일괄 적용했다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이처럼 100회 반복의 모든 결과를 어딘가의 담아 두기 위한 사전 설계의 노력이 따로 필요하다.&lt;br /&gt;
분명 정석적으로 이러한 준비는 반드시 필요하며 틀린 방법이라고 말할 수 없다.&lt;/p&gt;
&lt;p&gt;문제는 위의 예제처럼 간단한 코드가 아닌 복잡한 상황일 때 사전준비 과정들은 곱절 높아질 수 있다는 것이다.&lt;br /&gt;
보통 복잡도는 지수적으로 늘어나기 때문에 이 오묘한 방법이 실전에서 코딩의 비효율로 일어날 수 있다고 생각한다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;replicate-함수-소개&quot;&gt;&lt;code&gt;replicate()&lt;/code&gt; 함수 소개&lt;/h2&gt;
&lt;p&gt;만약 복잡한 상황일 때,&lt;br /&gt;
위의 예제들의 로직을 그대로 가지고 있되 사전준비의 부담을 덜 수 있는 함축된 함수가 있다고 생각하는데&lt;br /&gt;
바로 &lt;code&gt;replicate()&lt;/code&gt; 함수이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;res &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;replicate&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;sample&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;))
res&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##   [1] 2 5 1 4 2 5 2 2 2 5 1 1 4 5 5 6 3 4 5 1 6 1 3 5 6 2 5 1 5 4 1 1 1 5 6
##  [36] 3 1 2 3 6 3 5 2 6 5 6 4 6 5 5 4 1 2 6 4 5 1 5 5 1 1 2 2 5 6 2 2 3 1 3
##  [71] 4 4 4 6 2 1 2 2 2 1 4 6 5 2 4 5 4 6 4 2 4 1 2 2 2 6 1 4 4 1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;replicate()&lt;/code&gt; 함수는 반복문의 내용(expr)을 두 번째 인자에 부여하고, 첫 번째 인자에 반복회수를 넣어줌으로써 반복 실행된 코드의 결과를 벡터형태로 반환시켜주는 편리한 함수이다.&lt;br /&gt;
사전준비에 대한 로직을 &lt;code&gt;replicate()&lt;/code&gt; 함수가 대신해준다.&lt;br /&gt;
따라서 코드 길이도 확실히 줄일 수 있게 된다.&lt;/p&gt;
</description>
        <pubDate>Fri, 19 Feb 2016 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2016/02/19/replicate_function.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2016/02/19/replicate_function.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>R에서 try(), tryCatch() 함수 소개</title>
        <description>&lt;p&gt;이전에 나는 특정 코드들이 있을 때, 이 코드를 수행하면 에러가 나는지, 나지 않는지 여부를 boolean 값으로 반환하는 그러한 함수를 찾고 있었다. (그보단 이러한 함수를 만들 수 있도록 리소스를 찾아보고 있었다)&lt;br /&gt;
그러던 중 우연히 알게 된 &lt;code&gt;try()&lt;/code&gt; 함수에 대해 알아보고자 한다.&lt;/p&gt;
&lt;p&gt;R이 처음으로 실행된 상황에서 (깔끔한 상태에서) 아래 코드는 &lt;code&gt;bsid&lt;/code&gt; 라는 객체가 어떠한 환경에서도 없기 때문에 에러를 발생한다.&lt;br /&gt;
만약 .rmd 포맷으로 코딩을 하고 있는 상황이라면 오류나는 코드청크가 하나라도 있는 경우 랜더링이 막히게 될 것이다.&lt;br /&gt;
우선 랜더링마저 막히는 상황을 피하기 위해 코드청크의 옵션을 &lt;code&gt;eval=F&lt;/code&gt; 로 설정했다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;bsid&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;실제로 위 코드를 실행시키면&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; bsid
Error: object &amp;#39;bsid&amp;#39; not found&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;의 에러메세지가 출력된다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;try-함수&quot;&gt;&lt;code&gt;try()&lt;/code&gt; 함수&lt;/h2&gt;
&lt;p&gt;에러를 뿜는 위의 코드를 &lt;code&gt;try()&lt;/code&gt; 함수로 감싸주어 보자.&lt;br /&gt;
감싼 이 코드는 단순히 &amp;quot;try&amp;quot; 라는 단어 대로 시도를 해보고 안되면 마는 식으로 동작하게 된다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;expr=&lt;/span&gt;bsid)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;try()&lt;/code&gt; 함수 안에는 표현식(&lt;code&gt;expr&lt;/code&gt;)이 들어가는데 여기에 &lt;code&gt;bsid&lt;/code&gt; 를 입력하였다.&lt;br /&gt;
이 코드는 역시 에러가 반환된다. 하지만&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;bsid&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이것과의 차이점은 에러를 반환하고도 &lt;strong&gt;이후 코드를 계속적으로 수행&lt;/strong&gt;한다는 차이점을 가지고 있다.&lt;br /&gt;
무슨소리인지 잘 모르겠다면 아래코드를 보면 된다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;expr=&lt;/span&gt;bsid)

&lt;span class=&quot;kw&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;Hello R&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;Hello R&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;try()&lt;/code&gt; 함수를 쓴 코드 이후의 코드인 &lt;code&gt;print(&amp;quot;Hello R&amp;quot;)&lt;/code&gt; 은 정상적으로 실행되 수행된 것을 볼 수 있다.&lt;br /&gt;
유의할 것은 실제로 위 코드청크에 &lt;code&gt;eval=F&lt;/code&gt; 설정을 주지 않고도 렌더링이 막히지 않았는다는 것이다.&lt;br /&gt;
따라서 에러를 뿜는 코드이더라 하더라도, 그것이 &lt;code&gt;try()&lt;/code&gt; 함수로 감싸지면 계속적으로 수행된다는 것이다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;silent-인자&quot;&gt;&lt;code&gt;silent&lt;/code&gt; 인자&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;try()&lt;/code&gt; 함수의 &lt;code&gt;silent&lt;/code&gt; 인자로 command 에 에러가 반환되는 메세지 조차 침묵시킬 수 있다.&lt;br /&gt;
이 인자의 값을 &lt;code&gt;TRUE&lt;/code&gt; 로 설정하면 에러는 silent 시킨다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt;(bsid, &lt;span class=&quot;dt&quot;&gt;silent =&lt;/span&gt; T)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;차이점을 체감하기 위해선 직접 R 을 켜 코드를 동작시켜 볼 필요가 있다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;두-줄-의-코드를-try-하되-한줄은-정상-한줄은-에러를-내는-코드로-수정하면&quot;&gt;두 줄 의 코드를 try 하되 한줄은 정상, 한줄은 에러를 내는 코드로 수정하면?&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt;({
  &lt;span class=&quot;kw&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;Hello R&amp;quot;&lt;/span&gt;)  &lt;span class=&quot;co&quot;&gt;# normal code&lt;/span&gt;
  bsid  &lt;span class=&quot;co&quot;&gt;# error code&lt;/span&gt;
}, &lt;span class=&quot;dt&quot;&gt;silent =&lt;/span&gt; T)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;Hello R&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;첫번째 코드는 정상적으로 문자열 &amp;quot;Hello R&amp;quot; 을 출력시킨다.&lt;br /&gt;
그리고 에러를 반환하는 2번째 코드는 반응이 없다.&lt;/p&gt;
&lt;p&gt;순서를 바꾸어 보면?&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt;({
  bsid  &lt;span class=&quot;co&quot;&gt;# error code&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;Hello R&amp;quot;&lt;/span&gt;)  &lt;span class=&quot;co&quot;&gt;# normal code&lt;/span&gt;
}, &lt;span class=&quot;dt&quot;&gt;silent =&lt;/span&gt; T)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;흠 첫번째 코드가 에러를 뿜기 때문에 그 이후 코드인 &lt;code&gt;print(&amp;quot;Hello R&amp;quot;)&lt;/code&gt;는 수행되지 않는것을 볼 수 있다. &lt;code&gt;try()&lt;/code&gt; 함수에 감싸져있는 코드덩어리는 평소대로 에러코드 이후인 정상적 코드를 실행하지 못한다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;에러가-날-경우의-예외처리를-위한-trycatch-함수&quot;&gt;에러가 날 경우의 예외처리를 위한 &lt;code&gt;tryCatch()&lt;/code&gt; 함수&lt;/h2&gt;
&lt;p&gt;이처럼 &lt;code&gt;try()&lt;/code&gt; 함수를 알아 보았는데 잘 이용하면 에러가 나는 코드를 건너뛰고 다음 프로세스를 진행할 수 있다.&lt;br /&gt;
에러가 나는 상황에 대한 조건부 프로세스가 따로 필요하다면 &lt;code&gt;try()&lt;/code&gt; 함수만으론 부족할 수 있다.&lt;br /&gt;
이럴때는 lowerCamelCase 로 네이밍된 &lt;code&gt;tryCatch()&lt;/code&gt; 함수를 이용하면 간편하게 해결할 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;tryCatch&lt;/span&gt;(bsid,
  &lt;span class=&quot;dt&quot;&gt;error =&lt;/span&gt; function(e) &lt;span class=&quot;kw&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;I am error&amp;quot;&lt;/span&gt;),
  &lt;span class=&quot;dt&quot;&gt;warning =&lt;/span&gt; function(w) &lt;span class=&quot;kw&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;I am warning&amp;quot;&lt;/span&gt;),
  &lt;span class=&quot;dt&quot;&gt;finally =&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;NULL&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;I am error&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;tryCatch()&lt;/code&gt; 에는 본코드가 에러를 뿜을 때 실행될 함수를 설정하는 &lt;code&gt;error&lt;/code&gt;,&lt;br /&gt;
에러가 아니라 warning 가 일어날 때 실행될 함수를 설정하는 &lt;code&gt;warning&lt;/code&gt;,&lt;br /&gt;
조건 상관없이 공통으로 실행되는 &lt;code&gt;finally&lt;/code&gt; 인자들을 이용할 수 있어 좀 더 섬세한 예외처리가 가능하다.&lt;/p&gt;
&lt;p&gt;위의 예제는 &lt;code&gt;bsid&lt;/code&gt; 객체가 존재하지 않아 &lt;code&gt;error&lt;/code&gt; 에 해당되는 &lt;code&gt;print(&amp;quot;I am error&amp;quot;)&lt;/code&gt; 가 실행된 경우이다. 만약&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;bsid &amp;lt;-&lt;span class=&quot;st&quot;&gt; &amp;quot;I exist!&amp;quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;를 실행한 다음 위의 코드를 실행한다면?&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;tryCatch&lt;/span&gt;(bsid,
  &lt;span class=&quot;dt&quot;&gt;error =&lt;/span&gt; function(e) &lt;span class=&quot;kw&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;I am error&amp;quot;&lt;/span&gt;),
  &lt;span class=&quot;dt&quot;&gt;warning =&lt;/span&gt; function(w) &lt;span class=&quot;kw&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;I am warning&amp;quot;&lt;/span&gt;),
  &lt;span class=&quot;dt&quot;&gt;finally =&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;NULL&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;I exist!&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;del&gt;
&amp;quot;그래 넌 존재해&amp;quot; 라는 결론을 낼 수 있다.
&lt;/del&gt;
&lt;p&gt;error, warning 둘다 해당되지 않으므로 본 코드 &lt;code&gt;bsid&lt;/code&gt; 가 정상 실행되어 &amp;quot;I exist!&amp;quot; 를 외치는 걸 볼 수 있다.&lt;/p&gt;
</description>
        <pubDate>Thu, 11 Feb 2016 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2016/02/11/tryfunction.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2016/02/11/tryfunction.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>R에서 Shell command 를 실행하기 위한 대안 : system() 함수</title>
        <description>&lt;p&gt;(본 글은 Linux, Mac OS 머신을 기준으로 작성한 글이다)&lt;/p&gt;
&lt;p&gt;Shell command 로 출력되는 것을 R에서 보기 위한 방법은 없을까?&lt;br /&gt;
예를 들어 워킹디렉토리의 파일리스트를 출력하기 위해선 쉘에다서 간단히 &lt;code&gt;ls&lt;/code&gt;, 아니면 &lt;code&gt;ls -al&lt;/code&gt; 등으로 참조할 수 있지만 Rstudio 를 사용하고 있는 상황이 아니고선 R command 상황에서 파일리스트를 참조하기는 좀 그렇다.&lt;/p&gt;
&lt;p&gt;굳이 찾아본다면 Shell 의 &lt;code&gt;ls -al&lt;/code&gt; 와 같은 R코드는&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;file.info&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;list.files&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;all.files =&lt;/span&gt; T))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##                   size isdir mode               mtime               ctime
## .                  204  TRUE  755 2017-05-04 14:28:32 2017-05-04 14:28:32
## ..                1394  TRUE  755 2017-05-04 13:54:18 2017-05-04 13:54:18
## .DS_Store         6148 FALSE  644 2017-05-04 14:28:32 2017-05-04 14:28:32
## Rmarkdown.Rmd     4451 FALSE  755 2017-05-04 14:12:34 2017-05-04 14:12:34
## Rmarkdown.html 1037047 FALSE  666 2017-05-04 14:12:41 2017-05-04 14:12:41
## Rmarkdown.md      7150 FALSE  666 2017-05-04 14:12:41 2017-05-04 14:12:41
##                              atime uid gid     uname grname
## .              2017-05-04 14:30:01 501  20 lovetoken  staff
## ..             2017-05-04 13:56:14 501  20 lovetoken  staff
## .DS_Store      2017-05-04 14:11:18 501  20 lovetoken  staff
## Rmarkdown.Rmd  2017-05-04 14:30:01 501  20 lovetoken  staff
## Rmarkdown.html 2017-05-04 14:28:33 501  20 lovetoken  staff
## Rmarkdown.md   2017-05-04 14:13:27 501  20 lovetoken  staff&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;등을 예시로 들 수 있는데 딱 봐도 마음에 들지 않는다 😨&lt;/p&gt;
&lt;p&gt;불필요하게 길은 코드인 것 뿐만아니라&lt;br /&gt;
Shell 의 &lt;code&gt;ls&lt;/code&gt; 만의 기능을 R의 &lt;code&gt;list.files()&lt;/code&gt; 함수가 가지고 있지 못하다.&lt;/p&gt;
&lt;p&gt;이처럼 R에서 대체할 수 있는 함수나 코드를 찾기보단 아예 R내에서 Shell command를 실행할 수 있는 방법이 없을까 고민해 보았다.&lt;br /&gt;
이것저것 찾아보았는데 &lt;code&gt;system()&lt;/code&gt; 함수를 이용하는 방법이 있어 정리해 본다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;r에서-shell-command-입력해-표준출력-조회하기&quot;&gt;R에서 Shell command 입력해 표준출력 조회하기&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;system&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;ls -al&amp;quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;system&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;pwd&amp;quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;system&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;echo Hello world!&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;사용방법은 &lt;code&gt;system()&lt;/code&gt; 함수의 첫번째 인자인 expression 을 Shell command 로 채워 넣어주면 된다.&lt;br /&gt;
아쉽지만 문자열만을 받아들이기 때문에 &amp;quot;&amp;quot; 로 양 옆을 채워야 한다.&lt;br /&gt;
현재 글에선 출력결과를 생략하였지만 실제로 R에서 실행 시 원하는 표준출력(stdout)을 볼 수 있다.&lt;/p&gt;
&lt;h3 id=&quot;shell-출력물을-r에서-바로-이용하기-위한-intern-true&quot;&gt;Shell 출력물을 R에서 바로 이용하기 위한 &lt;code&gt;intern = TRUE&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;위의 예제에서 본 출력물을 R 내에서 character 형으로 바로 사용하기 위해선 R의 컨테이너에 저장되어야 한다.&lt;br /&gt;
하지만 &lt;code&gt;system()&lt;/code&gt; 함수를 이용한 기본출력은 벡터형으로 반환되지 않는다.&lt;br /&gt;
출력은 출력일 뿐인 이것을 벡터형으로 반환시키기 위해선 &lt;code&gt;intern = TRUE&lt;/code&gt; 로 설정하면 된다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;system&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;ls -al&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;intern =&lt;/span&gt; T)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;total 2080&amp;quot;                                                          
## [2] &amp;quot;drwxr-xr-x@  6 lovetoken  staff      204 May  4 14:28 .&amp;quot;             
## [3] &amp;quot;drwxr-xr-x@ 41 lovetoken  staff     1394 May  4 13:54 ..&amp;quot;            
## [4] &amp;quot;-rw-r--r--@  1 lovetoken  staff     6148 May  4 14:28 .DS_Store&amp;quot;     
## [5] &amp;quot;-rwxr-xr-x@  1 lovetoken  staff     4451 May  4 14:12 Rmarkdown.Rmd&amp;quot; 
## [6] &amp;quot;-rw-rw-rw-@  1 lovetoken  staff  1037047 May  4 14:12 Rmarkdown.html&amp;quot;
## [7] &amp;quot;-rw-rw-rw-@  1 lovetoken  staff     7150 May  4 14:12 Rmarkdown.md&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;system&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;pwd&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;intern =&lt;/span&gt; T)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;/Users/lovetoken/Desktop/Dropbox/02_Study/01_Statistic/31_R/11_R_posting/01_function/system&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;system&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;echo Hello world!&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;intern =&lt;/span&gt; T)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;Hello world!&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;shell-표준출력을-r과-함께-이용&quot;&gt;Shell 표준출력을 R과 함께 이용&lt;/h2&gt;
&lt;p&gt;이점을 이용하여 R과 Shell 의 캐미를 만들 수 있을 것이다.&lt;/p&gt;
&lt;h3 id=&quot;ex1-r-에서의-hello-와-shell-에서의-r-을-붙여-hello-r-완성시키기&quot;&gt;ex1) R 에서의 &#39;Hello &#39; 와 Shell 에서의 &#39;R!&#39; 을 붙여 &#39;Hello R!&#39; 완성시키기&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;R &amp;lt;-&lt;span class=&quot;st&quot;&gt; &amp;quot;Hello &amp;quot;&lt;/span&gt;
Shell &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;system&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;echo R!&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;intern =&lt;/span&gt; T)

&lt;span class=&quot;kw&quot;&gt;paste0&lt;/span&gt;(R, Shell)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;Hello R!&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;ex2-r에서-생성한-규칙적-문자열-데이터들로-폴더-생성하기&quot;&gt;ex2) R에서 생성한 규칙적 문자열 데이터들로 폴더 생성하기&lt;/h3&gt;
&lt;p&gt;R에서 준비된 날짜명칭들을 이용해 Shell &lt;code&gt;mkdir&lt;/code&gt; 명령어와 혼합하여 폴더들을 생성해보는 예제이다.&lt;/p&gt;
&lt;p&gt;우선 현 워킹디렉토리의 상황을 조회해보면&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;system&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;ls -al&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;intern =&lt;/span&gt; T)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;total 2080&amp;quot;                                                          
## [2] &amp;quot;drwxr-xr-x@  6 lovetoken  staff      204 May  4 14:28 .&amp;quot;             
## [3] &amp;quot;drwxr-xr-x@ 41 lovetoken  staff     1394 May  4 13:54 ..&amp;quot;            
## [4] &amp;quot;-rw-r--r--@  1 lovetoken  staff     6148 May  4 14:28 .DS_Store&amp;quot;     
## [5] &amp;quot;-rwxr-xr-x@  1 lovetoken  staff     4451 May  4 14:12 Rmarkdown.Rmd&amp;quot; 
## [6] &amp;quot;-rw-rw-rw-@  1 lovetoken  staff  1037047 May  4 14:12 Rmarkdown.html&amp;quot;
## [7] &amp;quot;-rw-rw-rw-@  1 lovetoken  staff     7150 May  4 14:12 Rmarkdown.md&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;폴더따윈 없다.&lt;/p&gt;
&lt;p&gt;최근 3일치 날짜명칭들을 R을 통해 만들고&lt;br /&gt;
Shell 에서 폴더를 만드는 명령어인 &lt;code&gt;mkdir&lt;/code&gt; 과 결합하여&lt;br /&gt;
최종적으로 &lt;code&gt;&amp;quot;mkdir 2017-05-02 2017-05-03 2017-05-04&amp;quot;&lt;/code&gt; 명령어를 만들어 실행시키는 코드이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;date &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;seq&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;Sys.Date&lt;/span&gt;() -&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;Sys.Date&lt;/span&gt;(), &lt;span class=&quot;dt&quot;&gt;by =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;paste&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;collapse =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot; &amp;quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;paste&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;mkdir&amp;quot;&lt;/span&gt;, date) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;system&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;intern =&lt;/span&gt; T)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## character(0)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;실행 이후 최근 3일치 명칭 폴더 3개가 잘 만들어 졌는지 확인해 보면&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;system&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;ls -al&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;intern =&lt;/span&gt; T)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;total 2080&amp;quot;                                                          
##  [2] &amp;quot;drwxr-xr-x@  9 lovetoken  staff      306 May  4 14:30 .&amp;quot;             
##  [3] &amp;quot;drwxr-xr-x@ 41 lovetoken  staff     1394 May  4 13:54 ..&amp;quot;            
##  [4] &amp;quot;-rw-r--r--@  1 lovetoken  staff     6148 May  4 14:28 .DS_Store&amp;quot;     
##  [5] &amp;quot;drwxr-xr-x   2 lovetoken  staff       68 May  4 14:30 2017-05-02&amp;quot;    
##  [6] &amp;quot;drwxr-xr-x   2 lovetoken  staff       68 May  4 14:30 2017-05-03&amp;quot;    
##  [7] &amp;quot;drwxr-xr-x   2 lovetoken  staff       68 May  4 14:30 2017-05-04&amp;quot;    
##  [8] &amp;quot;-rwxr-xr-x@  1 lovetoken  staff     4451 May  4 14:12 Rmarkdown.Rmd&amp;quot; 
##  [9] &amp;quot;-rw-rw-rw-@  1 lovetoken  staff  1037047 May  4 14:12 Rmarkdown.html&amp;quot;
## [10] &amp;quot;-rw-rw-rw-@  1 lovetoken  staff     7150 May  4 14:12 Rmarkdown.md&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;잘 만들어 진 것을 볼 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;정리&quot;&gt;정리&lt;/h2&gt;
&lt;p&gt;필자는 Shell 에 대해 완전 초급자여서 즐겨 쓰는 명령어 몇 개 이외에 잘 아는것이 없다.&lt;br /&gt;
따라서 예제도 저 정도의 수준의 예제 외에 생각나는 아이디어가 바닥이 나버렸다. 😓&lt;br /&gt;
하지만 Shell 고수분들은 응용력과 잠재력이 대단할 것인데 R과의 연동된 좋은 아이디어들을 구현할 수 있을 것 같아 감히 &lt;code&gt;system()&lt;/code&gt; 함수를 소개한다.&lt;/p&gt;
</description>
        <pubDate>Mon, 08 Feb 2016 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2016/02/08/system_function.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2016/02/08/system_function.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>R에서 Step function model 이용하기</title>
        <description>&lt;p&gt;일반적인 선형회귀분석보다 모델의 해석이 특수하나&lt;br /&gt;
한눈에 이해할 수 있는 모델링 방법인 Step function 을 R에서 구현해보고자 한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt;(College, &lt;span class=&quot;dt&quot;&gt;package =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;ISLR&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;예제로 사용할 데이터는 ISLR 패키지에 내장되어있는 &lt;code&gt;College&lt;/code&gt; 데이터이다.&lt;br /&gt;
미국의 여러 대학교가 관측치이고, 각 대학들의 지원자 수와 각 대학들의 정보를 변수로 가지고 있는 데이터셋이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;summary&lt;/span&gt;(College)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##  Private        Apps           Accept          Enroll       Top10perc    
##  No :212   Min.   :   81   Min.   :   72   Min.   :  35   Min.   : 1.00  
##  Yes:565   1st Qu.:  776   1st Qu.:  604   1st Qu.: 242   1st Qu.:15.00  
##            Median : 1558   Median : 1110   Median : 434   Median :23.00  
##            Mean   : 3002   Mean   : 2019   Mean   : 780   Mean   :27.56  
##            3rd Qu.: 3624   3rd Qu.: 2424   3rd Qu.: 902   3rd Qu.:35.00  
##            Max.   :48094   Max.   :26330   Max.   :6392   Max.   :96.00  
##    Top25perc      F.Undergrad     P.Undergrad         Outstate    
##  Min.   :  9.0   Min.   :  139   Min.   :    1.0   Min.   : 2340  
##  1st Qu.: 41.0   1st Qu.:  992   1st Qu.:   95.0   1st Qu.: 7320  
##  Median : 54.0   Median : 1707   Median :  353.0   Median : 9990  
##  Mean   : 55.8   Mean   : 3700   Mean   :  855.3   Mean   :10441  
##  3rd Qu.: 69.0   3rd Qu.: 4005   3rd Qu.:  967.0   3rd Qu.:12925  
##  Max.   :100.0   Max.   :31643   Max.   :21836.0   Max.   :21700  
##    Room.Board       Books           Personal         PhD        
##  Min.   :1780   Min.   :  96.0   Min.   : 250   Min.   :  8.00  
##  1st Qu.:3597   1st Qu.: 470.0   1st Qu.: 850   1st Qu.: 62.00  
##  Median :4200   Median : 500.0   Median :1200   Median : 75.00  
##  Mean   :4358   Mean   : 549.4   Mean   :1341   Mean   : 72.66  
##  3rd Qu.:5050   3rd Qu.: 600.0   3rd Qu.:1700   3rd Qu.: 85.00  
##  Max.   :8124   Max.   :2340.0   Max.   :6800   Max.   :103.00  
##     Terminal       S.F.Ratio      perc.alumni        Expend     
##  Min.   : 24.0   Min.   : 2.50   Min.   : 0.00   Min.   : 3186  
##  1st Qu.: 71.0   1st Qu.:11.50   1st Qu.:13.00   1st Qu.: 6751  
##  Median : 82.0   Median :13.60   Median :21.00   Median : 8377  
##  Mean   : 79.7   Mean   :14.09   Mean   :22.74   Mean   : 9660  
##  3rd Qu.: 92.0   3rd Qu.:16.50   3rd Qu.:31.00   3rd Qu.:10830  
##  Max.   :100.0   Max.   :39.80   Max.   :64.00   Max.   :56233  
##    Grad.Rate     
##  Min.   : 10.00  
##  1st Qu.: 53.00  
##  Median : 65.00  
##  Mean   : 65.46  
##  3rd Qu.: 78.00  
##  Max.   :118.00&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;18개 만큼의 변수들을 가지고 있는데, 현 분석과정에선 지원서 등록횟수인 &lt;code&gt;Apps&lt;/code&gt; 을 종속변수로 하고, 졸업률인 &lt;code&gt;Grad.Rate&lt;/code&gt; 를 독립변수로 제한시켜 두 개의 변수만 신경쓰도록 하겠다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;simple-regression-model&quot;&gt;Simple regression model&lt;/h2&gt;
&lt;p&gt;일반적인 단순선형회귀적합을 하게되면 아래와 같이 모델적합이 된다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;regFit &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;lm&lt;/span&gt;(Apps ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;Grad.Rate, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; College)
&lt;span class=&quot;kw&quot;&gt;summary&lt;/span&gt;(regFit)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = Apps ~ Grad.Rate, data = College)
## 
## Residuals:
##    Min     1Q Median     3Q    Max 
##  -3764  -2123  -1473    650  44711 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&amp;gt;|t|)    
## (Intercept)  837.136    541.788   1.545    0.123    
## Grad.Rate     33.064      8.006   4.130 4.02e-05 ***
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1
## 
## Residual standard error: 3831 on 775 degrees of freedom
## Multiple R-squared:  0.02154,    Adjusted R-squared:  0.02027 
## F-statistic: 17.06 on 1 and 775 DF,  p-value: 4.019e-05&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;회귀적합된 1차 선형방정식을 살펴보면&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;span class=&quot;math display&quot;&gt;&lt;em&gt;A&lt;/em&gt;&lt;em&gt;p&lt;/em&gt;&lt;em&gt;p&lt;/em&gt;&lt;em&gt;s&lt;/em&gt; = 837.14 + 33.06 × &lt;em&gt;G&lt;/em&gt;&lt;em&gt;r&lt;/em&gt;&lt;em&gt;a&lt;/em&gt;&lt;em&gt;d&lt;/em&gt;.&lt;em&gt;R&lt;/em&gt;&lt;em&gt;a&lt;/em&gt;&lt;em&gt;t&lt;/em&gt;&lt;em&gt;e&lt;/em&gt;&lt;/span&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;졸업률이 한 단위 증가하면 지원자 수도 33.06회만큼 증가하는 경향을 가진 것으로 알 수 있다.&lt;br /&gt;
실제 데이터의 산포와 산출된 회귀적합선을 겹쳐 표현하면 아래와 같다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(Apps ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;Grad.Rate, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; College, &lt;span class=&quot;dt&quot;&gt;col =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;grey&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;pch =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;21&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;lines&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;sort&lt;/span&gt;(College$Grad.Rate), &lt;span class=&quot;kw&quot;&gt;sort&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;predict&lt;/span&gt;(regFit)), &lt;span class=&quot;dt&quot;&gt;col =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;blue&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;lwd =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;grid&lt;/span&gt;()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/step_1.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;분명 학교의 졸업률이 높으면 높을수록 대학교의 인기가 높은 것인지&lt;br /&gt;
해당학교의 지원자가 많아지는 경향을 그림을 보면 알 수 있다.&lt;br /&gt;
&lt;code&gt;Grad.Rate&lt;/code&gt; 의 회귀계수 또한 베타계수가 0이라는 귀무가설을 기각시키는 P-value 이다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;step-function-model&quot;&gt;Step function model&lt;/h2&gt;
&lt;p&gt;자 그러면 이제 언급할 Step function model 은 위의 일반적인 선형회귀적합과 어떤 차이가 있을까?&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;stepFit &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;lm&lt;/span&gt;(Apps ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;cut&lt;/span&gt;(Grad.Rate, &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;), &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; College)
&lt;span class=&quot;kw&quot;&gt;summary&lt;/span&gt;(stepFit)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = Apps ~ cut(Grad.Rate, 2), data = College)
## 
## Residuals:
##    Min     1Q Median     3Q    Max 
##  -3322  -2115  -1483    681  44631 
## 
## Coefficients:
##                           Estimate Std. Error t value Pr(&amp;gt;|t|)    
## (Intercept)                 2494.0      199.7  12.486  &amp;lt; 2e-16 ***
## cut(Grad.Rate, 2)(64,118]    969.1      276.0   3.511 0.000471 ***
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1
## 
## Residual standard error: 3842 on 775 degrees of freedom
## Multiple R-squared:  0.01566,    Adjusted R-squared:  0.01439 
## F-statistic: 12.33 on 1 and 775 DF,  p-value: 0.0004714&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;lm()&lt;/code&gt; 함수의 formula 인자부분의 독립변수에 해당되는 부분을 보면 &lt;code&gt;cut(Grad.Rate, 2)&lt;/code&gt; 으로 되어있는데 이것의 의미는 &lt;code&gt;Grad.Rate&lt;/code&gt; 변수값들을 두 부분으로 범주화(grouping) 시키겠다는 의미이다.&lt;br /&gt;
어떻게 범주화를 시키느냐? 한쪽은 값이 낮은 그룹, 나머지 한쪽은 값이 높은 그룹으로 이분류가 자동적으로 된다.&lt;br /&gt;
그리고 위에서 출력된 &lt;code&gt;summary(stepFit)&lt;/code&gt; 의 결과물을 이용해 종속변수 &lt;code&gt;Apps&lt;/code&gt; 의 모델 방정식을 표현하면 아래와 같다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;span class=&quot;math display&quot;&gt;&lt;em&gt;A&lt;/em&gt;&lt;em&gt;p&lt;/em&gt;&lt;em&gt;p&lt;/em&gt;&lt;em&gt;s&lt;/em&gt; = 2494.0 + 969.1 × &lt;em&gt;c&lt;/em&gt;&lt;em&gt;u&lt;/em&gt;&lt;em&gt;t&lt;/em&gt;(&lt;em&gt;G&lt;/em&gt;&lt;em&gt;r&lt;/em&gt;&lt;em&gt;a&lt;/em&gt;&lt;em&gt;d&lt;/em&gt;.&lt;em&gt;R&lt;/em&gt;&lt;em&gt;a&lt;/em&gt;&lt;em&gt;t&lt;/em&gt;&lt;em&gt;e&lt;/em&gt;, 2)(64, 118]&lt;/span&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;단 위에서 &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;c&lt;/em&gt;&lt;em&gt;u&lt;/em&gt;&lt;em&gt;t&lt;/em&gt;(&lt;em&gt;G&lt;/em&gt;&lt;em&gt;r&lt;/em&gt;&lt;em&gt;a&lt;/em&gt;&lt;em&gt;d&lt;/em&gt;.&lt;em&gt;R&lt;/em&gt;&lt;em&gt;a&lt;/em&gt;&lt;em&gt;t&lt;/em&gt;&lt;em&gt;e&lt;/em&gt;, 2)(64, 118]&lt;/span&gt; 의 값은 &lt;code&gt;Grad.Rate&lt;/code&gt; 값이 &lt;span class=&quot;math inline&quot;&gt;64 &amp;lt; &lt;em&gt;G&lt;/em&gt;&lt;em&gt;r&lt;/em&gt;&lt;em&gt;a&lt;/em&gt;&lt;em&gt;d&lt;/em&gt;.&lt;em&gt;R&lt;/em&gt;&lt;em&gt;a&lt;/em&gt;&lt;em&gt;t&lt;/em&gt;&lt;em&gt;e&lt;/em&gt; ≤ 118&lt;/span&gt; 일 때 1, 아니면 0의 의미이다.&lt;/p&gt;
&lt;p&gt;실제 데이터 산포와 &lt;code&gt;stepFit&lt;/code&gt; 적합선을 겹처 그려보면&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(Apps ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;Grad.Rate, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; College, &lt;span class=&quot;dt&quot;&gt;col =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;grey&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;pch =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;21&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;lines&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;sort&lt;/span&gt;(College$Grad.Rate), &lt;span class=&quot;kw&quot;&gt;sort&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;predict&lt;/span&gt;(stepFit)), &lt;span class=&quot;dt&quot;&gt;col =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;blue&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;lwd =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;grid&lt;/span&gt;()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/step_2.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Grad.Rate&lt;/code&gt; 의 값이 낮은 그룹, 즉 졸업률이 64% 이하인 그룹은 2493.99회로, 64% 이상인 그룹은 3463.13회로 예측이 되는 모델인 것이다.&lt;/p&gt;
&lt;p&gt;이처럼 모델의 형태가 계단(Step)의 형태로 적합 시키며 독립변수의 구간을 계단처럼 구분지은후 각 그룹구간별 종속변수의 값을 예측하게 되는 특성을 가진다.&lt;/p&gt;
&lt;p&gt;step function model 을 구현하기 위한 방법은 위의 예제처럼 R에서 &lt;code&gt;cut()&lt;/code&gt; 함수를 통해 간단히 구현할 수 있다.&lt;br /&gt;
&lt;code&gt;lm()&lt;/code&gt; 함수를 이용한 적합은 그대로 두고, formula 인자부분만 알맞게 조정하면 되는데&lt;br /&gt;
범주화를 시키고자 하는 독립변수에 &lt;code&gt;cut()&lt;/code&gt; 함수를 씌우고 범주화 개수를 지정시키면 된다. (더 특수하게 범주화시키고자 한다면 &lt;code&gt;cut()&lt;/code&gt; 함수의 도움말을 이용해 응용해 볼 수도 있겠다)&lt;/p&gt;
&lt;h3 id=&quot;example-step-function-model&quot;&gt;Example step function model&lt;/h3&gt;
&lt;p&gt;2개가 아닌 3개의 그룹으로 나누어 step function 적합한 경우의 코드 및 결과이다.&lt;br /&gt;
덧붙이면 &lt;code&gt;update()&lt;/code&gt; 함수를 통해 이전 객체 &lt;code&gt;stepFit&lt;/code&gt; 을 재활용 하고, 형식만 변형했다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;stepFit3 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;update&lt;/span&gt;(stepFit, Apps ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;cut&lt;/span&gt;(Grad.Rate, &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;))

&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(Apps ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;Grad.Rate, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; College, &lt;span class=&quot;dt&quot;&gt;col =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;grey&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;pch =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;21&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;lines&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;sort&lt;/span&gt;(College$Grad.Rate), &lt;span class=&quot;kw&quot;&gt;sort&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;predict&lt;/span&gt;(stepFit3)), &lt;span class=&quot;dt&quot;&gt;col=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&amp;quot;blue&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;lwd =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;grid&lt;/span&gt;()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/step_3.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;이번엔 4개로 해보면?&lt;br /&gt;
다음과 같다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;stepFit4 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;update&lt;/span&gt;(stepFit, Apps ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;cut&lt;/span&gt;(Grad.Rate, &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;))

&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(Apps ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;Grad.Rate, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; College, &lt;span class=&quot;dt&quot;&gt;col =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;grey&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;pch =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;21&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;lines&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;sort&lt;/span&gt;(College$Grad.Rate), &lt;span class=&quot;kw&quot;&gt;sort&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;predict&lt;/span&gt;(stepFit4)), &lt;span class=&quot;dt&quot;&gt;col =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;blue&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;lwd =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;grid&lt;/span&gt;()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/step_4.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 25 Jan 2016 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2016/01/25/Step_function_modeling.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2016/01/25/Step_function_modeling.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>Imitation game</title>
        <description>&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/Imitation_game_1.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;영화 &lt;a href=&quot;http://theimitationgamemovie.com/&quot;&gt;이미테이션 게임&lt;/a&gt;을 시작으로 요즘 컴퓨터에 관련된 도서들에 관심을 가지기 시작했다.&lt;br /&gt;
나는 독서와 거리가 매우 멀었고, 대학 전공서적류 외에는 지금껏 특별하게 독서하는 행위의 누적시간량이 심각할&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; 정도로 적었다.&lt;/p&gt;
&lt;p&gt;사실 독서라는 것이 많은 사람들에게 권장되고 중요한 것 이라는 건 수도 없이 들어왔다.&lt;br /&gt;
하지만 솔직하게 말해서 흥미가 없다면 정작 본인이 등을 돌리게 된다.&lt;br /&gt;
나는 애초에 어려운 것들은 매우 싫어해서 단순화 하는것을 좋아하고 쉽게 풀어서 이해시켜주는 스토리텔링을 좋아한다.&lt;br /&gt;
그렇기 때문에 솜씨 좋고 기교있는 단어들이 조합된 장문의 글들은 완벽하게 이해하지 못했고&lt;a href=&quot;#fn2&quot; class=&quot;footnoteRef&quot; id=&quot;fnref2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;, 사전적 정의와 같은 단순 명료한 요약글만을 보고 넘기는 것이 습관화 되었으며, 더 나아가 글로만 채워져 있는 도서보단 그림과 삽화가 많이 들어간 책이나 아니면 순도 100% 삽화가 되어있는 만화책, 동영상의 매체를 더 선호하였다. (지금도 선호한다.)&lt;/p&gt;
&lt;p&gt;여하튼 이러한 특성을 가진 나는 단순화에 대한 집착이 강했다.&lt;br /&gt;
단순화는 노력을 최소로 하고 싶어하는 인간의 본능이라는 것이 첫번째이고, 두번째로 단순화를 끝내야 생각의 정리정돈이 되어 가치가 있는 정보로 차곡차곡 쌓인다는 성취감이 느껴졌기 때문이다.&lt;/p&gt;
&lt;p&gt;그런데 지금껏 단순화를 시도하면서 한계가 느껴졌다.&lt;br /&gt;
도저히 단순화가 안되는 범위의 것들이 있다는 걸 깨닫게 되면서 많은 고민들이 생겼다.&lt;br /&gt;
이 범위에 있는 것들은 워낙 방대하고 포괄적이다 보니 남들에게 쉽게 스토리텔링하기가 불가능에 가까운 부피를 가진다는 특성이 있다.&lt;br /&gt;
이것을 지금껏 행해왔던 단순화하여 가치가 있는 정보로 내 머리에 담기 위해 단순화의 역방향을 걸어보고 있는 시점인 것 같다.&lt;/p&gt;
&lt;p&gt;어느새부터인가 나는 단순화를 하기 위한 도구를 찾게 되었다.&lt;br /&gt;
여러 가능성을 가진 도구를 발견하고 탐색하였으며, 이중에 가장 효과적이고 실현가능성 &amp;amp; 잠재력이 높은 도구는 컴퓨터로 생각되었다.&lt;br /&gt;
이때부터 컴퓨터 공부를 관심을 가지고 시작하였고, 컴퓨터 공부중에 첫번째 계단이 프로그래밍이였다.&lt;/p&gt;
&lt;p&gt;프로그래밍 자체는 단순화를 좋아하는 나에게 있어 상당히 어울렸다.&lt;br /&gt;
무엇보다 융통성이 제로에 가까운 딱딱한 컴퓨터 언어는 왠지 나에게 있어 격한 공감을 불러왔다.&lt;br /&gt;
언어중 이렇게 객관적이고 무뚝뚝한(?) 언어는 본적이 없었다.&lt;br /&gt;
예를 들어 내가 아직도 섭렵하지 못하고 있는 국어문제나 토익문제의 5지선다 중 아무리 머리를 굴려봐도 2~3개의 문항중 무엇을 선택하여야 할지 막막해하는 자신을 볼 수 있었다.&lt;br /&gt;
하지만 컴퓨터 언어는 머리를 최대한 굴리면 5지선다중 1개의 문항을 확신하여 답안지에 작성할 수 있었다.&lt;br /&gt;
따라서 프로그래밍 자체에 대한 공부는 즐겁고 비교적 적은시간안에 성취하였다.&lt;/p&gt;
&lt;p&gt;두번째 계단은 Minimal working example 에 대한 구현이다.&lt;br /&gt;
프로그래밍을 공부한 것을 이용해 간단한 예제를 구현하는 것은 실로 엄청난 성취감을 느끼게 하였다.&lt;br /&gt;
뭐든지 가능할 것 같은 말도안되는 이상까지 꿈꾸며 약간의 허황된 자신감이 생겼다.&lt;/p&gt;
&lt;p&gt;그런데 세번째 계단에서 숨이 턱 막혔다.&lt;br /&gt;
정작 내가 추구하던 복잡한 것을 단순화하는 건 두번째 계단이었던 Minimal working example 에 대한 구현의 트레이닝으로 얼마든지 해결할 수 있다고 생각했었다.&lt;br /&gt;
하지만 숨이 턱 막히고 나서 나름대로 내린 결론은 복잡한걸 단순화 하기에 앞서 복잡함의 내면을 철저하게 모두 이해하여야 한다는 것이다.&lt;/p&gt;
&lt;p&gt;요즘들어 엘런튜링을 시작해 리누스 토르발스와 같은 위인들은 어떻게 이러한 문제들을 해결하려고 노력하였는지 궁금해 하며 독서를 시작하게 되었다.&lt;br /&gt;
그리고 도구를 더 격렬하게 찾고 갈망하기 시작하였다.&lt;br /&gt;
그런데 잠깐, 이상하게도 이러한 과정을 겪게되다보니 현 나는&lt;br /&gt;
아까도 말했던 단순화의 역방향을 걷고 있더라..&lt;/p&gt;
&lt;p&gt;주저리주저리 말주변이 없이 글을 작성한 거 같은데 이글의 결론을 정리하면&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;독서는 필요했다(더라.)&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;협업이 절실하게 필요하더라.&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;주변의 연륜이 있는 지인분왈, 결국 자네가 마지막에 찾게될 Key는 &#39;사람&#39;과 &#39;인문학적 소양&#39; 이라고 하시더라.&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;마지막으로 알면 알수록 부족한 것을 뼈저리~~ 느끼게 되더라.&lt;/li&gt;
&lt;/ol&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;본인이 자신에 대해 심각할 정도라고 생각한 바를 적은 것은 이글을 쓴 최근의 시기에 깨닫기 때문에 이렇게 작성하는것이라고 본다.&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn2&quot;&gt;&lt;p&gt;어찌보면 &amp;quot;이해를 못한것&amp;quot;보다, &amp;quot;이해를 하려고 노력하지 않았다&amp;quot; 라는게 옳은 것 같다.&lt;a href=&quot;#fnref2&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Mon, 07 Dec 2015 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/diary/2015/12/07/Imitation_game.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/diary/2015/12/07/Imitation_game.html</guid>
        
        
        <category>Diary</category>
        
      </item>
    
      <item>
        <title>R에서 연산자의 우선순위</title>
        <description>&lt;h2 id=&quot;연산자-종류&quot;&gt;연산자 종류&lt;/h2&gt;
&lt;p&gt;R은 다양한 연산자(Operator)를 가지고 있다.&lt;br /&gt;
사칙연산 시 사용되는 &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt; 뿐만 아니라&lt;br /&gt;
&lt;code&gt;==&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt; 와 같은 비교연산자,&lt;br /&gt;
&lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;lt;-&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt;, &lt;code&gt;:&lt;/code&gt; 등과 같은 것도 모두 연산자에 포함된다.&lt;br /&gt;
더 이야기하면 &lt;code&gt;%...%&lt;/code&gt; 꼴로 생긴 사용자가 따로 정의할 수 있는 연산자도 얼마든지 만들 수 있다.&lt;br /&gt;
이렇게 많은 연산자가 코드 한 줄에 다양하게 사용된다면 반드시 고려해야할 것이 연산자의 실행 우선순위가 있겠다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;?Syntax&lt;/code&gt; 를 작성하여 실행시키면 연산자의 목록이 수행절차에 대한 우선순위별로 &lt;a href=&quot;https://stat.ethz.ch/R-manual/R-devel/library/base/html/Syntax.html&quot;&gt;정리&lt;/a&gt;되어 있다.&lt;br /&gt;
예를 들어 곱셈과 덧셈이 같이 있는 식의 경우, 곱셈을 먼저 계산하고 그 다음 덧셈을 계산해야 할 것이다.&lt;br /&gt;
이 경우 덧셈과 곱셈 중 우선순위는 곱셈이 더 높은 것이다.&lt;br /&gt;
이처럼 R의 다양한 연산자들이 조합될 때 계산의 순서를 결정짓는 우선순위를 알고싶다면 &lt;code&gt;?Syntax&lt;/code&gt; 로 열리는 도움말을 참고한다.&lt;br /&gt;
아래의 그림이 도움말을 연 경우인데 맨 위의 연산자가 가장 높은 순으로 계산수행이 시작된다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;img src=&quot;/assets/operatorR1.png&quot; /&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;궁금증&quot;&gt;궁금증&lt;/h2&gt;
&lt;p&gt;연산자에 대한 빈번한 궁금증과 질문들을 접하는데&lt;br /&gt;
대표적으로 몇 개만 나열해 보았다.&lt;br /&gt;
만약 위의 연산자의 우선순위에 대해 정확히 알게 된다면 바로 해결되는 문제이며 그렇게 대단한 문제도 아니다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;와-의-차이가-무엇인가요&quot;&gt;&lt;code&gt;&amp;lt;-&lt;/code&gt; 와 &lt;code&gt;=&lt;/code&gt; 의 차이가 무엇인가요??&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;-&lt;/code&gt; 와 &lt;code&gt;=&lt;/code&gt; 는 오른쪽에 반환되는 값을 왼쪽에 할당하는 할당연산자&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;로 의미는 똑같다.&lt;br /&gt;
하지만 한가지 차이가 &lt;code&gt;=&lt;/code&gt; 보다는 &lt;code&gt;&amp;lt;-&lt;/code&gt; 이 더 우선적으로 실행된다는 차이가 존재할 뿐이다.&lt;br /&gt;
예를 들어 &lt;code&gt;B&lt;/code&gt; 객체에 25 라는 값을 입력하고 &lt;code&gt;A&lt;/code&gt;에 &lt;code&gt;B&lt;/code&gt;를 입력하는 코드를 다음과 같이 작성하였다고 가정할 때 굳이 &lt;code&gt;&amp;lt;-&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt; 두개의 할당연산자를 혼용해 보았다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;A &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;B =&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;25&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;그런데 위의 코드가 정상적으로 동작할까?&lt;br /&gt;
그렇지 않다.&lt;/p&gt;
&lt;p&gt;왜냐하면 &lt;code&gt;=&lt;/code&gt; 보다 &lt;code&gt;&amp;lt;-&lt;/code&gt; 가 먼저 수행이 될 텐데 &lt;code&gt;B&lt;/code&gt; 객체에는 (R)세상에 존재하지도 않는 친구이다.&lt;br /&gt;
따라서 &lt;code&gt;A&lt;/code&gt; 에 할당시켜야 하는 값을 R은 알지 못하여 에러가 난다.&lt;/p&gt;
&lt;p&gt;B 가 25라는 값으로 먼저 할당되기 위하여 아래와 같은 방법들을 이용하게 될 것이다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;한 줄짜리 코드를 단락을 나누어 수행순서 강제 변경&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;B &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;25&lt;/span&gt;
A &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;B&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;괄호를 이용하여 수행순서 강제 변경&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;A &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;B =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;25&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;정말로 연산자의 우선순위를 고려한 코딩&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;A =&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;B &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;25&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;할당연산자를 통일시킴&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;A =&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;B =&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;25&lt;/span&gt;
A &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;B &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;25&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;음의정수값-연산이-생각대로-안되요.&quot;&gt;음의정수값 연산이 생각대로 안되요.&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;-&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;^&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] -100&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;-10 의 제곱은 100이지만,&lt;br /&gt;
위의 코드가 100이 반환되기를 기대한 순간 &lt;code&gt;?Syntax&lt;/code&gt; 를 다시 참고할 시간인 것이다.&lt;br /&gt;
나는 항상 100이 되길 기대하기 때문에 빈번히 &lt;code&gt;?Syntax&lt;/code&gt; 도움말을 조회한다. 🤧&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;-&lt;/code&gt;보다 &lt;code&gt;^&lt;/code&gt;이 먼저 수행되는 문제를 괄호를 통해 해결&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;(-&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;)^&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] 100&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;-10 의 값을 사전에 객체로 할당하고, 그 객체에 제곱을 취함&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;C &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;-&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;
C^&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] 100&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;seq2-20-by-2-를-연산자를-통하여-더-간단한-코드로-만들고-싶습니다.&quot;&gt;&lt;code&gt;seq(2, 20, by = 2)&lt;/code&gt; 를 &lt;code&gt;:&lt;/code&gt; 연산자를 통하여 더 간단한 코드로 만들고 싶습니다.&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;seq(2, 20, by = 2)&lt;/code&gt; 의 결과를 잘 살펴보면&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;seq&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;by =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##  [1]  2  4  6  8 10 12 14 16 18 20&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;1:10&lt;/code&gt; 의 모든 결과값에&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##  [1]  1  2  3  4  5  6  7  8  9 10&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2를 곱한 것과 같다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;)*&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##  [1]  2  4  6  8 10 12 14 16 18 20&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그런데 &lt;code&gt;(1:10)*2&lt;/code&gt; 의 코드가 가장 간단히 구현된 코드가 아니다.&lt;br /&gt;
습관적으로 &lt;code&gt;1:10&lt;/code&gt;이 먼저 수행되어야 한다는 생각에 괄호를 본능적으로 둘러싸게 되었는데,&lt;br /&gt;
그렇지 않더라도 &lt;code&gt;:&lt;/code&gt; 연산자는 &lt;code&gt;*&lt;/code&gt; 보다 우위에 있으므로 &lt;code&gt;1:10&lt;/code&gt; 을 먼저 계산 이후에 곱 연산 &lt;code&gt;*&lt;/code&gt; 을 수행한다.&lt;br /&gt;
따라서 괄호를 생략하고 아래와 같이 코드를 작성해도 된다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;*&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##  [1]  2  4  6  8 10 12 14 16 18 20&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이밖에도 연산자 우선순위에 대한 추가 예제는 &lt;code&gt;?Syntax&lt;/code&gt; 의 example code 에도 몇가지 훌륭한 것이 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;## Logical AND (&amp;quot;&amp;amp;&amp;amp;&amp;quot;) has higher precedence than OR (&amp;quot;||&amp;quot;):
&lt;span class=&quot;ot&quot;&gt;TRUE&lt;/span&gt; ||&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;TRUE&lt;/span&gt; &amp;amp;&amp;amp;&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;FALSE&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;# is the same as&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;TRUE&lt;/span&gt; ||&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;(&lt;span class=&quot;ot&quot;&gt;TRUE&lt;/span&gt; &amp;amp;&amp;amp;&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;FALSE&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# and different from&lt;/span&gt;
(&lt;span class=&quot;ot&quot;&gt;TRUE&lt;/span&gt; ||&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;TRUE&lt;/span&gt;) &amp;amp;&amp;amp;&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;FALSE&lt;/span&gt;

## Special operators have higher precedence than &amp;quot;!&amp;quot; (logical NOT).
## You can use this for %in% :
!&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; %in%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# same as !(1:10 %in% c(2, 3, 5, 7))&lt;/span&gt;
## but we strongly advise to use the &amp;quot;!( ... )&amp;quot; form in this case!


## &amp;#39;=&amp;#39; has lower precedence than &amp;#39;&amp;lt;-&amp;#39; ... so you should not mix them
##     (and &amp;#39;&amp;lt;-&amp;#39; is considered better style anyway):
## Consequently, this gives a (&amp;quot;non-catchable&amp;quot;) error
 x &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;y =&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;#-&amp;gt;  Error in (x &amp;lt;- y) = 5 : ....&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;사실 할당연산자 중 &lt;code&gt;-&amp;gt;&lt;/code&gt; 도 존재하지만 이는 아예 모르는게 약일수도 있다 생각된다. 그만큼 잘 쓰지 않지만 파이프 연산자 &lt;code&gt;%&amp;gt;%&lt;/code&gt; 와 종종 조화되어 사용되곤 한다.&lt;br /&gt;
&lt;code&gt;&amp;lt;&amp;lt;-&lt;/code&gt;, &lt;code&gt;-&amp;gt;&amp;gt;&lt;/code&gt; 와 같은 할당연산자도 있는데 상위환경에 대해 할당한다. 이 특성을 이용해 일반적으로 함수내 런타임환경(runtime environment)에서 전역환경(global environment)으로 지정하여 할당하는 것 외에는 일반적으로 사용하지 않는 특수한 할당연산자이다.&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Tue, 08 Sep 2015 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2015/09/08/OperatorR.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2015/09/08/OperatorR.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>Amazon Web Service 를 이용한 공동 사용 Rstudio Server 환경구축</title>
        <description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.louisaslett.com&quot; class=&quot;uri&quot;&gt;http://www.louisaslett.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Amazon Web Service (AWS) 를 이용하여 미리 구축된 Rstudio Server AMI&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; 를 배포해주는 &lt;a href=&quot;http://www.louisaslett.com/&quot;&gt;사이트&lt;/a&gt;가 있다.&lt;/p&gt;
&lt;p&gt;이 AMI를 이용해 직접 여러대의 Rstudio Server 를 손쉽게 구축시킬 수 있다.&lt;/p&gt;
&lt;p&gt;관련된 정보는 &lt;a href=&quot;https://www.youtube.com/watch?v=NQu3ugUkYTk&quot;&gt;아래링크&lt;/a&gt;를 통해 참고하여 알게 되었고 튜토리얼 형태로 이용할 수 있는 방법에 대한 영상까지 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=NQu3ugUkYTk&quot;&gt;출처 : Youtube (Brief guide about Rstudio Server&#39;s Web interface on AWS)&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;iframe width=&quot;100%&quot; height=&quot;400&quot; src=&quot;https://www.youtube.com/embed/NQu3ugUkYTk&quot; frameborder=&quot;0&quot; allowfullscreen&gt;
&lt;/iframe&gt;
&lt;p&gt;AWS 를 프리티어로 공짜로 이용하던 이전시절 이영상을 보고 그대로 따라하여 Rstudio Server 를 구축 시켜 봤었다.&lt;br /&gt;
등록되는 도메인을 통해 들어간 후&lt;/p&gt;
&lt;p&gt;&lt;em&gt;ID : rstudio&lt;/em&gt;&lt;br /&gt;
&lt;em&gt;P.W : rstudio&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;로 로그인하여 자유자재로 웹에서 사용할 수 있게 된다.&lt;br /&gt;
물론 초기 로그인시 아이디와 패스워드는 저렇지만 추후에 다른 패스워드로, 그리고 다른 아이디를 만들어 사용할 수도 있겠다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/AWSAMI-1.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;실질적으로 사용하고자 한다면 AWS EC2 사용 과금을 고려해야하며,&lt;br /&gt;
AWS 프리티어 계정기준 t2.micro 와 같은 최저 사양으로 인스턴스를 활성화 시킨다면&lt;br /&gt;
성능, 속도측면에서 기대하지 않는것이 좋을것이다.&lt;/p&gt;
&lt;p&gt;하지만 간편하게 원격으로 R 을 실행할 수도 있고, 소셜코딩이 가능할 수도 있겠으며 간편한 서버증설 등등의&lt;br /&gt;
유용하게 사용할 수 있는 방법은 무궁무진 할 것으로 생각된다.&lt;/p&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;&amp;quot;Amazon Machine Image&amp;quot; 의 약어로 어떤 소프트웨어나 환경설정을 이미지화 하여 그대로 재활용할 수 있는 스냅샷이다&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Wed, 25 Mar 2015 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2015/03/25/RstudioServer_using_AWSAMI.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2015/03/25/RstudioServer_using_AWSAMI.html</guid>
        
        
        <category>R</category>
        
      </item>
    
  </channel>
</rss>
