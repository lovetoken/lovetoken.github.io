<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description></description>
    <link>https://lovetoken.github.io/</link>
    <atom:link href="https://lovetoken.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 16 Apr 2017 19:52:22 +0900</pubDate>
    <lastBuildDate>Sun, 16 Apr 2017 19:52:22 +0900</lastBuildDate>
    <generator>Jekyll v3.1.6</generator>
    
      <item>
        <title>R에서 iteration 별 결과를 손쉽게 저장할 수 있는 replicate() 함수에 대해</title>
        <description>&lt;p&gt;R 에서 특정 코드를 반복해서 실행하는 방법은 for, while, repeat, apply 과 같은 반복문을 이용하면 간단히 구현할 수 있다.&lt;br /&gt;
그런데 만약 반복문의 주안점이 반복된 모든 결과들을 저장해야 한다는 것에 있다면 통상적인 반복문에선 조금 오묘한 방법을 통해 이를 구현한다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;for문을-이용한-주사위-100회-던지기&quot;&gt;for문을 이용한 주사위 100회 던지기&lt;/h2&gt;
&lt;p&gt;for 문을 이용한 간단한 예시 코드를 보면&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;res &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;()
for(i in &lt;span class=&quot;kw&quot;&gt;seq&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;)) res[i] &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;sample&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
res&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##   [1] 5 1 6 4 2 1 2 4 5 2 5 4 2 6 3 6 2 4 4 6 2 6 2 4 2 3 6 1 5 3 6 4 3 6 2
##  [36] 1 5 6 4 4 1 1 6 5 5 2 4 5 6 3 1 1 2 6 3 1 2 5 2 2 2 1 4 5 2 1 3 1 4 6
##  [71] 3 2 4 5 2 4 5 3 6 3 5 6 5 6 3 6 2 6 4 2 5 3 3 6 6 1 1 1 4 4&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 코드는 주사위를 100번 던져 나온 숫자들을 &lt;code&gt;res&lt;/code&gt; 라는 객체에 벡터형태로 저장하는 코드로 볼 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;apply를-이용한-주사위-100회-던지기&quot;&gt;&lt;code&gt;apply()&lt;/code&gt;를 이용한 주사위 100회 던지기&lt;/h2&gt;
&lt;p&gt;반복문 방식을 바꿔보겠다.&lt;br /&gt;
위 예시를 &lt;code&gt;apply()&lt;/code&gt; 를 이용해본 코드이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;res &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;apply&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;matrix&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;), &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, function(x) &lt;span class=&quot;kw&quot;&gt;sample&lt;/span&gt;(x, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;))
res&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##   [1] 6 2 1 1 6 5 4 3 5 3 5 1 6 3 3 1 4 4 6 2 3 2 2 1 1 4 2 4 1 4 3 4 5 6 4
##  [36] 4 5 3 6 3 1 1 1 6 4 1 2 2 4 3 5 2 3 3 4 6 4 4 2 5 4 5 1 6 3 1 1 4 3 1
##  [71] 6 4 4 2 1 6 1 1 3 2 6 5 2 4 4 3 2 2 4 5 6 1 4 1 1 3 4 1 3 2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;지금까지 예시로 든 두가지 방식의 코드는 한가지 공통점이 있다.&lt;br /&gt;
반복문의 내용이 무엇이 되었던 100번의 반복으로 인해 &lt;strong&gt;어떤 무엇인가가 100번 반환될 것이고, 이에 대한 저장공간을 사전에 생각하여 준비&lt;/strong&gt;해야 한다는 것 이다.&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;첫번째 for문 반복문 예제에선 100개의 값이 저장될 &lt;code&gt;res&lt;/code&gt; 라는 빈 벡터를 사전에 준비한 &lt;code&gt;res &amp;lt;- c()&lt;/code&gt; 코드가 눈에 띈다.&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;두번째 &lt;code&gt;apply()&lt;/code&gt; 예제에선 일괄함수적용을 위해 1, 2, 3, 4, 5, 6 의 벡터 100개가 열방향으로 bind 된 matrix 를 사전에 준비했고, 이에 대해 무작위로 추출하기 위한 &lt;code&gt;sample()&lt;/code&gt; 함수를 일괄 적용했다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이처럼 100회 반복의 모든 결과를 어딘가의 담아 두기 위한 사전 설계의 노력이 따로 필요하다.&lt;br /&gt;
분명 정석적으로 이러한 준비는 반드시 필요하며 틀린방법이라고 말할 수 없다.&lt;/p&gt;
&lt;p&gt;문제는 위의 예제처럼 간단한 코드가 아닌 복잡한 상황 일 때 사전준비 과정들은 곱절 높아질 수 있다는 것이다.&lt;br /&gt;
보통 복잡도는 지수적으로 늘어나기 때문에 이 오묘한 방법이 실전에서 코딩의 비효율로 일어날 수 있다고 생각한다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;replicate-함수-소개&quot;&gt;&lt;code&gt;replicate()&lt;/code&gt; 함수 소개&lt;/h2&gt;
&lt;p&gt;만약 복잡한 상황일 때,&lt;br /&gt;
위의 예제들의 로직을 그대로 가지고 있으되 사전준비의 부담을 덜 수 있는 함축된 함수가 있다고 생각하는데&lt;br /&gt;
바로 &lt;code&gt;replicate()&lt;/code&gt; 함수 이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;res &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;replicate&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;sample&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;))
res&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##   [1] 6 2 4 2 3 4 5 3 6 6 1 3 6 1 1 5 2 1 3 5 1 6 1 1 1 5 3 2 3 3 4 3 6 1 5
##  [36] 6 4 1 4 4 3 5 1 2 2 2 4 4 5 3 4 6 5 3 6 6 1 6 5 4 3 6 1 4 3 3 5 4 2 4
##  [71] 6 6 2 5 5 4 4 4 5 4 2 4 4 1 5 2 4 6 5 4 2 2 3 2 6 6 1 5 1 4&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;replicate()&lt;/code&gt; 함수는 반복문의 내용(expr)을 두번째 인자에 부여하고 첫번째 인자에 반복회수를 넣어줌으로써 반복 실행된 코드의 결과를 벡터형태로 반환시켜주는 편리한 함수이다.&lt;br /&gt;
사전준비에 대한 로직을 &lt;code&gt;replicate()&lt;/code&gt; 함수가 대신해준다.&lt;br /&gt;
따라서 코드길이도 확실히 줄일 수 있게 된다.&lt;/p&gt;
</description>
        <pubDate>Sun, 16 Apr 2017 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2017/04/16/replicate_function.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2017/04/16/replicate_function.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>R에서 RImpala 패키지를 이용해 Impala 커넥션 맺기 (with Docker)</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://www.cloudera.com/documentation/enterprise/5-8-x/topics/impala.html&quot;&gt;Impala&lt;/a&gt; 라는걸 사용해 봐야 할 일이 생겼다.&lt;br /&gt;
필자는 Hadoop, SQL 과 같은 기술이 상당히 낯설고 두려움이 있었는데 Impala 를 통해 조금씩 알게 되는 계기가 되었으면 좋겠다.&lt;/p&gt;
&lt;p&gt;Impala 는 아파치 프로젝트에 incubating 단계로 관리되고 있는 프로젝트로써&lt;br /&gt;
HDFS(Hadoop Distributed File System) 안에 있는 데이터를 SQL 을 통해 실시간으로(대화형으로) 분석할 수 있게 도와주는 시스템이라고 한다.&lt;br /&gt;
HDFS 를 이용하기 위해선 MapReduce 프레임워크를 알고 이용했어야 한다는 불편한 제약을 Impala 를 통해 벗어날 수 있다 이해할 수 있겠다.&lt;/p&gt;
&lt;p&gt;Impala 소개는 이쯤 하고 (&lt;del&gt;읔.. 알고있는게 이정도 뿐이다 😅;;&lt;/del&gt;) 여하튼 지금은 &lt;a href=&quot;https://www.docker.com/&quot;&gt;Docker&lt;/a&gt; 을 통해 Impala 를 간단히 구동시켜보고,&lt;br /&gt;
RImpala package 를 이용해 R 상에서 Impala 와 커넥션을 맺는데 성공했던 과정을 짤막하게 정리하고 적어보고자 한다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;ready-impala&quot;&gt;Ready impala&lt;/h2&gt;
&lt;p&gt;Impala 이용 전 &lt;code&gt;.jar&lt;/code&gt; 리소스들을 준비해야 한다고 한다.&lt;br /&gt;
아래 R 코드를 통해 다운로드 및 워킹디렉토리에 압축해제가 가능하다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;download.file&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;https://github.com/Mu-Sigma/RImpala/blob/master/impala-jdbc-cdh5.zip?raw=true&amp;quot;&lt;/span&gt;, 
              &lt;span class=&quot;st&quot;&gt;&amp;quot;jdbc.zip&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;method =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;curl&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;extra =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;-L&amp;quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;unzip&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;jdbc.zip&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;docker-images-ready&quot;&gt;Docker images ready&lt;/h2&gt;
&lt;p&gt;그다음 터미널을 들어가 Docker 를 구동할 준비를 한다.&lt;br /&gt;
여기서 Docker 를 이용하려는 이유를 언급해야 할 것 같은데&lt;br /&gt;
Impala 를 이용하기 위해선 Hadoop 시스템이 사전에 준비되어야 하고, JDBC 를 위한 Java 설정등 다양한 준비(Requirements)가 매우 부담되기 때문이다.&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;br /&gt;
이러한 이유로 나는 Docker 를 이용해 누군가 개발해 놓은, 사전에 잘 구축한 환경을 사용하고자 하기 때문에&lt;br /&gt;
Docker 구동을 위해 boot2docker 를 시작했다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;boot2docker&lt;/span&gt; init
$ &lt;span class=&quot;kw&quot;&gt;boot2docker&lt;/span&gt; up
$ &lt;span class=&quot;kw&quot;&gt;boot2docker&lt;/span&gt; ssh&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;boot2docker ssh&lt;/code&gt; 를 통해 docker 가상머신에 접속 후 &amp;quot;Impala&amp;quot; 를 검색어로 적당한 이미지를 찾아본다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;docker@boot2docker&lt;/span&gt;:~$ docker search impala&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;NAME                                DESCRIPTION                                     STARS
cloudera/impala-dev                 Impala development environment                  10
codingtony/impala                                                                   5
rooneyp1976/impala                  Impala 2.0.1 on Ubuntu 14.04 Image (fork o...   4
lancope/impala-shell                                                                1
yanlinw/docker-impala               impala 2.0.1 + sqoop + sql server driver        0
mikefaille/ubuntu-impala            Description                                     0
galloplabs/hadoop-cdh-impala                                                        0
yanlinw/docker-impala-sqoop         impala sqoop2                                   0
cpcloud86/impala                                                                    0
damsl/impala                                                                        0
joshdub223/impala                                                                   0
aurele/shiny4saagie-impala          Form that reads/writes from Impala on Saagie    0
sebastianmontero/impala                                                             0
datadudes/impala-rest-api           Simple rest API for Impala                      0
andreysabitov/impala-kudu                                                           0
... [이하 생략]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;여러 가지가 이미지가 준비되어 있는데 그중 개인적으론 &amp;quot;cloudera/impala-dev&amp;quot; 보단 &amp;quot;codingtony/impala&amp;quot; 가 바로 사용하기 좋았다.&lt;br /&gt;
&amp;quot;codingtony/impala&amp;quot; 이미지를 준비 내려받았다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;docker@boot2docker&lt;/span&gt;:~$ docker pull codingtony/impala&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1.4GB 정도가 다운로드 되는데 시간이 조금 소요된다.&lt;br /&gt;
다운로드 이후 image 가 잘 준비되어 있는지 &lt;code&gt;docker images&lt;/code&gt; 를 통해 확인할 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;docker@boot2docker&lt;/span&gt;:~$ docker images&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
codingtony/impala   latest              24f0d50712cf        2 years ago         1.452 GB&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;다음을 통해 준비한 Impala 이미지를 컨테이너로 실행시킨다.&lt;a href=&quot;#fn2&quot; class=&quot;footnoteRef&quot; id=&quot;fnref2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;docker@boot2docker&lt;/span&gt;:~$ docker run -d --name &lt;span class=&quot;st&quot;&gt;&amp;quot;impala&amp;quot;&lt;/span&gt; -p 9000:9000 -p 50010:50010 -p 50020:50020 -p 50070:50070 -p 50075:50075 -p 21000:21000 -p 21050:21050 -p 25000:25000 -p 25010:25010 -p 25020:25020 codingtony/impala&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;참고로 &lt;code&gt;docker run&lt;/code&gt; 의 다양한 옵션들 중 &lt;code&gt;-d,&lt;/code&gt; &lt;code&gt;--name&lt;/code&gt; 은 각각&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-d&lt;/code&gt; : background 프로세스로 실행해 놓겠다는 의미&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--name &amp;quot;impala&amp;quot;&lt;/code&gt; : image 이름의 alias 를 부여, 예를 들어 본 컨테이너에 접근하기 위해선 &amp;quot;codingtony/impala&amp;quot; 의 이름을 다 입력해야 하는데 앞으론 &amp;quot;impala&amp;quot; 라는 이름으로 접근 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;의 의미를 가지고 있다.&lt;br /&gt;
참고로 Impala 컨테이너가 백그라운드로 잘 실행되는 상태인지 확인을 위해선 &lt;code&gt;docker ps&lt;/code&gt; 명령어로 프로세스 확인할 수 있다.&lt;br /&gt;
프로세스가 잘 돌고 있는 것을 확인했다면&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;docker@boot2docker&lt;/span&gt;:~$ docker exec -it impala /bin/bash&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;를 통해 Impala 컨테이너의 bash 셸을 열어 입력/출력이 가능하도록 사용할 수 있고&lt;br /&gt;
&lt;code&gt;impala-shell&lt;/code&gt; 를 실행해 대화형 쿼리를 주고받을 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@cb4ba4d0f902:/# impala-shell

Starting Impala Shell without Kerberos authentication
Connected to cb4ba4d0f902:21000
Server version: impalad version 1.4.2-cdh5 RELEASE (build eac952d4ff674663ec3834778c2b981b252aec78)
Welcome to the Impala shell. Press TAB twice to see a list of available commands.

Copyright (c) 2012 Cloudera, Inc. All rights reserved.

(Shell build version: Impala Shell v1.4.2-cdh5 (eac952d) built on Tue Sep 16 19:15:40 PDT 2014)
[cb4ba4d0f902:21000] &amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;rimpala-package-이용한-로컬에서의-impala-제어&quot;&gt;RImpala package 이용한 로컬에서의 impala 제어&lt;/h2&gt;
&lt;h3 id=&quot;docker-vm-ip-확인&quot;&gt;Docker VM IP 확인&lt;/h3&gt;
&lt;p&gt;로컬 상에서 RImpala package 이용한 로컬 상의 제어를 위해 docker ip 를 확인할 필요가 있다.&lt;br /&gt;
이는 &lt;code&gt;boot2docker ip&lt;/code&gt; 를 통해 쉽게 확인 가능하다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;boot2docker&lt;/span&gt; ip&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;예를 들어 &amp;quot;192.168.59.103&amp;quot; 임을 위의 커멘드를 통해 확인했다고 가정하겠다.&lt;/p&gt;
&lt;h3 id=&quot;r상에-rimpala-패키지를-이용한-커넥션&quot;&gt;R상에 RImpala 패키지를 이용한 커넥션&lt;/h3&gt;
&lt;p&gt;R로 되돌아오자.&lt;br /&gt;
먼저 &lt;code&gt;.jar&lt;/code&gt; 들을 다운받은 디렉토리 path를 &lt;code&gt;rimpala.init()&lt;/code&gt; 함수에 입력한 코드를 먼저 실행하고,&lt;br /&gt;
docker 가상환경의 ip, 그리고 Impala JDBC/ODBC 기본값 포트번호 (21050) 를 &lt;code&gt;rimpala.connect()&lt;/code&gt; 에 입력한 코드를 그다음으로 실행하면 &lt;code&gt;TRUE&lt;/code&gt; 가 반기면 커넥션이 성공한 것이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(RImpala)

&lt;span class=&quot;kw&quot;&gt;rimpala.init&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;libs =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;impala-jdbc-cdh5&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;Classpath added successfully&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;rimpala.connect&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;IP =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;192.168.59.103&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;port =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;21050&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;use-databases&quot;&gt;Use databases&lt;/h3&gt;
&lt;p&gt;자 이제 즐기면(?) 되겠다. database 가 무엇이 있는지 확인부터 해보자.&lt;br /&gt;
&lt;code&gt;show databases;&lt;/code&gt; 쿼리를 날려보는 건 &lt;code&gt;rimpala.showdatabases()&lt;/code&gt; 을 실행하는 것과 같다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;rimpala.showdatabases&lt;/span&gt;()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##               name
## 1 _impala_builtins
## 2          default&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;쿼리문 자체를 이용하고자 한다면 &lt;code&gt;rimpala.query()&lt;/code&gt; 함수를 이용하면 된다.&lt;br /&gt;
단 쿼리문 마지막에 세미콜론(;)은 넣지 않아야 에러가 나지 않았다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;rimpala.query&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;show databases&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##               name
## 1 _impala_builtins
## 2          default&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;사용할 데이터베이스 선택을 해보자.&lt;br /&gt;
&amp;quot;default&amp;quot; database 를 사용하려한다면&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;rimpala.usedatabase&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;default&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;를 하면된다. &lt;code&gt;use default;&lt;/code&gt; 쿼리와 같다.&lt;/p&gt;
&lt;h3 id=&quot;send-query-test&quot;&gt;Send query test&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;tryCatch&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;rimpala.query&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;drop table sample&amp;quot;&lt;/span&gt;), &lt;span class=&quot;dt&quot;&gt;error =&lt;/span&gt; function(e){})&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## NULL&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;tryCatch&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;rimpala.query&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;create table sample(no integer)&amp;quot;&lt;/span&gt;), &lt;span class=&quot;dt&quot;&gt;error =&lt;/span&gt; function(e){})&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## NULL&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;tryCatch&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;rimpala.query&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;insert into sample (no) values (1)&amp;quot;&lt;/span&gt;), &lt;span class=&quot;dt&quot;&gt;error =&lt;/span&gt; function(e){})&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## NULL&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;data &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;rimpala.query&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;select * from sample&amp;quot;&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# output value is data.frame class&lt;/span&gt;
data&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##   no
## 1  1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;rimpala.query()&lt;/code&gt; 함수로 쿼리를 보낼 때 에러를 많이 반환했다.&lt;br /&gt;
하지만 이상하게도 R상에선 에러를 뿜었으나 쿼리가 Impala 에 잘 먹혔다.&lt;br /&gt;
이 때문에 임시방편으로 &lt;code&gt;tryCatch()&lt;/code&gt; 를 통해 예외처리를 했다.&lt;br /&gt;
다만 데이터를 끌어오는데는 쿼리는 문제없이 잘 실행됬다.&lt;/p&gt;
&lt;h3 id=&quot;close-connect-impala&quot;&gt;close connect impala&lt;/h3&gt;
&lt;p&gt;커넥션은 &lt;code&gt;rimpala.close()&lt;/code&gt; 로 끊을 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;rimpala.close&lt;/span&gt;()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.cloudera.com/blog/2013/12/how-to-do-statistical-analysis-with-impala-and-r/&quot;&gt;How-to: Do Statistical Analysis with Impala and R&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://d2.naver.com/helloworld/246342&quot;&gt;Naver D2 - Hadoop에서의 실시간 SQL 질의: Impala&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/codingtony/docker-impala&quot;&gt;Github Readme (codingtony/docker-impala)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;Cloudera 에서 &lt;a href=&quot;https://www.cloudera.com/documentation/enterprise/5-9-x/topics/impala_prereqs.html&quot;&gt;Impala install 페이지&lt;/a&gt;를 보고 지레 겁먹어서 그렇기도 하다&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn2&quot;&gt;&lt;p&gt;&lt;code&gt;docker pull&lt;/code&gt; 과정 없이 바로 &lt;code&gt;docker run&lt;/code&gt; 을 해도 된다. 무슨말이냐면 사실 &lt;code&gt;docker run&lt;/code&gt; 은 이미지가 없을 경우 자동으로 이미지를 다운로드 하기 때문이다&lt;a href=&quot;#fnref2&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Tue, 21 Mar 2017 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2017/03/21/RImpala_package.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2017/03/21/RImpala_package.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>인터넷 접속이 불가능 한 내부망에서의 R package 설치방법에 대해</title>
        <description>&lt;p&gt;(지금은 그렇지 않은데) 이전에 일하던 환경이 망분리(내부망)의 도입으로 인하여&lt;br /&gt;
인터넷이 불가능한 상황에서 R을 이용해 분석을 해야 했던 적이 있었다.&lt;br /&gt;
특히 보안으로 인한 법 개정인지 몰라도 망분리 도입이 공기업을 시작으로 활발하게 진행하는 듯 싶은데,&lt;br /&gt;
이로인한 많은 이슈를 대응해야 하는 사람들 입장에선 많이 피곤할 것으로 생각한다.&lt;/p&gt;
&lt;p&gt;오픈소스 도구 특성상 대부분이 그렇겠지만, 인터넷의 의존도는 높을 것이다.&lt;br /&gt;
그중 하나인 R 언어 역시 마찬가지다.&lt;br /&gt;
R 패키지의 설치는 기본적으론 &lt;a href=&quot;https://cran.r-project.org/&quot;&gt;CRAN&lt;/a&gt; 을 통해 패키지 리소스들을 요청하고 다운로드 하는데 이것이 불가해진다.&lt;br /&gt;
그렇다고 패키지 설치가 아예 불가능한 것은 아닌데, 문제는 R을 이용하는 클라이언트 입장에서 매우 불편을 느끼게 된다는 것이 문제다.&lt;br /&gt;
R을 잘 알고 사용하는 사람이라면 방법이 어찌 되었건 간에 패키지 리소스를 로컬상으로 옮겨서 이슈를 해결하지만, 수동적으로 R 을 분석을 위해서 단편적으로 이용하시는 분들 입장에선 어디까지나 해괴망측한 에러 중 하나로 판단할 것이 당연하다.&lt;br /&gt;
클라이언트 입장에서 가장 간단한 패키지 설치 방법을 PPT로 제작해 보았다.&lt;/p&gt;
&lt;iframe src=&quot;https://lovetoken.github.io/assets/assets/player/KeynoteDHTMLPlayer.html#0&quot; width=&quot;100%&quot; height=&quot;500px&quot;&gt;
&lt;/iframe&gt;
&lt;p&gt;준비한 슬라이드 쇼에는 가장 간단한 패키지 수동설치법에 대해서&lt;br /&gt;
5page 로 축약하여 설명을 해 놓았다.&lt;/p&gt;
&lt;p&gt;망분리란 고립된(?) 환경을 체험 중인 분들에게&lt;br /&gt;
그나마 해갈이 될 수 있도록 도움이 되었으면 좋겠다 😢&lt;/p&gt;
</description>
        <pubDate>Sun, 05 Mar 2017 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2017/03/05/Rpackage_install_in.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2017/03/05/Rpackage_install_in.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>R에서 의미가 있었던 프로파일링 모음</title>
        <description>&lt;p&gt;훌륭한진 못해도 좋은 개발을 하고 싶다는 생각이 많이 든다.&lt;br /&gt;
좋은 코드를 짜기 위해 노력중이다.&lt;br /&gt;
좋은 코드에 필요한 요소들은 여러가지가 있겠지만, 지금 가장 큰 흥미를 가지고 관심가지는 것은 효율성이다.&lt;br /&gt;
효율성에서도 여러 가지 측면이 있겠지만 코드수행시간에 특히 민감해 하고 있다.&lt;br /&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Profiling_(computer_programming)&quot;&gt;Profiling&lt;/a&gt; 을 통해 이런저런 실험들을 해보고 있고, 그 중 나름 유의미했던 실험들을 정리해 보고자 한다.&lt;/p&gt;
&lt;p&gt;프로파일링에 사용한 도구는 rbenchmark package 의 &lt;code&gt;benchmark()&lt;/code&gt; 함수로 통일 하였고, 대조군 코드를 통해 비교적 쉽게 받아들일 수 있도록 작성해 보았다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;lapply-vs-parallelmclapply&quot;&gt;&lt;code&gt;lapply()&lt;/code&gt; VS &lt;code&gt;parallel::mclapply()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&amp;quot;parallel&amp;quot; package 에 있는 &lt;code&gt;mclapply()&lt;/code&gt; 함수는 &lt;code&gt;lapply()&lt;/code&gt; 함수와 기능이 똑같다.&lt;br /&gt;
다만 &lt;code&gt;mc.cores&lt;/code&gt; 인자를 가지고 있고 멀티코어 개수를 지정하여 병렬처리를 간편하게 수행할 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(parallel)

&lt;span class=&quot;kw&quot;&gt;benchmark&lt;/span&gt;(
  &lt;span class=&quot;kw&quot;&gt;lapply&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1000&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;9999&lt;/span&gt;, rnorm),
  &lt;span class=&quot;kw&quot;&gt;mclapply&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1000&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;9999&lt;/span&gt;, rnorm, &lt;span class=&quot;dt&quot;&gt;mc.cores =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;)
)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;                                 test replications elapsed relative 
2 mclapply(1000:9999, rnorm, mc.c ...          100 289.162    1.000 
1                 lapply(1000:999 ...          100 464.604    1.607 &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위의 실험은 표준정규분포에서 난수발생을 1000번부터 9999번까지 수행하는 것을 100번&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; 반복시킨 후 수행시간을 평가하는 코드이다.&lt;br /&gt;
&lt;code&gt;mclapply()&lt;/code&gt; 함수로 실행한 결과가 평균 289초, &lt;code&gt;lapply()&lt;/code&gt; 함수로 실행한 결과가 평균 464초 걸렸고 상대적으로 &lt;code&gt;lapply()&lt;/code&gt; 를 사용한 코드가 &lt;code&gt;mclapply()&lt;/code&gt; 로 사용한 코드보다 1.607배 많은 시간이 소요됨을 알 수 있다.&lt;/p&gt;
&lt;p&gt;반면에 난수발생을 적게 시킬 경우 &lt;code&gt;mclapply()&lt;/code&gt; 는 &lt;code&gt;lapply()&lt;/code&gt; 보다 멍청해(?) 지는 것을 볼 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;benchmark&lt;/span&gt;(
  &lt;span class=&quot;kw&quot;&gt;lapply&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;99&lt;/span&gt;, rnorm),
  &lt;span class=&quot;kw&quot;&gt;mclapply&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;99&lt;/span&gt;, rnorm, &lt;span class=&quot;dt&quot;&gt;mc.cores =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;)
)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##                              test replications elapsed relative 
## 1                 lapply(10:9 ...          100   0.118    1.000 
## 2 mclapply(10:99, rnorm, mc.c ...          100   1.994   16.898 &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;filtering-data.table-data.frame-dplyrfilter&quot;&gt;Filtering data.table, data.frame + &lt;code&gt;dplyr::filter()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;이번에 수행한 프로파일링은 &lt;a href=&quot;http://using.tistory.com/81&quot;&gt;빵군님의 블로그 글&lt;/a&gt;을 보다가 추가로 생긴 궁금증에 몇 개를 더 추가해 본 경우이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(data.table)
&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(dplyr)

DF &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;data.frame&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;x =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;runif&lt;/span&gt;(&lt;span class=&quot;fl&quot;&gt;2.6e+07&lt;/span&gt;), &lt;span class=&quot;dt&quot;&gt;y =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;rep&lt;/span&gt;(LETTERS, &lt;span class=&quot;dt&quot;&gt;each =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10000&lt;/span&gt;))

DT &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;as.data.table&lt;/span&gt;(DF)
&lt;span class=&quot;kw&quot;&gt;setkey&lt;/span&gt;(DT, y) 

&lt;span class=&quot;kw&quot;&gt;benchmark&lt;/span&gt;(
  DF[DF$y ==&lt;span class=&quot;st&quot;&gt; &amp;quot;D&amp;quot;&lt;/span&gt;, ],
  DT[&lt;span class=&quot;kw&quot;&gt;J&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;D&amp;quot;&lt;/span&gt;), ],
  DF %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;dplyr::&lt;span class=&quot;kw&quot;&gt;filter&lt;/span&gt;(y ==&lt;span class=&quot;st&quot;&gt; &amp;quot;D&amp;quot;&lt;/span&gt;),
  DT %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;dplyr::&lt;span class=&quot;kw&quot;&gt;filter&lt;/span&gt;(y ==&lt;span class=&quot;st&quot;&gt; &amp;quot;D&amp;quot;&lt;/span&gt;)
)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##                             test replications elapsed relative
## 2                   DT[J(&amp;quot;D&amp;quot;), ]          100   2.500    1.000
## 4 DT %&amp;gt;% dplyr::filter(y == &amp;quot;D&amp;quot;)          100  23.083    9.233
## 3 DF %&amp;gt;% dplyr::filter(y == &amp;quot;D&amp;quot;)          100  23.248    9.299
## 1              DF[DF$y == &amp;quot;D&amp;quot;, ]          100  38.298   15.319&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;비교대상은 4가지이다.&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;code&gt;data.frame&lt;/code&gt; 형에서 필터링&lt;/li&gt;
&lt;li&gt;&lt;code&gt;data.table&lt;/code&gt; 형에서 필터링&lt;/li&gt;
&lt;li&gt;&lt;code&gt;data.frame&lt;/code&gt; 형에서 &lt;code&gt;dplyr::filter()&lt;/code&gt; 를 이용한 필터링&lt;/li&gt;
&lt;li&gt;&lt;code&gt;data.table&lt;/code&gt; 형에서 &lt;code&gt;dplyr::filter()&lt;/code&gt; 를 이용한 필터링&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;결과는 J표현식을 사용한 data.table 이 가장 우월하다는 것을 볼 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;sqldf-package-를-통해-join-작업을-하다가-생긴-의문&quot;&gt;sqldf package 를 통해 Join 작업을 하다가 생긴 의문&lt;/h2&gt;
&lt;p&gt;R에서 SQL 문을 통해 data.frame 형을 처리하기 위한 대표적인 패키지가 &lt;a href=&quot;https://cran.r-project.org/web/packages/sqldf/index.html&quot;&gt;sqldf&lt;/a&gt; 이지 않을까?&lt;br /&gt;
필요에 따라서 R에서 SQL 을 통해 data.frame 을 핸들링 하는 확장성을 이용할 수 있다.&lt;/p&gt;
&lt;p&gt;하지만 문득 이런 생각이 드는 것도 사실이다.&lt;br /&gt;
R에서 굳이 다른 문법(SQL)을 이용하는 것은&lt;br /&gt;
영국 가서 미국발음으로 영어하고, 미국 가서 영국발음으로 영어 하는 것으로 비유해 보고 싶다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;merge()&lt;/code&gt;, &lt;code&gt;dplyr::left_join()&lt;/code&gt;, &lt;code&gt;sqldf()&lt;/code&gt; 3가지 함수를 통해 left join 을 하는 예제로 프로파일링을 해보았는데&lt;br /&gt;
그 이후 SQL 문법을 불필요하게 남용하지 않아야 겠다는 생각을 가졌다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(sqldf)
&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(dplyr)

df1 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;data.frame&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;Key =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;), 
                  &lt;span class=&quot;dt&quot;&gt;Var1 =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;a&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;b&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;c&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;c&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;b&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;c&amp;quot;&lt;/span&gt;), &lt;span class=&quot;dt&quot;&gt;stringsAsFactors =&lt;/span&gt; F)
df2 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;data.frame&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;Key =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;), 
                  &lt;span class=&quot;dt&quot;&gt;Var2 =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;x&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;y&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;z&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;xx&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;yy&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;zz&amp;quot;&lt;/span&gt;), &lt;span class=&quot;dt&quot;&gt;stringsAsFactors =&lt;/span&gt; F)

&lt;span class=&quot;kw&quot;&gt;benchmark&lt;/span&gt;(
  df1 %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;merge&lt;/span&gt;(df2, &lt;span class=&quot;dt&quot;&gt;by =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;Key&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;all.x =&lt;/span&gt; T),
  df1 %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;dplyr::&lt;span class=&quot;kw&quot;&gt;left_join&lt;/span&gt;(df2, &lt;span class=&quot;dt&quot;&gt;by =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;Key&amp;quot;&lt;/span&gt;),
  &lt;span class=&quot;kw&quot;&gt;sqldf&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;SELECT df1.Key, Var1, Var2 FROM df1 LEFT JOIN df2 on df1.Key=df2.Key&amp;quot;&lt;/span&gt;)
)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##                                                 test replications elapsed relative 
## 2                                     df1 %&amp;gt;% dp ...          100   0.033    1.000 
## 1                                     df1 %&amp;gt;% me ...          100   0.089    2.697 
## 3 sqldf(&amp;quot;SELECT df1.Key, Var1, Var2 FROM df1 LEF ...          100   2.361   71.545 &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;sqldf()&lt;/code&gt; 을 통한 join 이 다른방법보다 71배 더 오래걸려 비교적 느림을 알 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;output&quot;&gt;Output&lt;/h2&gt;
&lt;p&gt;위의 SQL 프로파일링과도 이어지는 컨셉이다.&lt;br /&gt;
냉면으로 유명한 집에서 국수를 먹고, 국수가 유명한 집에서 밥을 먹지 않는 것 처럼&lt;br /&gt;
각 언어의 특색에 맞는 장점들을 충분히 이용하는것이 합리적이라 생각한다.&lt;/p&gt;
&lt;p&gt;이번 프로파일링도 비슷하다.&lt;br /&gt;
R에서 처리된 결과물을 R object 이미지로(.rda)로 저장하는것과 .csv 포맷으로 저장하는 것을 비교해 보았다.&lt;br /&gt;
(R에서 처리된 결과물의 예제를 &lt;code&gt;mtcars&lt;/code&gt; 내장데이터로 가정해보겠다)&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;benchmark&lt;/span&gt;(
  &lt;span class=&quot;kw&quot;&gt;save&lt;/span&gt;(mtcars, &lt;span class=&quot;dt&quot;&gt;file =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;mtcars.rda&amp;quot;&lt;/span&gt;),
  &lt;span class=&quot;kw&quot;&gt;write.csv&lt;/span&gt;(mtcars, &lt;span class=&quot;dt&quot;&gt;file =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;mtcars.csv&amp;quot;&lt;/span&gt;)
)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##                                     test replications elapsed relative
## 1      save(mtcars, file = &amp;quot;mtcars.rda&amp;quot;)          100   0.054    1.000
## 2 write.csv(mtcars, file = &amp;quot;mtcars.csv&amp;quot;)          100   0.116    2.148&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;결과는 .rda 로 객체이미지를 저장시키는 것이 2배 빠른 것을 볼 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;역행렬-계산시-특이값-분해singular-value-decomposition-이용&quot;&gt;역행렬 계산시 특이값 분해(Singular value decomposition) 이용&lt;/h2&gt;
&lt;p&gt;(정방)행렬의 차원이 크면 클수록 역행렬을 계산할 때 컴퓨터가 힘들어 한다.&lt;br /&gt;
조금이라도 빠르게 계산할 수 있는 방법이 없을까 고민하다가 특이값 분해(SVD) 를 알게된 이후로 조금 개선된 방법을 찾게 되었다.&lt;/p&gt;
&lt;p&gt;SVD 를 아주 간단하게 설명하면 행렬&lt;a href=&quot;#fn2&quot; class=&quot;footnoteRef&quot; id=&quot;fnref2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;X&lt;/em&gt;&lt;/span&gt; 를 대각행렬 &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;D&lt;/em&gt;&lt;/span&gt; 를 중앙으로 하고 3개의 행렬곱으로 나누어 준다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;span class=&quot;math display&quot;&gt;&lt;em&gt;X&lt;/em&gt; = &lt;em&gt;U&lt;/em&gt;&lt;em&gt;D&lt;/em&gt;&lt;em&gt;V&lt;/em&gt;&lt;sup&gt;&lt;em&gt;T&lt;/em&gt;&lt;/sup&gt;&lt;/span&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;그리고 이렇게 분해된 행렬곱을 변환하면&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;span class=&quot;math display&quot;&gt;&lt;em&gt;X&lt;/em&gt;&lt;sup&gt;−1&lt;/sup&gt; = &lt;em&gt;V&lt;/em&gt;&lt;em&gt;D&lt;/em&gt;&lt;sup&gt;−1&lt;/sup&gt;&lt;em&gt;U&lt;/em&gt;&lt;sup&gt;&lt;em&gt;T&lt;/em&gt;&lt;/sup&gt;&lt;/span&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;이 되는 특성을 가지고 있다.&lt;br /&gt;
컴퓨터 입장에선 복잡한 &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;X&lt;/em&gt;&lt;/span&gt;를 바로 역행렬 계산하는 것 보다, 부담이 적은 단위행렬 &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;D&lt;/em&gt;&lt;/span&gt;를 역행렬 계산하는것을 쉬워할 것이다.&lt;br /&gt;
이러한 특성을 이용한 것이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;m &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;matrix&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;rnorm&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1000&lt;/span&gt;^&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;), &lt;span class=&quot;dv&quot;&gt;1000&lt;/span&gt;)
svd &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;svd&lt;/span&gt;(m)

&lt;span class=&quot;kw&quot;&gt;benchmark&lt;/span&gt;(
  &lt;span class=&quot;kw&quot;&gt;solve&lt;/span&gt;(m),
  svd$v %*%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;solve&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;diag&lt;/span&gt;(svd$d)) %*%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;t&lt;/span&gt;(svd$u)
)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##                                        test replications elapsed relative
## 1                                  solve(m)          100 238.183    1.194
## 2 svd$v %*% solve(diag(svd$d)) %*% t(svd$u)          100 199.452    1.000&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;SVD로 나눈 행렬을 이용해 역행렬 &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;X&lt;/em&gt;&lt;sup&gt;−1&lt;/sup&gt;&lt;/span&gt; 을 구하는것이 조금 빠른것을 볼 수 있다.&lt;br /&gt;
상대적으로 볼 때 별차이가 없어 보일수도 있지만 행렬의 차원이 크면 클수록 절대소요시간차이는 엄청날 것이다.&lt;/p&gt;
&lt;p&gt;그런데 여기서 반론을 제기할 수 있다.&lt;br /&gt;
바로 특이값 분해시 코드수행속도도 포함시켜야 하지 않느냐 이다.&lt;br /&gt;
즉 엄밀히 말하면 &lt;code&gt;svd &amp;lt;- svd(m)&lt;/code&gt; 코드 수행시간도 더해주어야 할 것이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;system.time&lt;/span&gt;(svd &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;svd&lt;/span&gt;(m))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##   user  system elapsed 
##  4.101   0.047   4.202 &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;하지만 4초내외로 특이값분해는 의외로 많은 시간이 걸리지 않는다.&lt;br /&gt;
이 4초 내외를 더해보았자 대세에 지장이 없는 수준이다.&lt;br /&gt;
게다가 &lt;code&gt;svd()&lt;/code&gt; 말고도 이보다 더 빠르게 특이값 분해를 할 수 있는 방법&lt;a href=&quot;#fn3&quot; class=&quot;footnoteRef&quot; id=&quot;fnref3&quot;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;들도 있으니 참고해 볼만하다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;to-be-continued&quot;&gt;To be continued&lt;/h2&gt;
&lt;p&gt;의미 있는 프로파일링이 다음에 또 생기면 이어서 덧붙여질 예정이다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;프로파일링에-사용했던-동작환경&quot;&gt;프로파일링에 사용했던 동작환경&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;sessionInfo&lt;/span&gt;()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## R version 3.3.1 (2016-06-21)
## Platform: x86_64-apple-darwin13.4.0 (64-bit)
## Running under: OS X 10.12.3 (Sierra)
## 
## locale:
## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8
## 
## attached base packages:
## [1] parallel  stats     grDevices utils     datasets  graphics  methods  
## [8] base     
## 
## other attached packages:
## [1] rbenchmark_1.0.0            data.table_1.10.4          
## [3] ggplot2_2.2.1               dplyr_0.5.0                
## [5] knitr_1.15.1                useful.lovetoken_0.1.0.0090
## 
## loaded via a namespace (and not attached):
##  [1] Rcpp_0.12.9      magrittr_1.5     munsell_0.4.3    colorspace_1.3-2
##  [5] R6_2.2.0         stringr_1.2.0    plyr_1.8.4       tools_3.3.1     
##  [9] grid_3.3.1       gtable_0.2.0     pacman_0.4.1     DBI_0.5-1       
## [13] htmltools_0.3.5  yaml_2.1.14      lazyeval_0.2.0   assertthat_0.1  
## [17] digest_0.6.12    rprojroot_1.2    tibble_1.2       evaluate_0.10   
## [21] rmarkdown_1.3    stringi_1.1.2    scales_0.4.1     backports_1.0.5&lt;/code&gt;&lt;/pre&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;&lt;code&gt;benchmark()&lt;/code&gt; 함수에서 &lt;code&gt;replications&lt;/code&gt; 인자를 통해 조정이 가능하며, 디폴트 값이 100이다&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn2&quot;&gt;&lt;p&gt;이때 행렬은 정방행렬이 아니어도 특이값 분해가 가능하다&lt;a href=&quot;#fnref2&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn3&quot;&gt;&lt;p&gt;&lt;code&gt;corpcor::fast.svd()&lt;/code&gt; 와 같은 것도 있다&lt;a href=&quot;#fnref3&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Wed, 22 Feb 2017 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2017/02/22/Profiling.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2017/02/22/Profiling.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>Docker 를 이용해 Rstudio server 띄워보기 (on Mac OSX)</title>
        <description>&lt;p&gt;가상머신보다 경량화된 &lt;a href=&quot;https://www.docker.com/&quot;&gt;Docker&lt;/a&gt; 기술을 이것저것 만져보며 차차 공부중에 있다.&lt;br /&gt;
Docker가 왜 가상머신보다 가볍고 빠른지 지금은 논리적으로 설명하지 못한다.&lt;br /&gt;
가상머신상에서 실험했을 당시 불편한 점들과 만족스럽지 못한 성능을 대체할만한 기술 중 Docker 라는 것이 있다는 소문을 듣고 추천을 받았으며 인기가 매우 높다는 정도만 알고 있다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;우선 본 글은 Docker를 이용해 Rstudio server를 띄움으로써 &amp;quot;Hello Docker!&amp;quot; 를 외치는 것이 목표라 하겠다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;docker-준비&quot;&gt;Docker 준비&lt;/h2&gt;
&lt;p&gt;Docker 을 OSX 에서 설치하는 방법은 다양하다.&lt;br /&gt;
&lt;a href=&quot;https://www.docker.com/&quot;&gt;Docker 공식홈페이지&lt;/a&gt;의 튜토리얼 대로 설치하는 것이 가장 정석의 방법이고,&lt;br /&gt;
&lt;a href=&quot;https://penandpants.com/2014/03/09/docker-via-homebrew/&quot;&gt;Homebrew 를 통해서도 설치&lt;/a&gt;할 수 있으며,&lt;br /&gt;
&lt;a href=&quot;https://www.docker.com/products/docker-toolbox&quot;&gt;Docker Toolbox&lt;/a&gt; 를 이용해 큰 고민 없이 설치할 수도 있다.&lt;/p&gt;
&lt;p&gt;필자는 정석방법대로 하다가 진도가 중간에 막히게 되어 Docker Toolbox 를 overwrite 한 시행착오가 있었는데, 현재로썬 Docker Toolbox 로 설치하는 것이 가장 간단한 방법이라 추측된다.&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;br /&gt;
아래 사진은 &lt;a href=&quot;https://www.docker.com/products/docker-toolbox&quot;&gt;Docker Toolbox&lt;/a&gt; 로 접속했을 때 모습이다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/docker_toolbox.png&quot; width=90%&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;왼쪽 맥용 다운로드 링크를 누르면 &lt;code&gt;.pkg&lt;/code&gt; 파일이 다운로드 된다.&lt;br /&gt;
실행하여 설치를 진행하면 된다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/dtInstall_1.png&quot; width=70%&gt;
&lt;/center&gt;
&lt;br&gt; &lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/dtInstall_2.png&quot; width=70%&gt;
&lt;/center&gt;
&lt;br&gt; &lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/dtInstall_3.png&quot; width=70%&gt;
&lt;/center&gt;
&lt;br&gt; &lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/dtInstall_4.png&quot; width=70%&gt;
&lt;/center&gt;
&lt;br&gt; &lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/dtInstall_5.png&quot; width=70%&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;다른 곳은 특이사항 없이 설치를 진행하면 되는데 이곳에서 무언가를 선택하라고 나온다.&lt;br /&gt;
오른쪽의 Kitematic (Beta) 는 Docker 를 GUI 방식으로 이용할 수 있는 것이고,&lt;br /&gt;
왼쪽은 터미널을 이용해서 빠르게 사용하겠다는 것이다.&lt;br /&gt;
나는 왼쪽을 눌러 사용하는 터미널을 선택 후 계속 버튼을 눌렀다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/dtInstall_6.png&quot; width=70%&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;설치가 성공되면 터미널에서 &lt;code&gt;docker&lt;/code&gt;, &lt;code&gt;boot2docker&lt;/code&gt; 가 실행 가능하다.&lt;br /&gt;
설치가 잘 되었는지 실험삼아 각각의 버전을 확인해보는 커맨드를 입력 해 보았다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker --version
Docker version 1.12.6, build 78d1802&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;$ boot2docker version
Boot2Docker-cli version: v1.8.0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;boot2docker-로-docker-vm-준비하기&quot;&gt;boot2docker 로 docker VM 준비하기&lt;/h2&gt;
&lt;p&gt;&amp;quot;boot2docker&amp;quot; 이름대로 docker 를 이용하기 전에 수행되어야 한다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ boot2docker

Usage: boot2docker [&amp;lt;options&amp;gt;] {help|init|up|ssh|save|down|poweroff|reset|restart|config|status|info|ip|shellinit|delete|download|upgrade|version} [&amp;lt;args&amp;gt;]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;boot2docker 의 사용법을 살펴보면 많은 기능이 있는 것을 볼 수 있는데, 이 중에서 지금은 &lt;code&gt;init&lt;/code&gt;, &lt;code&gt;up&lt;/code&gt;, &lt;code&gt;ssh&lt;/code&gt; 만 알고 넘어가도 되겠다.&lt;br /&gt;
아래와 같이 입력해 실행한다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ boot2docker init
$ boot2docker up&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;boot2docker init&lt;/code&gt; 로 docker daemon 에 대한 VM 을 처음으로 준비한다.&lt;br /&gt;
그다음 &lt;code&gt;boot2docker up&lt;/code&gt; 로 docker daemon VM 을 실행시키는데 수십초 정도가 걸린다.&lt;a href=&quot;#fn2&quot; class=&quot;footnoteRef&quot; id=&quot;fnref2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Waiting for VM and Docker daemon to start...
........ooooooooo
Started.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그 이후에&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ boot2docker ssh&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;를 실행하여 접속하면&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ boot2docker ssh

                        ##         .
                  ## ## ##        ==
               ## ## ## ## ##    ===
           /&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;\___/ ===
      ~~~ {~~ ~~~~ ~~~ ~~~~ ~~~ ~ /  ===- ~~~
           \______ o           __/
             \    \         __/
              \____\_______/
 _                 _   ____     _            _
| |__   ___   ___ | |_|___ \ __| | ___   ___| | _____ _ __
| &amp;#39;_ \ / _ \ / _ \| __| __) / _` |/ _ \ / __| |/ / _ \ &amp;#39;__|
| |_) | (_) | (_) | |_ / __/ (_| | (_) | (__|   &amp;lt;  __/ |
|_.__/ \___/ \___/ \__|_____\__,_|\___/ \___|_|\_\___|_|
Boot2Docker version 1.8.0, build master : 7f12e95 - Tue Aug 11 17:55:16 UTC 2015
Docker version 1.8.0, build 0d03096
docker@boot2docker:~$&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;docker VM 에 접속되며 호스트 OS 가 아닌 bash 인것을 확인할 수 있다.&lt;br /&gt;
저 고래의 모습이 터미널에 출력되면 docker를 본격적으로 이용할 수 있는 모든 준비가 되었다는 것으로 이해해도 좋다. 🐳🐳🐳&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;hello-docker-를-위한-rstudio-server-띄우기&quot;&gt;Hello Docker! 를 위한 Rstudio server 띄우기&lt;/h2&gt;
&lt;p&gt;Docker 의 장점은 여러가지가 있다고 하는데 대표적으로 내세우는 장점이 배포성이라고 한다.&lt;br /&gt;
&lt;a href=&quot;https://hub.docker.com/&quot;&gt;Docker Hub&lt;/a&gt; 는 개발환경 세팅이 끝난 이미지들을 공유하는 곳인데,&lt;br /&gt;
지금 예로 들을 Rstudio server 의 경우도 환경세팅이 끝난 이미지를 찾아 바로 이용할 수 있다.&lt;br /&gt;
이 말은 Rstudio server 구축에 필요한 과정들을 쓸데없이 재발명하지 않고 사용할 수 있다는 것이다.&lt;br /&gt;
실제로 Rstudio server 구축은 어려우면 어렵지 쉬운 과제가 아니다.&lt;/p&gt;
&lt;p&gt;docker VM 에 접속된 상황에서&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker@boot2docker:~$ docker search rstudio-server&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;를 입력해 보자.&lt;br /&gt;
위의 명령어는 Docker Hub 에서 &amp;quot;rstudio-server&amp;quot; 란 검색어로 이미지를 검색하는 것이다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker@boot2docker:~$ docker search rstudio-server

NAME                                     DESCRIPTION                   STARS  OFFICIAL  AUTOMATED
rocker/rstudio                           RStudio Server image          107              [OK]
h2sp/cent65-rstudio-server                                             2                [OK]
mgymrek/docker-rstudio-server                                          1                [OK]
analyticsplatform/rstudio-server         Docker Images for RStudio...  0                [OK]
mjmg/centos-rstudio-opencpu-server       Latest CENTOS with rstudi...  0                [OK]
mjmgaro/fedora-rstudio-server            Latest Fedora with rstudi...  0                [OK]
mjmg/fedora-rstudio-opencpu-server       Latest FEDORA with rstudi...  0                [OK]
davislaboratory/docker-rstudio-serve...  rstudio server for Docker...  0                [OK]
mjmg/fedora-rstudio-server               Latest Fedora with rstudi...  0                [OK]
mjmg/centos-rstudio-opencpu-shiny-se...  Latest CENTOS with rstudi...  0                [OK]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;잘 보면 3번째 열에 &amp;quot;STARS&amp;quot; 라는 것이 있는데 Docker 사용자가 추천한 횟수를 의미한다.&lt;br /&gt;
가장 높은 별을 받은 첫번째 이미지를 우리 예제로 이용해 볼 것이다.&lt;/p&gt;
&lt;p&gt;첫번째 이미지의 명칭은 &amp;quot;rocker/rstudio&amp;quot; 이다.&lt;br /&gt;
이 이미지를 받고 컨테이너를 생성하여(&lt;em&gt;docker VM 에 Rstudio server 를 설치한다고 이해해도 좋다&lt;/em&gt;) Rstudio server 를 실행해 보겠다.&lt;br /&gt;
&lt;code&gt;docker run&lt;/code&gt; 명령이면 이 모든 것이 한번에 된다.&lt;br /&gt;
아래 커맨드를 입력해 실행해 보자.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker@boot2docker:~$ docker run --rm -p 8787:8787 rocker/rstudio&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;조금 복잡해 보일지 몰라도 핵심은 &lt;code&gt;docker run &amp;lt;이미지 이름&amp;gt;&lt;/code&gt; 이다.&lt;br /&gt;
&lt;code&gt;--rm&lt;/code&gt; , &lt;code&gt;-p&lt;/code&gt; 인자들은 부가적인 옵션으로 생각하면 되는데 &lt;code&gt;--rm&lt;/code&gt; 은 컨테이너 종료시 리소스들을 자동으로 반환해주고, &lt;code&gt;-p&lt;/code&gt; 는 포트번호를 직접 입력할 수 있게 한다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker@boot2docker:~$ docker run --rm -p 8787:8787 rocker/rstudio

[fix-attrs.d] applying owners &amp;amp; permissions fixes...
[fix-attrs.d] 00-runscripts: applying...
[fix-attrs.d] 00-runscripts: exited 0.
[fix-attrs.d] done.
[cont-init.d] executing container initialization scripts...
[cont-init.d] conf: executing...
[cont-init.d] conf: exited 0.
[cont-init.d] done.
[services.d] starting services
[services.d] done.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;무엇인가 촤라락 실행된다.&lt;br /&gt;
그리고 실행이 유지되는데, 바로 Rstudio server 를 가동중인 상태인 것이다. 포트번호를 8787로 부여했기 때문에 docker VM 의 IP에서 8787 번 포트로 접속하면 가동중인 Rstudio server 를 띄울 수 있게 된다.&lt;/p&gt;
&lt;p&gt;그런데 잠깐 docker VM 의 IP 를 모르는 상태에서 설명을 쭉쭉 해버리고 있었다.&lt;br /&gt;
IP는 &lt;code&gt;ifconfig&lt;/code&gt; 등으로 확인해 볼 수 있는데 잠깐 가동중인 Rstudio server 를 종료하고 bash 로 빠져 나와야 할 상황이다.&lt;br /&gt;
이럴땐 &lt;kbd&gt;ctrl&lt;/kbd&gt; + &lt;kbd&gt;C&lt;/kbd&gt; 를 눌러 bash 로 빠져나올 수 있다.&lt;br /&gt;
그리고 IP 확인을 위해&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker@boot2docker:~$ ifconfig&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;를 실행하여 &amp;quot;eth1&amp;quot; 의 IP 를 확인한다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker@boot2docker:~$ ifconfig

docker0   Link encap:Ethernet  HWaddr 02:42:22:E3:A5:EA
          inet addr:172.17.42.1  Bcast:0.0.0.0  Mask:255.255.0.0
          inet6 addr: fe80::42:22ff:fee3:a5ea/64 Scope:Link
          UP BROADCAST MULTICAST  MTU:1500  Metric:1
          RX packets:211 errors:0 dropped:0 overruns:0 frame:0
          TX packets:448 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:817705 (798.5 KiB)  TX bytes:48897 (47.7 KiB)

eth0      Link encap:Ethernet  HWaddr 08:00:27:D1:4E:08
          inet addr:10.0.2.15  Bcast:10.0.2.255  Mask:255.255.255.0
          inet6 addr: fe80::a00:27ff:fed1:4e08/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:1250 errors:0 dropped:0 overruns:0 frame:0
          TX packets:799 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:129451 (126.4 KiB)  TX bytes:118182 (115.4 KiB)

eth1      Link encap:Ethernet  HWaddr 08:00:27:3D:AA:C9
          inet addr:192.168.59.103  Bcast:192.168.59.255  Mask:255.255.255.0
          inet6 addr: fe80::a00:27ff:fe3d:aac9/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:465 errors:0 dropped:0 overruns:0 frame:0
          TX packets:226 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:53127 (51.8 KiB)  TX bytes:822933 (803.6 KiB)

lo        Link encap:Local Loopback
          inet addr:127.0.0.1  Mask:255.0.0.0
          inet6 addr: ::1/128 Scope:Host
          UP LOOPBACK RUNNING  MTU:65536  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;필자의 경우 &lt;code&gt;http://192.168.59.103:8787&lt;/code&gt; 가 Rstudio server 를 띄울 수 있는 주소가 된다.&lt;br /&gt;
다시 Rstudio server 컨테이너를 실행하기 위해&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker@boot2docker:~$ docker run --rm -p 8787:8787 rocker/rstudio&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 후 &lt;code&gt;http://192.168.59.103:8787&lt;/code&gt; 로 접속해 본다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/rssLogin.png&quot;&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;로그인 화면이 뜬다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;username : rstudio&lt;/li&gt;
&lt;li&gt;password : rstudio&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;로 로그인을 해보면&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/rss.png&quot;&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;Rstudio server 를 띄울 수 있고 웹상에서 Rstudio 를 이용할 수 있게 된다.&lt;br /&gt;
이렇게 해서 Docker 를 이용한 Rstudio server 이미지를 이용해 손쉽게 &amp;quot;Hello Docker!&amp;quot; 해보았다.&lt;br /&gt;
Docker 를 조금 공부한다면 다른 서비스들도 이러한 방법으로 어려운 구축과정 없이 이용할 수 있지 않을까?&lt;/p&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;Docker command 를 사용하던 도중에도 Docker Toolbox 를 설치하는것을 추천하는 경고메세지가 나오기도 한다 (Docker Toolbox (https://docker.com/toolbox) is the recommended install method)&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn2&quot;&gt;&lt;p&gt;&lt;code&gt;boot2docker up&lt;/code&gt; 대신 &lt;code&gt;boot2docker boot&lt;/code&gt;, &lt;code&gt;boot2docker start&lt;/code&gt; 도 똑같다&lt;a href=&quot;#fnref2&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Sat, 28 Jan 2017 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2017/01/28/Docker_Rstudio_server.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2017/01/28/Docker_Rstudio_server.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>R에서 다수의 패키지 편하게 불러오기</title>
        <description>&lt;h2 id=&quot;상황&quot;&gt;상황&lt;/h2&gt;
&lt;p&gt;R 에서 여러 개의 패키지를 사용해야 하는 프로그램을 작성해야 한다면 &lt;code&gt;library()&lt;/code&gt; 함수로 사용하는 패키지를 불러오는 코드를 서두에 작성하는 전략을 사용할 것이다. &lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;package1&amp;quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;package2&amp;quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;package3&amp;quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;package4&amp;quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;package5&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위의 코드는 5개의 패키지를 로드하는 코드로 볼 수 있는데, 만약 필요로 하는 패키지의 수가 5개가 아닌 수십 개가 된다면 수십개의 &lt;code&gt;library()&lt;/code&gt; 함수를 작성하게 될 것이다.&lt;br /&gt;
아쉽게도 &lt;code&gt;library()&lt;/code&gt; 함수는 불러올 대상이 되는 패키지를 복수개로 입력할 수 없어&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;package1&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;package2&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;package3&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;package4&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;package5&amp;quot;&lt;/span&gt;))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Error : 
  &amp;#39;package&amp;#39;는 반드시 길이가 1이어야 합니다&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;와 같은 꼴로는 사용할 수 없기 때문에 코드가 불필요하게 길어진다.&lt;br /&gt;
반복문을 이용해 굳이 해결책을 찾자면 벡터형 문자열을 이용할 수 있을 것인데&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;for(i in &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;package1&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;package2&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;package3&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;package4&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;package5&amp;quot;&lt;/span&gt;)){
  &lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(i, &lt;span class=&quot;dt&quot;&gt;character.only =&lt;/span&gt; T)
} &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;중간에 패키지 로드가 실패했을 경우 (예를 들어 &amp;quot;package3&amp;quot; 호출이 실패)&lt;br /&gt;
이후의 패키지들 (&amp;quot;package4&amp;quot;, &amp;quot;package5&amp;quot;) 이 로드되지 않는 등 실제로 사용하기엔 불편한 점들이 있을 것이다.&lt;/p&gt;
&lt;p&gt;또한, 위에 제시한 어떠한 방법이든&lt;br /&gt;
자신이 만든 프로그램이 다수의 패키지에 의존되면 의존될수록 타인이 자신의 프로그램을 이용할 때 오류가 일어날 가능성도 커진다.&lt;br /&gt;
타인은 프로그램에 의존된 패키지가 모두 설치되어 있을 리 없다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;pacman-패키지의-p_load-함수&quot;&gt;pacman 패키지의 &lt;code&gt;p_load()&lt;/code&gt; 함수&lt;/h2&gt;
&lt;p&gt;이처럼 재현 가능한 연구를 방해하는 요소들을 없애기 위해 고민하다가 pacman package 를 알게 되었고&lt;br /&gt;
pacman 패키지에서 제공되는 여러 함수 중 &lt;code&gt;p_load()&lt;/code&gt; 함수의 도움을 가장 많이 받고 있다.&lt;br /&gt;
일반적인 상황에서 &lt;code&gt;p_load()&lt;/code&gt; 함수는 위에 제시한 불편한 문제들을 잘 해결해 준다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;pacman::&lt;span class=&quot;kw&quot;&gt;p_load&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;package1&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;package2&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;package3&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;package4&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;package5&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;다수의 패키지를 불러올 때 복수의 문자열 벡터를 입력받을 수 있어 코드 길이를 줄일 수 있다.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;불러오길 희망하는 다수의 패키지 중에&lt;br /&gt;
설치가 되지 않은 패키지가 있어도 알아서 설치를 진행한 후 설치가 잘 완료되면 불러오는 기능이 한 번에 수행된다.&lt;br /&gt;
예를 들어 &amp;quot;package3&amp;quot; 이란 패키지가 설치되어있지 않은 상황이라 하더라도&lt;br /&gt;
오류와 함께 코드실행이 멈추는 것이 아니라 CRAN 에 &amp;quot;package3&amp;quot; 을 찾은 후 패키지 설치완료 후 불러온다.&lt;br /&gt;
CRAN 에 존재하지 않는 패키지명칭을 적지 않는 한 &lt;code&gt;p_load()&lt;/code&gt; 함수로 패키지를 로드할 때 오류가 날 일은 거의 없을 것이다.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;코드 중간중간 필요한 시점에서 &lt;code&gt;library()&lt;/code&gt; 호출을 할 수 도 있겠으나, 프로젝트를 시작하기 앞서 필요한 모든 패키지를 보여주기 위해 보통 서두에 몰아 패키지를 호출하는 경우가 많은것 같다&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Thu, 12 Jan 2017 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2017/01/12/multiple_load_packages.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2017/01/12/multiple_load_packages.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>R에서 Startup option 설정하기 (on Mac OSX)</title>
        <description>&lt;p&gt;만약 R에서 꾸준히 + 자주자주 + 빈번하게 활용하는 패키지가 있다면 매번 &lt;code&gt;library()&lt;/code&gt; 로 호출하는 것이 귀찮을 수 있다.&lt;br /&gt;
나의 경우 dplyr package 를 항시 사용하는 편이어서 R이 켜질 때 자동으로 &lt;code&gt;library(dplyr)&lt;/code&gt; 이 실행됐으면 했는데 찾아보니 R은 이런 경우를 생각해 Startup option 들을 제공하고 있다는 것을 알았다.&lt;/p&gt;
&lt;p&gt;여러 방법이 있지만 내가 볼 때 가장 간편한 방법은&lt;br /&gt;
자신의 홈 디렉토리에 &amp;quot;.Rprofile&amp;quot; 이란 숨김파일을 만든 후&lt;br /&gt;
이안에 자주 활용하는 패키지를 호출하는 명령어를 미리 적어 놓는 것이다.&lt;/p&gt;
&lt;p&gt;자세히 정리하면 아래와 같다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;홈-디렉토리로-들어가-.rprofile-숨김파일-만들기&quot;&gt;홈 디렉토리로 들어가 &amp;quot;.Rprofile&amp;quot; 숨김파일 만들기&lt;/h2&gt;
&lt;p&gt;쉘에서 틸드(~)문자는 사용자의 홈 디렉토리를 의미하는 특별한 기호이다.&lt;br /&gt;
터미널을 실행한 후 틸드문자를 이용해 사용자 홈디렉토리로 이동한다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd ~&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;아마도 &amp;quot;.Rprofile&amp;quot; 파일이 존재할 수도 있다. 물론 없을 수도 있고 상황에 따라 다르다.&lt;br /&gt;
상관없이 텍스트에디터를 이용해 &amp;quot;.Rprofile&amp;quot; 를 수정하거나 새로 만들면 되겠다.&lt;br /&gt;
간편히 nano 를 이용한다고 치면&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nano .Rprofile&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;를 통해 &amp;quot;.Rprofile&amp;quot; 를 열거나 새로 만들게 된다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;startup-커멘드-및-옵션들-작성하기&quot;&gt;Startup 커멘드 및 옵션들 작성하기&lt;/h2&gt;
&lt;p&gt;&amp;quot;.Rprofile&amp;quot; 에 무언가를 작성할 것인데&lt;br /&gt;
바로 이곳에 &lt;code&gt;library(dplyr)&lt;/code&gt; 과 같은 것을 적고 저장시키면&lt;br /&gt;
앞으로 R을 실행하자마자 &lt;code&gt;library(dplyr)&lt;/code&gt; 명령어가 자동으로 실행된다.&lt;br /&gt;
이러한 간단한 원리를 이용해 패키지 자동호출 외에도 &lt;code&gt;options()&lt;/code&gt; set 을 미리 지정하는 것도 매우 좋은 Tip이 될 수 있겠다.&lt;/p&gt;
&lt;p&gt;나의 &amp;quot;.Rprofile&amp;quot; 을 소개하자면 이렇다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;options&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;help_type =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;html&amp;quot;&lt;/span&gt;) ## 1
&lt;span class=&quot;kw&quot;&gt;options&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;stringsAsFactors =&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;FALSE&lt;/span&gt;) ## 2

pacman::&lt;span class=&quot;kw&quot;&gt;p_load&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;useful.lovetoken&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;knitr&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;dplyr&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;ggplot2&amp;quot;&lt;/span&gt;) ## 3

opts_chunk$&lt;span class=&quot;kw&quot;&gt;set&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;fig.path =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;output/figure/&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;fig.align =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;center&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;out.width =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;80%&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;warning =&lt;/span&gt; F, &lt;span class=&quot;dt&quot;&gt;message =&lt;/span&gt; F) ## 4

&lt;span class=&quot;kw&quot;&gt;theme_set&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;theme_bw&lt;/span&gt;()) ## 5&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;함수 도움말을 볼 때 기본적으로 html 포맷의 형태에 문서가 열리는걸로 고정시켰다&lt;a href=&quot;#fn2&quot; class=&quot;footnoteRef&quot; id=&quot;fnref2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;read.csv()&lt;/code&gt; 와 같은 함수에서 &lt;code&gt;stringsAsFactors&lt;/code&gt; 인자값이 &lt;code&gt;getOption(&amp;quot;stringsAsFactors&amp;quot;)&lt;/code&gt; 에 의존되는데 이를 &lt;code&gt;FALSE&lt;/code&gt; 로 고정시켰다&lt;/li&gt;
&lt;li&gt;필자가 자주쓰는 패키지로 R을 실행할 때 무조건 호출될 패키지 4개를 pacman 을 통해 호출했다&lt;/li&gt;
&lt;li&gt;Rmarkdown 을 쓰는 경우 knitr 패키지를 통해 코드청크 글로벌 옵션들을 지정시켰다&lt;/li&gt;
&lt;li&gt;ggplot2 의 메인테마에 대한 설정이다&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;여러분도 여러분 나름의 &amp;quot;.Rprofile&amp;quot; 를 작성해 보시길 🙃&lt;br /&gt;
그리고 본 글은 Mac OS X 를 기준으로 작성한 경우이지만, 리눅스이어도 홈 디렉토리의 경로만 약간 다를 뿐 틸드문자를 이용한 방법은 똑같다고 보면 되겠다.&lt;br /&gt;
윈도우의 경우는 R이 설치된 &amp;quot;C:\Program Files\R\R-***\etc\&amp;quot; 이곳에 &amp;quot;.Rprofile&amp;quot; 를 작성하면 되겠다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.onthelambda.com/2014/09/17/fun-with-rprofile-and-customizing-r-startup/&quot;&gt;Fun with .Rprofile and customizing R startup&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://stat.ethz.ch/R-manual/R-devel/library/base/html/Startup.html&quot;&gt;&lt;code&gt;?Startup&lt;/code&gt; in R&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;vi, vim 들도 있지만 이걸 아시는분들을 위한 글은 아닐수도... 있을것 같다&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn2&quot;&gt;&lt;p&gt;IDE 에 따라 도움말 포맷이 유동적으로 설정된다. 이걸 무조건 html type 으로만 열리게 고정시킨 경우이다&lt;a href=&quot;#fnref2&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Tue, 20 Dec 2016 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2016/12/20/RStartup_Option.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2016/12/20/RStartup_Option.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>Google 에서 사용하는 R 코딩 스타일 규약</title>
        <description>&lt;p&gt;구글에서는 코드를 작성할 때 아래 링크로 정리된 규약을 따라 프로그램을 작성한다고 한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://google.github.io/styleguide/Rguide.xml&quot;&gt;Google&#39;s R Style Guide&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;여러가지 규칙이 있고 이에 대한 예제가 상세히 제시되어 있다.&lt;br /&gt;
간단하게 주요 10가지 사항만 정리해 보면&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;한 줄에 80자 이상을 작성하지 않는다.&lt;/li&gt;
&lt;li&gt;단일명령문에는 중괄호 &lt;code&gt;{}&lt;/code&gt; 를 사용하지 않는다.&lt;/li&gt;
&lt;li&gt;모든 연산자에는 양 좌, 우에 띄어쓰기를 하여 자간을 맞춘다.&lt;/li&gt;
&lt;li&gt;쉼표 &lt;code&gt;,&lt;/code&gt; 는 앞에 공백을 두지 않고 뒤에만 넣는다.&lt;/li&gt;
&lt;li&gt;들여쓰기는 Space를 이용해 2칸으로 정한다. Tab 을 사용하지 않는다.&lt;/li&gt;
&lt;li&gt;괄호와 대괄호에서 여는곳과 닫는곳에 공백을 넣지 않는다.&lt;/li&gt;
&lt;li&gt;할당연산자는 &lt;code&gt;&amp;lt;-&lt;/code&gt; 를 사용한다. &lt;code&gt;=&lt;/code&gt; 를 사용하지 않는다.&lt;/li&gt;
&lt;li&gt;함수의 정의에서 인수를 설정할 땐 기본값이 없는 인수를 먼저 나열하고, 그 뒤에 기본값을 갖는 인수를 나열한다.&lt;/li&gt;
&lt;li&gt;프로그램에선 오류를 만들 가능성이 있는 &lt;code&gt;attach()&lt;/code&gt; 를 사용하지 않는다.&lt;/li&gt;
&lt;li&gt;(구글은 일관성을 위하여 세미콜론을 불필요하다고 판단했다) 세미콜론 &lt;code&gt;;&lt;/code&gt; 으로 줄을 끝내거나 같은 줄에 둘 이상의 명령을 넣지 않는다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;정도가 된다.&lt;/p&gt;
&lt;p&gt;나름대로 정리된 Code convention 을 읽지 않았을 이전에는 항상 R 스크립트가 뒤죽박죽인 면이 있었는데 앞으론 통일시킬 수 있을 것 같다.&lt;br /&gt;
무엇보다 중요한 건 코딩시 생기는 불필요한 코딩 스타일의 선택에 대한 고민을 줄여 줄 수 있을 거라 생각된다.&lt;/p&gt;
</description>
        <pubDate>Sun, 18 Dec 2016 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2016/12/18/RCodeConventions.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2016/12/18/RCodeConventions.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>Getting Started StackOverflow</title>
        <description>&lt;a href=&quot;http://stackoverflow.com/&quot;&gt;&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/SO_logo.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이 글을 쓰는 시점 스택오버플로우&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;를 눈팅만 한지 2년 가까이 되었다.&lt;br /&gt;
나는 굳이 분류하자면 개발군과 비개발군 중 비개발군에 속하는 사람이다.&lt;br /&gt;
따라서 스택오버플로우에 있는 글들을 눈팅만 해도 충분하게 넘칠 정도로 얻어갔다.&lt;/p&gt;
&lt;p&gt;그런데 요즘시대 개발, 비개발 분류하는것이 의미가 없어질 정도로 다양하게 섭렵해야 하는 시대가 아닌가?&lt;br /&gt;
다양한 컴퓨터언어와 오픈소스도구들을 이것저것 만지작하면서 최소한 개발자들과의 협업이 가능한 수준의 배경지식과 개발능력을 함양할 필요가 있다고 생각이 바뀌기 시작했다.&lt;br /&gt;
그리고 눈팅만 2년째 하다 보니 입문자 입장에서의(나를 위한) 얼토당토않은 낮은 수준의 질문글이 보이지 않는다는 것을 느끼게 되었다.&lt;a href=&quot;#fn2&quot; class=&quot;footnoteRef&quot; id=&quot;fnref2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;br /&gt;
그래서 내가 생각하는 낮은 수준의 질문을 발번역해 영어로 작문하고, 작성된 글을 올리기 위하여 스택오버플로우에 로그인하였다.&lt;a href=&quot;#fn3&quot; class=&quot;footnoteRef&quot; id=&quot;fnref3&quot;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이때부터 스택오버플로우의 사용방법과, 생태계의 메커니즘을 좀 정확히 알고 싶은 마음이 생겼는데&lt;br /&gt;
이를 계기로 이글을 작성한 다음 적극적으로 애용해보려 한다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;스택오버플로우-간단-소개&quot;&gt;스택오버플로우 간단 소개&lt;/h2&gt;
&lt;p&gt;스택오버플로우는 2008년경에 만들어진 프로그래머들 사이의 질문/답변 커뮤니케이션 사이트이다.&lt;br /&gt;
조엘 스폴스키 등 2명이 기존의 있던 Q&amp;amp;A 사이트인 Experts_Exchange를 더 개방시킨 웹사이트로서 만들어진 사이트라고 한다.&lt;br /&gt;
만들어진지 8년만에 개발관련된 구글링을 하면 절반이 넘는 게시글이 스택오버플로우로 연결되어 있을 정도로 아주 중요한 웹사이트가 되었다.(&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_Overflow&quot;&gt;wiki 참고&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;스택오버플로우의-운영-원리&quot;&gt;스택오버플로우의 운영 원리&lt;/h2&gt;
&lt;p&gt;스택오버플로우는 reputation 즉 명성도라는 것을 이용한다. (평판이라고도 한다)&lt;br /&gt;
평판제도는 스택오버플로우를 사용할 때 특정 자격을 부여하는 등 사용 동기부여를 주기도 한다.&lt;br /&gt;
이 제도 때문에 사용자들이 좀 더 정확한 질문, 그에 대한 알찬 답변을 상호적으로 주고 받을 수 있는 좋은 메커니즘으로 작용하고 있고, 자연스럽게 주제와 벗어난 질문과 글들이 필터링 되는 좋은 인프라가 뿌리잡았다고 생각한다.&lt;br /&gt;
나도 특정 커뮤니티를 운영하는 사람으로서 부러운, 그리고 여러모로 본받고싶은 생태계이다.&lt;/p&gt;
&lt;p&gt;명성도를 얻는 방법은 구체적인 방법을 뒤에 작성할 것이지만, 결국은 질문과 답변을 주고받으면 자연스럽게 오르는 규칙이다.&lt;br /&gt;
우선 최초 가입시점 자신의 명성도는 1점으로 시작한다. 아래 그림은 Profile로 들어가본 모습이다. &lt;a href=&quot;#fn4&quot; class=&quot;footnoteRef&quot; id=&quot;fnref4&quot;&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/SO_1.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;명성도 외에도 또 다른 숫자가 점과 함께 표기되어 있다.&lt;br /&gt;
이건 배지(Badge)의 개수를 의미한다.&lt;br /&gt;
배지는 있어도 그만 없어도 그만이지만 있으면 기분이 흡족해지는 그런 물건이 아닌가?&lt;br /&gt;
평판도와 함께 각 배지 종류별 갯수도 함께 표시되어진다.&lt;br /&gt;
배지의 종류는 골드, 실버, 브론즈로 3가지가 나뉘는데 지금 나는 브론즈 배지가 2개가 있다는 것을 의미한다.&lt;br /&gt;
활동을 열심히 해서 평판도와 여러 가지 종류의 배지를 획득하게 되면 Profile 은 이런식으로 발전하게 될 것이다. (R의 knitr 패키지 개발자 Yihui Xie 의 Profile 을 예로 들어보았다)&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/SO_2.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;배지와는 다르게 명성도는 스택오버플로우 이용에 직접적인 영향을 끼친다.&lt;br /&gt;
직접적인 영향이라고 해서 차별이 있는 것이 아니다.&lt;br /&gt;
명성도가 없어도 스택오버플로우를 이용하는데 전혀 문제가 없다.&lt;br /&gt;
다만 일종의 특권(Privilege)이 생기는 것으로 생각하는 게 좋다.&lt;/p&gt;
&lt;p&gt;특권은 명성도가 일정치를 초과했을 시점부터 생긴다.&lt;br /&gt;
표로 정리해보면 이렇다. (지금상황에서 무슨 의미인지 정확하게 모르는 특권은 번역하지 않고 영어로 그대로 놔두었는데, 알게 되면 번역하겠다)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;http://stackoverflow.com/help/privileges?tab=all&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;
&lt;colgroup&gt;
&lt;col style=&quot;width: 8%&quot; /&gt;
&lt;col style=&quot;width: 91%&quot; /&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr class=&quot;header&quot;&gt;
&lt;th style=&quot;text-align: left;&quot;&gt;명성도&lt;/th&gt;
&lt;th style=&quot;text-align: left;&quot;&gt;특권내용&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;25,000&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;스택오버플로우 사이트의 내부분석을 위한 Google analytics 접근이 가능&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;20,000&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;신뢰할 수 있는 사용자로 판단되어 스택오버플로우의 모든 질문글에 대해 편집, 삭제 권한이 부여됨&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;15,000&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;보호된 질문을 사용할 수 있음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;10,000&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;access to moderator tools : Access reports, delete questions, review reviews&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;5,000&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;모든 글에 대해 태그를 수정할 수 있음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;3,000&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;cast close and reopen votes : Help decide whether posts are off-topic or duplicates&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;2,500&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;어떤 태그가 다른것과 동일한 의미를 가지는지 결정할 수 있음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;2,000&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;이미 올려진 질문, 질문에 대한 답변을 즉시 편집할 수 있음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;1,500&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;새로운 태그를 만들 수 있음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;1,000&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;established user : You&#39;ve been around for a while; see vote counts&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;1,000&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;특정한 사람들과 대화할 수 있는 대화방을 만들 수 있음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;500&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;access review queues : Access first posts and late answers review queues&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;250&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;자신의 질문글에 대한 투표를 종료할 수 있고, 이후에 종료된 것을 다시 열 수 있음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;200&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;광고를 줄일 수 있는 옵션을 사용할 수 있음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;125&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;질문과 질문의 답변글에 대해 upvote 외에도 downvote 를 할 수 있음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;100&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;위키 커뮤니티에 협업할 수 있음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;100&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;대화방을 만들 수 있음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;100&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;문서에 대하여 제안된 변경사항에 대하여 승인 및 거부할 수 있음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;75&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;자신의 명성을 보상으로 걸 수 있는 질문을 할 수 있음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;50&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;다른 사람의 게시물에 댓글을 달 수 있음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;20&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;대화방에 참석이 가능&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;15&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;신고기능(Flag)을 이용할 수 있음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;15&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;답변글에 대해 투표가 가능, 단 upvote 만 할 수 있음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;10&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;신규유저에 대한 제한처리 기능 해제&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;10&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;create wiki posts : Create answers that can be easily edited by most users&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;5&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;participate in meta : Discuss the site itself: bugs, feedback, and governance&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;1&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;질문 혹은 답변글을 작성할 수 있음&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;지금 명성도가 1인 나는 질문과 답변글을 작성할 수 있다.&lt;br /&gt;
그런데 예를들어 질문을 열심히하고 답변을 주고받으며 명성도가 15점 이상 되면 다른 질문과 답변에 대해서 투표를 할 수 있다.&lt;br /&gt;
정확히 말하면 upvote 가 가능한데 좋은 Q&amp;amp;A 글이라 생각되는 것에 대해서 점수를 준다고 생각하면 된다.&lt;br /&gt;
그리고 upvote 를 받은 글의 주인은 명성도가 오르게 된다.&lt;br /&gt;
반대로 downvote 도 가능하다. (단 명성도 125 필요)&lt;br /&gt;
스택오버플로우는 이렇게 투표를 받은 질문글이 상위로 노출되어 좀 더 가치 있는 질문글과 답변으로 자가발전하게 되는 식이다.&lt;/p&gt;
&lt;p&gt;명성도를 얻는 방법은 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;내가 작성한 질문에 upvote 가 되면 +5&lt;/li&gt;
&lt;li&gt;내가 작성한 답변에 upvote 가 되면 +10&lt;/li&gt;
&lt;li&gt;내가 작성한 답변이 질문자에 의해 승인이 되면 +15&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;see-also&quot;&gt;See also&lt;/h2&gt;
&lt;p&gt;스택오버플로우의 가장 아쉬운 점은 영어를 사용해야 한다는 점이다.&lt;br /&gt;
개발 및 코드와 함께 작성될 질문글은 많은 부가적인 설명과 함께 작성하게 될 가능성이 높은데&lt;br /&gt;
영어를 완벽하게 구사하지 못한다면 자신이 표출하고 싶은 의미를 서술하기 힘들 것이다.&lt;/p&gt;
&lt;p&gt;이런 이유때문에 아마도 눈팅만 2년째이었을 수도 있다.&lt;br /&gt;
여하튼 이런 애로사항을 많은 사람이 가지고 있었다는 걸 StackOverflow in Korean (이하 &lt;a href=&quot;(http://stackoverflow-in-korean.github.io/)&quot;&gt;SOK&lt;/a&gt;) 를 통해 알 수 있었다.&lt;br /&gt;
스택오버플로우는 내부적으로 Non-english 를 위한 베타버전을 운용하고 있는데&lt;br /&gt;
한국을 위한 스택오버플로우를 만들기위해 SOK 에서 열심히 온라인 활동을 했었지만 &lt;a href=&quot;http://stackoverflow-in-korean.github.io/docs/%EC%97%B0%ED%98%81/&quot;&gt;기각&lt;/a&gt;되었다고 한다.&lt;br /&gt;
진작에 이런 활동을 알고 있었다면 부족하게나마 도움을 주었을텐데 하는 아쉬움이 많이 든다.&lt;/p&gt;
&lt;p&gt;하지만 해결되지 않은 이 애로사항을 속으로 애타게 해결하고자 하는 분들이 많았을 것이라 본다.&lt;br /&gt;
때문에 이러한 사이트들이 이후에 생긴 게 아닐까?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://dolgo.net/&quot;&gt;돌고넷&lt;/a&gt; (http://dolgo.net)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://hashcode.co.kr&quot;&gt;Hashcode&lt;/a&gt; (http://hashcode.co.kr)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow-in-korean.github.io/&quot;&gt;StackOverflow in Korean&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/tour&quot;&gt;Welcome to Stack Overflow&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;StackOverflow 줄여서 SO라고들 많이 표현한다&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn2&quot;&gt;&lt;p&gt;이렇게 느끼게 된 이유는 무엇일까? 아마도 모른다는 것을 모르는 단계에서, 모르는걸 알게 된 단계로 바뀌어서 그런 걸까!&lt;a href=&quot;#fnref2&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn3&quot;&gt;&lt;p&gt;눈팅시절 가입도 안하고 비로그인 상태에서 스택오버플로우를 이용했었다&lt;a href=&quot;#fnref3&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn4&quot;&gt;&lt;p&gt;굳이 Profile 로 들어가서 확인하지 않아도 스택오버플로우의 최상단 배너에 명성도를 확인할 수 있다&lt;a href=&quot;#fnref4&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Sun, 11 Dec 2016 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/etc/2016/12/11/StackOverflow.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/etc/2016/12/11/StackOverflow.html</guid>
        
        
        <category>etc</category>
        
      </item>
    
      <item>
        <title>R에서 모델적합에 사용되는 formula 인자식 사용부분에 대한 고찰</title>
        <description>&lt;p&gt;R을 이용한 모델링을 할 때 &lt;code&gt;formula&lt;/code&gt; 인자값을 어떤 식으로 입력해야 하는지 정리해 볼 필요가 있다.&lt;br /&gt;
대표적으로 &lt;code&gt;lm()&lt;/code&gt; 함수의 첫 번째 인자에 대한 입력값을 예로 들 수 있을 것이다.&lt;br /&gt;
이 인자값에는 약속에 의해 정해진 기호(operator)를 이용하여 모델의 뼈대를 설정할 수 있다.&lt;br /&gt;
몇가지의 기호만 알고 이를 조합한다면 일반적인 뼈대를 구성하는데 문제가 생기진 않을 것이다.&lt;/p&gt;
&lt;p&gt;(본 글에서 사용될 기초데이터는 &lt;code&gt;mtcars&lt;/code&gt; 이다.)&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;head&lt;/span&gt;(mtcars)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##                    mpg cyl disp  hp drat    wt  qsec vs am gear carb
## Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4
## Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4
## Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1
## Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1
## Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2
## Valiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;기호&quot;&gt;&amp;quot;~&amp;quot; 기호&lt;/h2&gt;
&lt;p&gt;기본적으로 &lt;code&gt;formula&lt;/code&gt; 인자값의 입력은 종속변수를 앞에 쓰고 독립변수를 뒤에 쓰게 되는데&lt;br /&gt;
종속변수와 독립변수를 구분 짓는 기호는 &amp;quot;~&amp;quot; 이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;lm&lt;/span&gt;(mpg ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;wt, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; mtcars)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = mpg ~ wt, data = mtcars)
## 
## Coefficients:
## (Intercept)           wt  
##      37.285       -5.344&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위의 단순선형회귀적합 코드를 살펴보자.&lt;br /&gt;
&lt;code&gt;lm()&lt;/code&gt; 함수의 첫 번째 인자입력값을 보면 &lt;code&gt;mpg ~ wt&lt;/code&gt; 로 되어있다.&lt;br /&gt;
왼쪽 맨 앞의 &lt;code&gt;mpg&lt;/code&gt; 는 종속변수로 지정하고, 오른쪽 뒤에 있는 &lt;code&gt;wt&lt;/code&gt; 는 독립변수로 지정하겠다는 의미가 된다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;기호-1&quot;&gt;&amp;quot;+&amp;quot; 기호&lt;/h2&gt;
&lt;p&gt;독립변수를 &lt;code&gt;wt&lt;/code&gt; 뿐만 아니라 &lt;code&gt;cyl&lt;/code&gt; 변수까지 고려하는 다중회귀분석을 하고 싶다면 &amp;quot;+&amp;quot; 기호를 이용해 고려대상이 되는 변수를 추가시킬 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;lm&lt;/span&gt;(mpg ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;wt +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;cyl, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; mtcars)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = mpg ~ wt + cyl, data = mtcars)
## 
## Coefficients:
## (Intercept)           wt          cyl  
##      39.686       -3.191       -1.508&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그런데 만약 자신이 가지고 있는 데이터셋에 종속변수를 설명시킬 독립변수들이 이미 모두 포진되어있는 상태라면, 그리고 그 독립변수들을 모두 고려한 다중회귀적합을 시키고 싶다면 어떻게 해야 할까?&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;lm&lt;/span&gt;(mpg ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;cyl +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;disp +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;hp +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;drat +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;wt +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;qsec +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;vs +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;am +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;gear +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;carb, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; mtcars)  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = mpg ~ cyl + disp + hp + drat + wt + qsec + vs + 
##     am + gear + carb, data = mtcars)
## 
## Coefficients:
## (Intercept)          cyl         disp           hp         drat  
##    12.30337     -0.11144      0.01334     -0.02148      0.78711  
##          wt         qsec           vs           am         gear  
##    -3.71530      0.82104      0.31776      2.52023      0.65541  
##        carb  
##    -0.19942&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이런 식으로 고려대상이 되는 독립변수의 명칭을 모두 적은 다음&lt;br /&gt;
사이사이에 &amp;quot;+&amp;quot; 기호를 무식하게 넣어주어야 하는 상황이다.&lt;br /&gt;
하지만 위의 코딩은 매우 비효율적 🙄 손이 아파질 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;기호-2&quot;&gt;&amp;quot;.&amp;quot; 기호&lt;/h2&gt;
&lt;p&gt;이를 대비해 특수하게 약속된 &amp;quot;.&amp;quot; 기호를 이용하면 좋다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;lm&lt;/span&gt;(mpg ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;., &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; mtcars)  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = mpg ~ ., data = mtcars)
## 
## Coefficients:
## (Intercept)          cyl         disp           hp         drat  
##    12.30337     -0.11144      0.01334     -0.02148      0.78711  
##          wt         qsec           vs           am         gear  
##    -3.71530      0.82104      0.31776      2.52023      0.65541  
##        carb  
##    -0.19942&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;quot;.&amp;quot; 기호는 &amp;quot;전부&amp;quot; 의 의미를 가진다.&lt;br /&gt;
위의 코드는 종속변수로 이미 배정된 mpg 이외의 모든 변수를 독립변수로 고려하라 라는 의미가 된다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;기호-3&quot;&gt;&amp;quot;-&amp;quot; 기호&lt;/h2&gt;
&lt;p&gt;&amp;quot;+&amp;quot; 기호의 반대는 &amp;quot;-&amp;quot; 이다. 의미 역시 반대이다.&lt;br /&gt;
고려대상에서 추가하는 &amp;quot;+&amp;quot; 와 다르게 &amp;quot;-&amp;quot; 는 고려대상에서 제외시킨다.&lt;br /&gt;
&amp;quot;.&amp;quot; 기호를 통해 모든 독립변수를 배정했는데, 여기서 &lt;code&gt;cyl&lt;/code&gt; 변수만은 독립변수에서 제외하고 싶을 경우&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;lm&lt;/span&gt;(mpg ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;. -&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;cyl, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; mtcars)  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = mpg ~ . - cyl, data = mtcars)
## 
## Coefficients:
## (Intercept)         disp           hp         drat           wt  
##    10.96007      0.01283     -0.02191      0.83520     -3.69251  
##        qsec           vs           am         gear         carb  
##     0.84244      0.38975      2.57743      0.71155     -0.21958&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이렇게 &amp;quot;-&amp;quot; 기호를 활용하면 된다.&lt;/p&gt;
&lt;p&gt;한 가지 덧붙이자면 회귀적합시 기본적으로 절편(intercept)을 고려하는 회귀적합을 하게 되는데, 절편이 0인 모델로 적합하고 싶은 경우 절편항을 제외시켜야 할 것이다.&lt;br /&gt;
&amp;quot;-&amp;quot; 기호를 아래와 같이 이용하면 된다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;lm&lt;/span&gt;(mpg ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;. -&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; mtcars)  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = mpg ~ . - 1, data = mtcars)
## 
## Coefficients:
##      cyl      disp        hp      drat        wt      qsec        vs  
##  0.35083   0.01354  -0.02055   1.24158  -3.82613   1.19140   0.18972  
##       am      gear      carb  
##  2.83222   1.05426  -0.26321&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;결과를 확인해 보면 항시 언급되었던 절편항 &amp;quot;(Intercept)&amp;quot; 이 없어진 것을 확인할 수 있다.&lt;br /&gt;
참고로 아래와 같이 해도 절편항을 제외한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;lm&lt;/span&gt;(mpg ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;. +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; mtcars)  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = mpg ~ . + 0, data = mtcars)
## 
## Coefficients:
##      cyl      disp        hp      drat        wt      qsec        vs  
##  0.35083   0.01354  -0.02055   1.24158  -3.82613   1.19140   0.18972  
##       am      gear      carb  
##  2.83222   1.05426  -0.26321&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;기호-4&quot;&gt;&amp;quot;:&amp;quot; 기호&lt;/h2&gt;
&lt;p&gt;회귀적합에서 상호작용에 대해 고려한다면 &amp;quot;:&amp;quot; 기호를 이용하여 상호작용항을 부여할 수 있다.&lt;br /&gt;
만약 종속변수 &lt;code&gt;mpg&lt;/code&gt; 에 대해 설명하는 독립변수를 &lt;code&gt;wt&lt;/code&gt;, &lt;code&gt;cyl&lt;/code&gt; 2개 설정하고,&lt;br /&gt;
이 두 변수의 상호작용까지 고려하고자 한다면 이렇게 하면 된다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;lm&lt;/span&gt;(mpg ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;wt +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;cyl +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;wt:cyl, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; mtcars)  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = mpg ~ wt + cyl + wt:cyl, data = mtcars)
## 
## Coefficients:
## (Intercept)           wt          cyl       wt:cyl  
##     54.3068      -8.6556      -3.8032       0.8084&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그런데 고려대상인 독립변수가 3개 이상, 그리고 독립변수의 조합별 상호작용을 고려하게 된다면 골치가 아플 수 있다.&lt;br /&gt;
예를 들어 &lt;code&gt;mpg&lt;/code&gt; 에 대해 설명하는 독립변수를 &lt;code&gt;wt&lt;/code&gt;, &lt;code&gt;cyl&lt;/code&gt;, &lt;code&gt;gear&lt;/code&gt; 3개이고, 3개의 모든 조합에 대해 상호작용을 고려한다면 &lt;code&gt;formula&lt;/code&gt; 인자값이 아래처럼 매우 길게 된다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;lm&lt;/span&gt;(mpg ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;wt +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;cyl +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;gear +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;wt:cyl +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;wt:gear +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;cyl:gear +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;wt:cyl:gear, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; mtcars)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = mpg ~ wt + cyl + gear + wt:cyl + wt:gear + cyl:gear + 
##     wt:cyl:gear, data = mtcars)
## 
## Coefficients:
## (Intercept)           wt          cyl         gear       wt:cyl  
##     47.3853     -10.4502      -0.8957       2.2704       0.5459  
##     wt:gear     cyl:gear  wt:cyl:gear  
##      0.3527      -0.8794       0.1001&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;기호-5&quot;&gt;&amp;quot;*&amp;quot; 기호&lt;/h2&gt;
&lt;p&gt;상호작용항을 고려하되 각 개별항과 상호작용항이 될 수 있는 모든 조합을 알아서 배정시키는&lt;br /&gt;
약속된 기호가 바로 &amp;quot;*&amp;quot; 이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;lm&lt;/span&gt;(mpg ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;wt *&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;cyl *&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;gear, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; mtcars)  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = mpg ~ wt * cyl * gear, data = mtcars)
## 
## Coefficients:
## (Intercept)           wt          cyl         gear       wt:cyl  
##     47.3853     -10.4502      -0.8957       2.2704       0.5459  
##     wt:gear     cyl:gear  wt:cyl:gear  
##      0.3527      -0.8794       0.1001&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위의&lt;br /&gt;
&lt;code&gt;mpg ~ wt * cyl * gear&lt;/code&gt;&lt;br /&gt;
는&lt;br /&gt;
&lt;code&gt;mpg ~ wt + cyl + gear + wt:cyl + wt:gear + cyl:gear + wt:cyl:gear&lt;/code&gt;&lt;br /&gt;
와 동일한 것이다.&lt;br /&gt;
따라서 실행된 코드의 출력결과도 비교해 보면 같은 것을 확인할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;i-함수&quot;&gt;&lt;code&gt;I()&lt;/code&gt; 함수&lt;/h2&gt;
&lt;p&gt;만약 분석자 나름대로 다변수들의 정보를 하나로 압축시킨 파생변수로 회귀적합을 하고 싶다면 어떻게 해야 할까?&lt;br /&gt;
예를 들어 &lt;code&gt;hp&lt;/code&gt; 변수값과 루트를 씌운 &lt;code&gt;wt&lt;/code&gt;변수값을 더하고 &lt;code&gt;carb&lt;/code&gt; 변수의 값을 뺀 값을 독립변수로 설정하여 단순회귀적합을 하고 싶다고 가정해보자. (일부러 의미 없이 복잡하게 설정해 봄)&lt;/p&gt;
&lt;p&gt;일단 떠오르는 방법은 &lt;code&gt;mtcars&lt;/code&gt; 에 새로운 변수열을 만들어 위의 상황대로&lt;/p&gt;
&lt;p&gt;hp + sqrt(wt) - carb&lt;/p&gt;
&lt;p&gt;를 계산한 새로운 변수를 만들어 이 변수열과 회귀적합을 하면 될 것이다.&lt;br /&gt;
하지만 &lt;code&gt;I()&lt;/code&gt; 함수를 알게 된다면 새로운 변수를 직접 만들 필요가 없다. 이렇게 하면 된다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;lm&lt;/span&gt;(mpg ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;I&lt;/span&gt;(hp +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;sqrt&lt;/span&gt;(wt) -&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;carb), &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; mtcars)  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = mpg ~ I(hp + sqrt(wt) - carb), data = mtcars)
## 
## Coefficients:
##             (Intercept)  I(hp + sqrt(wt) - carb)  
##                30.20584                 -0.06945&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그런데 한 가지 의문이 생길 수 있다.&lt;br /&gt;
만약 &lt;code&gt;I()&lt;/code&gt; 함수를 이용하지 않고 &lt;code&gt;formula&lt;/code&gt; 에 &lt;code&gt;hp + sqrt(wt) - carb&lt;/code&gt; 의 날것의 형태로 입력하면 되지 않을까? 라는 의문이다.&lt;br /&gt;
실행해보면 다음과 같다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;lm&lt;/span&gt;(mpg ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;hp +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;sqrt&lt;/span&gt;(wt) -&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;carb, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; mtcars)  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = mpg ~ hp + sqrt(wt) - carb, data = mtcars)
## 
## Coefficients:
## (Intercept)           hp     sqrt(wt)  
##    50.42823     -0.02908    -14.70273&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;우리가 줄곧 배운 &lt;code&gt;formula&lt;/code&gt; 의 입력값은 특정한 기호에 의해 약속된 문법을 따른다.&lt;br /&gt;
따라서 &lt;code&gt;hp + sqrt(wt) - carb&lt;/code&gt; 의 형태는 우리가 원하는 파생변수를 만들어 적합시키지 않는다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;hp&lt;/code&gt; 값에 &lt;code&gt;sqrt(wt)&lt;/code&gt; 값이 더해진 후 &lt;code&gt;carb&lt;/code&gt; 변수값이 차감된 것을 원하지만,&lt;br /&gt;
독립변수에 &lt;code&gt;hp&lt;/code&gt;, &lt;code&gt;sqrt(wt)&lt;/code&gt; 가 따로따로 고려되고 &lt;code&gt;carb&lt;/code&gt; 변수가 독립변수로 제외됨을 명시할 뿐이다.&lt;/p&gt;
&lt;p&gt;다시 &lt;code&gt;I()&lt;/code&gt; 함수를 이용한 결과로 돌아가 보면 &lt;code&gt;I()&lt;/code&gt; 의 쓰임은 결국 &lt;code&gt;formula&lt;/code&gt; 인자의 약속된 문법을 escape 하는 역할로 볼 수도 있겠다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;formula&lt;/code&gt; 인자에 입력할 값의 사용방법과 기호의 의미를 정리해 보았다.&lt;br /&gt;
위의 내용 외에도 더 많은 팁과 기호들의 조합을 생각해 볼 수 있을 것이다.&lt;/p&gt;
</description>
        <pubDate>Tue, 06 Dec 2016 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2016/12/06/formula_usage.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2016/12/06/formula_usage.html</guid>
        
        
        <category>R</category>
        
      </item>
    
  </channel>
</rss>
