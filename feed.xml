<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description></description>
    <link>https://lovetoken.github.io/</link>
    <atom:link href="https://lovetoken.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 19 Mar 2018 23:24:00 +0900</pubDate>
    <lastBuildDate>Mon, 19 Mar 2018 23:24:00 +0900</lastBuildDate>
    <generator>Jekyll v3.1.6</generator>
    
      <item>
        <title>Rmarkdown + Shiny + flexdashboard package 의 조합을 통한 대쉬보드 만들기 (네이버 연관검색어를 예제로)</title>
        <description>&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;최근 &lt;a href=&quot;https://lovetoken.gitbooks.io/r-dev-team-open-seminar/content/&quot;&gt;R dev team&lt;/a&gt; 과 세미나를 통해 자발적인 분석 도전과제를 만들고 코워킹을 하고 있다.&lt;br /&gt;
도전과제 중 첫 번째로 나온 결과물이 &lt;a href=&quot;https://lovetoken.gitbooks.io/r-dev-team-open-seminar/content/b3c4-c804-acfc-c81c/b124-c774-bc84-c5f0-ad00-ac80-c0c9-c5b4-cd94-cd9c-c800-c7a5-d504-b85c-adf8-b7a8-b9cc-b4e4-ae30.html&quot;&gt;네이버 연관검색어 추출 프로그램&lt;/a&gt;이다.&lt;br /&gt;
패키지화 하여 한 개의 함수만으로 연관검색어의 결과를 저장하고 표출하며 시각화하였다.&lt;br /&gt;
이어서 R을 모르는 타인에게도 우리가 쉽게 사용토록 해 보고자 shiny application을 만들어 보기로 하였다.&lt;/p&gt;
&lt;p&gt;필자는 정석적인 Shiny app 개발 방법보단 Rmarkdown 과 &lt;a href=&quot;https://rmarkdown.rstudio.com/flexdashboard/&quot;&gt;flexdashboard package&lt;/a&gt;를 조합하여 사용하면&lt;br /&gt;
대쉬보드를 손쉽게 만들 수 있고&lt;br /&gt;
대쉬보드의 특성상 결과물을 최대한 심플하게 만들려 노력할 것이기 때문에&lt;br /&gt;
자연스럽게 개발량도 줄어들 것으로 생각했다.&lt;/p&gt;
&lt;p&gt;개발량이 줄어들면 협업이 쉬워지고 진입장벽도 낮아지기 때문에 초심자와 제 3자에게 흥미를 유도할 수 있을 거라 기대하며&lt;br /&gt;
아래와 같은 영상을 만들어 보았다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;center&gt;
&lt;iframe width=&quot;90%&quot; height=&quot;400&quot; src=&quot;https://www.youtube.com/embed/UKw1YxQRPes&quot; frameborder=&quot;0&quot; allow=&quot;autoplay; encrypted-media&quot; allowfullscreen&gt;
&lt;/iframe&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt; 참고로 R dev team 은 성과물들을 R code 로 남기려 하고 있고 이를 &lt;a href=&quot;https://github.com/lovetoken/rdevteam&quot;&gt;rdevteam 패키지&lt;/a&gt;로 관리하려 하고 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(devtools)
&lt;span class=&quot;kw&quot;&gt;install_github&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;ntels-BI/ntelsBI&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;를 통해서 설치가 가능하며&lt;br /&gt;
현재 이를 설치하면 영상에 있는 &lt;code&gt;naverRelation()&lt;/code&gt; 함수를 이용할 수 있고&lt;br /&gt;
그대로 재현할 수 있을 것이다.&lt;/p&gt;
</description>
        <pubDate>Mon, 19 Mar 2018 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2018/03/19/flexdashboard.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2018/03/19/flexdashboard.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>R에서 테이블 형 객체를 파일단위로 저장할 때 특화된 fst package</title>
        <description>&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;데이터 프레임 형을 파일단위로 저장할 때 R에서는 다양한 방법들이 있다.&lt;br /&gt;
크게 유형 분류를 하면&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;csv 와 같은 텍스트형으로 저장하는 방법&lt;/li&gt;
&lt;li&gt;이진 형태, 즉 binary 파일로 저장하는 방법&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;으로 나눌 수 있는데&lt;br /&gt;
호환성을 위해선 1번 방법이 좋지만, 저장 및 로드하는 속도, 파일의 볼륨을 줄이기 위한 압축 부분을 포기해야 하고,&lt;br /&gt;
속도를 위해선 2번 방법이 좋지만 텍스트에디터 등으로 파일을 간편하게 확인하는 것을 포기해야 하는 등&lt;br /&gt;
유형별로 장단점이 있다.&lt;/p&gt;
&lt;p&gt;본 글은 2번 이진 형태의 방법으로 R에서 데이터 프레임의 정보를 파일로 저장하는 방법 중 읽고 쓰는 속도가 상대적으로 빠른 편인 &lt;a href=&quot;http://www.fstpackage.org/&quot;&gt;fst package&lt;/a&gt; 를 이용한 방법을 소개하고자 한다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;benchmark&quot;&gt;Benchmark&lt;/h2&gt;
&lt;p&gt;소개에 앞서 처리속도가 다른 방법에 비교해 얼마나 빠른지 결과를 먼저 확인 해 보고 싶었다.&lt;br /&gt;
아래 코드는 샘플 데이터프레임을 만든 다음&lt;br /&gt;
오늘 주제인 fst 형으로 저장하는 방법과 그 외의 방법들로 저장하는 코드별 코드수행 시간을 측정하여 plotting 해 보는 코드이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(dplyr)
&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(microbenchmark)

nr_of_rows &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;^&lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;

df &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;data.frame&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;Logical =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;sample&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(T, F, &lt;span class=&quot;ot&quot;&gt;NA&lt;/span&gt;), &lt;span class=&quot;dt&quot;&gt;prob =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(.&lt;span class=&quot;dv&quot;&gt;85&lt;/span&gt;, .&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, .&lt;span class=&quot;dv&quot;&gt;05&lt;/span&gt;), nr_of_rows, &lt;span class=&quot;dt&quot;&gt;replace =&lt;/span&gt; T), 
                 &lt;span class=&quot;dt&quot;&gt;Integer =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;sample&lt;/span&gt;(1L:100L, nr_of_rows, &lt;span class=&quot;dt&quot;&gt;replace =&lt;/span&gt; T), 
                 &lt;span class=&quot;dt&quot;&gt;Real =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;sample&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;sample&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;10000&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt;) /&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;, nr_of_rows, &lt;span class=&quot;dt&quot;&gt;replace =&lt;/span&gt; T),
                 &lt;span class=&quot;dt&quot;&gt;Factor =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;as.factor&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;sample&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;labels&lt;/span&gt;(UScitiesD), nr_of_rows, &lt;span class=&quot;dt&quot;&gt;replace =&lt;/span&gt; T))) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;tbl_df

df&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 100,000,000 x 4
##    Logical Integer  Real Factor       
##    &amp;lt;lgl&amp;gt;     &amp;lt;int&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;fct&amp;gt;        
##  1 T            30  97.6 Chicago      
##  2 T            42  61.0 Atlanta      
##  3 NA           21  97.6 Chicago      
##  4 T             3  97.6 Miami        
##  5 T            89  48.2 Washington.DC
##  6 T            52  62.9 SanFrancisco 
##  7 T            41  31.5 NewYork      
##  8 T            38  47.1 Chicago      
##  9 T            21  48.2 Denver       
## 10 T            78  48.2 Denver       
## # ... with 99,999,990 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;저장대상으로 테스트에 쓸 데이터프레임 &lt;code&gt;df&lt;/code&gt; 를 만들어 보았다.&lt;br /&gt;
1억건의 레코드를 가진 데이터프레임이다.&lt;br /&gt;
이 &lt;code&gt;df&lt;/code&gt; 를&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;write.table&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;data.table::fwrite&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;saveRDS&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;feather::write_feather&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fst::write_fst&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;의 5개 방법별로 저장하는 시간을 반복측정하는 것을 microbenchmark package 의 도움을 받아 실행해 본다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;bench &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;microbenchmark&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;write.table =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;write.table&lt;/span&gt;(df, &lt;span class=&quot;dt&quot;&gt;file =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;output/df_writetable.csv&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;quote =&lt;/span&gt; F, &lt;span class=&quot;dt&quot;&gt;row.names =&lt;/span&gt; F, &lt;span class=&quot;dt&quot;&gt;sep =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;,&amp;quot;&lt;/span&gt;),
                        &lt;span class=&quot;dt&quot;&gt;fwrite =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;fwrite&lt;/span&gt;(df, &lt;span class=&quot;dt&quot;&gt;file =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;output/df_fwrite.csv&amp;quot;&lt;/span&gt;),
                        &lt;span class=&quot;dt&quot;&gt;saveRDS =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;saveRDS&lt;/span&gt;(df, &lt;span class=&quot;dt&quot;&gt;file =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;output/df_saveRDS.rds&amp;quot;&lt;/span&gt;),
                        &lt;span class=&quot;dt&quot;&gt;write_feather =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;write_feather&lt;/span&gt;(df, &lt;span class=&quot;dt&quot;&gt;path =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;output/df_feather.fea&amp;quot;&lt;/span&gt;),
                        &lt;span class=&quot;dt&quot;&gt;write_fst =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;write_fst&lt;/span&gt;(df, &lt;span class=&quot;dt&quot;&gt;path =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;output/df_fst.fst&amp;quot;&lt;/span&gt;), &lt;span class=&quot;dt&quot;&gt;times =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;autoplot&lt;/span&gt;(bench)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/fstPackage.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;fst 형으로 저장하는 방법이 약 2.52초로 다른 방법들에 비해 비약적으로 빠른 것을 볼 수 있다.&lt;/p&gt;
&lt;p&gt;쓰기 속도 외에도 읽기 속도 역시 좋은 성능을 보인다.&lt;/p&gt;
&lt;p&gt;읽기 테스트는 생략하지만 &lt;a href=&quot;http://www.fstpackage.org/&quot;&gt;fst package 홈페이지&lt;/a&gt;에 지금까지의 벤치마킹과 비슷한 실험 결과물이 소개되었으니 참고해 보면 좋겠다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;사용법&quot;&gt;사용법&lt;/h2&gt;
&lt;p&gt;벤치마킹 테스트 코드에 fst 형으로 저장하는 방법에 대한 코드가 있었다. 바로 이 부분인데&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;write_fst&lt;/span&gt;(df, &lt;span class=&quot;dt&quot;&gt;path =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;output/df_fst.fst&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;저장시킬 데이터프레임 객체명, 저장시킬 파일경로를 지정 이 두 가지가 필수이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;data &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;read_fst&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;output/df_fst.fst&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;읽는 방법은 &lt;code&gt;read_fst()&lt;/code&gt; 함수안에 이전에 저장시킨 파일경로를 지정하고 할당하는 방식이다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;특징&quot;&gt;특징&lt;/h2&gt;
&lt;p&gt;fst package 는 여러 특징이 있는데 가장 눈에 띄는 특징은&lt;br /&gt;
자동적으로 병렬스레드를 이용하여 저장 및 읽는 처리속도의 효율을 높인다는 것이다.&lt;br /&gt;
볼륨이 큰 데이터프레임을 &lt;code&gt;write_fst()&lt;/code&gt; 함수로 저장하곤 할 때 이러한 로그가 나타나는 것을 보면 알 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;write_fst&lt;/span&gt;(df, &lt;span class=&quot;dt&quot;&gt;path =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;output/df_fst.fst&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Written 9.6% of 100000000 rows in 2 secs using 4 threads. anyBufferGrown=no; maxBuffUsed=37%. Finished in 18 secs.      
Written 15.8% of 100000000 rows in 3 secs using 4 threads. anyBufferGrown=no; maxBuffUsed=37%. Finished in 15 secs.      
Written 22.5% of 100000000 rows in 4 secs using 4 threads. anyBufferGrown=no; maxBuffUsed=37%. Finished in 13 secs.      
Written 28.7% of 100000000 rows in 5 secs using 4 threads. anyBufferGrown=no; maxBuffUsed=37%. Finished in 12 secs.      
Written 33.7% of 100000000 rows in 6 secs using 4 threads. anyBufferGrown=no; maxBuffUsed=37%. Finished in 11 secs.      
Written 40.4% of 100000000 rows in 7 secs using 4 threads. anyBufferGrown=no; maxBuffUsed=37%. Finished in 10 secs.      
Written 46.6% of 100000000 rows in 8 secs using 4 threads. anyBufferGrown=no; maxBuffUsed=37%. Finished in 9 secs.      
Written 51.6% of 100000000 rows in 9 secs using 4 threads. anyBufferGrown=no; maxBuffUsed=37%. Finished in 8 secs.      
Written 57.2% of 100000000 rows in 10 secs using 4 threads. anyBufferGrown=no; maxBuffUsed=37%. Finished in 7 secs.      
Written 62.8% of 100000000 rows in 11 secs using 4 threads. anyBufferGrown=no; maxBuffUsed=37%. Finished in 6 secs.      
Written 67.8% of 100000000 rows in 12 secs using 4 threads. anyBufferGrown=no; maxBuffUsed=37%. Finished in 5 secs.      
Written 72.8% of 100000000 rows in 13 secs using 4 threads. anyBufferGrown=no; maxBuffUsed=37%. Finished in 4 secs.      
Written 77.9% of 100000000 rows in 14 secs using 4 threads. anyBufferGrown=no; maxBuffUsed=37%. Finished in 3 secs.      
Written 82.9% of 100000000 rows in 15 secs using 4 threads. anyBufferGrown=no; maxBuffUsed=37%. Finished in 3 secs.      
Written 88.5% of 100000000 rows in 16 secs using 4 threads. anyBufferGrown=no; maxBuffUsed=37%. Finished in 2 secs.      
Written 93.5% of 100000000 rows in 17 secs using 4 threads. anyBufferGrown=no; maxBuffUsed=37%. Finished in 1 secs.      
Written 97.4% of 100000000 rows in 18 secs using 4 threads. anyBufferGrown=no; maxBuffUsed=37%. Finished in 0 secs.  &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;data.table package 의 &lt;code&gt;fwrite()&lt;/code&gt;, &lt;code&gt;fread()&lt;/code&gt; 에서도 가지고 있는 기능이지만 fst package가 조금 더 높은 성능을 &lt;a href=&quot;http://www.fstpackage.org/README-multi-threading-1.png&quot;&gt;보이기도 한다&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;압축저장도 지원한다.&lt;br /&gt;
&lt;code&gt;write_fst()&lt;/code&gt; 함수의 인자들을 살펴보면 &lt;code&gt;compress&lt;/code&gt; 인자가 있고 기본적으로 50인데 이를 조정하여 압축률을 높이거나 낮출 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;write_fst&lt;/span&gt;(df, &lt;span class=&quot;dt&quot;&gt;path =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;output/compress_1.fst&amp;quot;&lt;/span&gt;,   &lt;span class=&quot;dt&quot;&gt;compress =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;write_fst&lt;/span&gt;(df, &lt;span class=&quot;dt&quot;&gt;path =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;output/compress_50.fst&amp;quot;&lt;/span&gt;,  &lt;span class=&quot;dt&quot;&gt;compress =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;50&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;write_fst&lt;/span&gt;(df, &lt;span class=&quot;dt&quot;&gt;path =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;output/compress_100.fst&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;compress =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;system&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;ls -lh output/compress*&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;-rw-r--r--@ 1 lovetoken  staff   1.2G Mar  1 10:21 output/compress_1.fst
-rw-r--r--@ 1 lovetoken  staff   247M Mar  1 10:22 output/compress_100.fst
-rw-r--r--@ 1 lovetoken  staff   582M Mar  1 10:21 output/compress_50.fst&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;압축률을 1로 한 것과 100으로 한 것 간의 파일 용량이 각각 1.2Gb, 247Mb 으로 차이가 큰 것을 볼 수 있다.&lt;/p&gt;
&lt;p&gt;마지막으로..&lt;br /&gt;
fst package 가 혹 &lt;code&gt;save()&lt;/code&gt;, &lt;code&gt;saveRDS()&lt;/code&gt; 처럼 R 객체를 저장할 수 있다고 생각하면 안 된다.&lt;br /&gt;
서두에도 말했듯이 데이터프레임 형 객체만 저장할 수 있다.&lt;br /&gt;
데이터프레임 형을 저장하는데 특화된 것이 특징이라면 특징이겠다.&lt;/p&gt;
</description>
        <pubDate>Thu, 01 Mar 2018 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2018/03/01/fstPackage.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2018/03/01/fstPackage.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>R에서 Benchmarking 패키지를 이용한 자료포락분석(Data Envelopment Analysis) 이용하기</title>
        <description>&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;약 5년전 컨설팅 인턴 일을 하면서 자료포락분석&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;(Data envelopment analysis 이하 DEA)이 필요했던 시점이 있다.&lt;br /&gt;
그때 당시 실제로 분석을 하기 위하여 컴퓨터 프로그램을 이용할 필요가 있었고&lt;br /&gt;
&lt;a href=&quot;http://expertchoice.co.kr/expert_choice.html&quot;&gt;Export choice&lt;/a&gt; 프로그램을 이용해 DEA 분석을 한 논문들을 상당수 찾을 수 있었다.&lt;br /&gt;
하지만 Export choice 는 상용 프로그램이었고 새로 알아야 된다는 점들 때문에 빠르게 시도해 볼 수 없었다.&lt;br /&gt;
이때는 깊은 분석보단 만만하게 시도해 볼 수 있었던 환경이 필요했었는데&lt;br /&gt;
마침 DEA 를 해볼 수 있는 R package 가 있었고 그 패키지 이름은 Benchmarking 이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;install.packages&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;Benchmarking&amp;quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(Benchmarking)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Benchmarking 패키지의 &lt;code&gt;dea()&lt;/code&gt; 함수를 이용하여 얼마든지 벤치마킹의 대상이 되는 의사결정단위(자료포괄분석에서 이를 Decision Making Unit. DMU로 줄여 표현한다) 별 efficiencies 값들을 구해낼 수 있었다.&lt;br /&gt;
우선 투입요소와 산출요소가 정해지고 그에 따른 정량적인 데이터가 존재하면&lt;br /&gt;
각 DMU 에 대한 효율성 평가를 수행할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;예제-데이터에-대한-설명&quot;&gt;예제 데이터에 대한 설명&lt;/h2&gt;
&lt;p&gt;Benchmarking package 안에 있는 데이터 셋 중 하나인 &lt;code&gt;charnes1981&lt;/code&gt; 을 예제로 DEA를 간단히 수행해 보겠다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;set.seed&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1004&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(dplyr)

&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt;(charnes1981)
charnes1981 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;charnes1981 %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;tbl_df %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;sample_n&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt;)
charnes1981&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 20 x 11
##     firm    x1    x2    x3    x4    x5    y1    y2    y3   pft
##    &amp;lt;int&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;int&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;int&amp;gt;
##  1    20 25.42  9.05 29.69 31.74     4 29.43 42.63 23.34     1
##  2    17 22.63  4.43 15.40 15.00     2 17.25 20.80 12.07     1
##  3    53 16.20  7.02 26.94 26.30     9 18.23 22.05 17.56     0
##  4    66 23.32  7.10 24.96 28.56    22 16.81 19.72 18.70     0
##  5    29 10.62  2.55 10.10  9.09     4  6.51  7.02  6.16     1
##  6    60 16.28  4.81 18.20 18.98     5 15.15 18.04 13.58     0
##  7    32  6.30  1.93  7.11  7.68     4  4.59  6.16  4.99     1
##  8    24 19.74  6.43 24.20 25.66     3 25.72 30.81 16.54     1
##  9    64 28.38  8.91 30.95 33.33     8 18.63 24.48 23.13     0
## 10    27 27.20  9.38 37.80 31.55     4 31.31 38.32 25.03     1
## 11    15  4.29  5.42 21.45 17.27     5 14.39 18.30 14.33     1
## 12    22 16.34  5.84 20.89 22.10     4 19.40 25.18 16.52     1
## 13     5 11.62  2.21  6.85  6.37     4  7.81  6.94  5.37     1
## 14     9 34.40 11.04 38.16 42.40     8 26.13 29.80 26.29     1
## 15    45  8.32  3.64 12.92 13.13     2  9.47 11.92  8.85     1
## 16     2 29.26 10.24 41.96 40.65     5 24.69 33.89 26.02     1
## 17    11 52.92 11.67 39.48 39.64     5 39.80 37.73 30.29     1
## 18    49  7.14  5.29 23.10 19.06     8 12.17 16.03 15.82     1
## 19    51 11.88  3.59 13.41 13.82     8  9.96 14.34  9.33     0
## 20    54 82.45 15.52 45.00 44.23    13 59.63 64.41 35.89     0
## # ... with 1 more variables: name &amp;lt;fctr&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;data 를 불러온 후&lt;br /&gt;
설명의 편의상 tibble type 으로 &lt;code&gt;charnes1981&lt;/code&gt; 형을 변환 및 20개의 샘플링을 하였다. &lt;a href=&quot;#fn2&quot; class=&quot;footnoteRef&quot; id=&quot;fnref2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;br /&gt;
각 변수들에 대한 설명은 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;firm&lt;/code&gt; : 학교별 ID&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;name&lt;/code&gt; : 주소&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x1&lt;/code&gt; : education level of the mother&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x2&lt;/code&gt; : highest occupation of a family member&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x3&lt;/code&gt; : parental visits to school&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x4&lt;/code&gt; : time spent with children in school-related topics&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;x5&lt;/code&gt; : the number of teachers at the site&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;y1&lt;/code&gt; : reading score&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;y2&lt;/code&gt; : math score&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;y3&lt;/code&gt; : self–esteem score&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;x로 시작하는 변수들은 각 학교들에 대한 독립변수(투입요소) 로 볼 수 있고&lt;br /&gt;
y로 시작하는 변수들은 그 학교에 대한 평가이므로 종속변수(산출요소) 로 볼 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;dea-분석&quot;&gt;DEA 분석&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;X &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;charnes1981 %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;starts_with&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;x&amp;quot;&lt;/span&gt;)) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;as.matrix

Y &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;charnes1981 %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;starts_with&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;y&amp;quot;&lt;/span&gt;)) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;as.matrix   

dea_res &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;dea&lt;/span&gt;(X, Y)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;dea()&lt;/code&gt; 함수의&lt;br /&gt;
첫번째 인자에는 투입변수에 대한 데이터를 matrix 형으로 입력한다.&lt;br /&gt;
위의 예제 경우 5개의 투입변수가 존재하므로 &lt;code&gt;X&lt;/code&gt; 처럼 적절하게 묶어주었다.&lt;/p&gt;
&lt;p&gt;두번째 인자에는 산출변수에 대한 데이터를 역시 matrix 형으로 입력한다.&lt;br /&gt;
마찬가지로 3개의 산출변수를 적절히 묶은 &lt;code&gt;Y&lt;/code&gt; 를 입력했다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dea()&lt;/code&gt; 함수로 반환되는 결과물들은 다양하다.&lt;br /&gt;
관심대상이 효율성 점수만이라면 아래처럼 &lt;code&gt;eff&lt;/code&gt; 속성값만을 호출해 본다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;dea_res$eff&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##  [1] 1.0000000 1.0000000 0.8844074 0.9541975 0.9326048 0.9964845 1.0000000
##  [8] 1.0000000 0.9804835 1.0000000 1.0000000 1.0000000 1.0000000 0.9850544
## [15] 1.0000000 1.0000000 1.0000000 1.0000000 0.9713179 1.0000000&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;의사결정단위 70개 별 Efficiencies 값이 출력된다.&lt;br /&gt;
학교주소별 Efficiencies 값을 매치시켜 표현해보거나&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data.frame&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;School_site_name =&lt;/span&gt; charnes1981$name, &lt;span class=&quot;dt&quot;&gt;Efficiencies =&lt;/span&gt; dea_res$eff)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##    School_site_name Efficiencies
## 1            Racine    1.0000000
## 2          New York    1.0000000
## 3            Fresno    0.8844074
## 4      Jacksonville    0.9541975
## 5           Chigago    0.9326048
## 6      Philidelphia    0.9964845
## 7      Jacksonville    1.0000000
## 8      Portageville    1.0000000
## 9             Flint    0.9804835
## 10         Meridian    1.0000000
## 11       Fall River    1.0000000
## 12         New York    1.0000000
## 13          Lebanon    1.0000000
## 14         Lakewood    0.9850544
## 15         New York    1.0000000
## 16          Buffalo    1.0000000
## 17          Wichita    1.0000000
## 18         San Jose    1.0000000
## 19          Buffalo    0.9713179
## 20          Lebanon    1.0000000&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;아래 plotting 결과물 처럼&lt;br /&gt;
제공되는 &lt;code&gt;dea.plot.frontier()&lt;/code&gt; 함수 결과물인 효율최적선을 통해&lt;br /&gt;
상대적인 효율성 평가를 하는데 용이할 것이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;dea.plot.frontier&lt;/span&gt;(X, Y, &lt;span class=&quot;dt&quot;&gt;txt =&lt;/span&gt; T)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/DEA_1.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dea()&lt;/code&gt; 함수는 DEA분석 주제에 대한 대부분의 기능을 총괄하고 있기 때문에 복잡하고, 제공되는 인자들도 많다.&lt;br /&gt;
투입 혹은 산출 관점에 따라 분석방법이 달라지기도 하고,&lt;br /&gt;
가정이 달라지기도 한다.&lt;br /&gt;
위의 예제처럼 인자의 조종 없이 &lt;code&gt;dea()&lt;/code&gt; 함수를 이용하면 기본값 설정을 따르는데&lt;br /&gt;
투입기준의 Variable returns to scale 가정을 기반하에 효율성 평가를 한다. (자세한건 &lt;code&gt;RTS&lt;/code&gt;, &lt;code&gt;ORIENTATION&lt;/code&gt; 인자의 도움말을 살펴본다)&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;분석-결과-해석&quot;&gt;분석 결과 해석&lt;/h2&gt;
&lt;p&gt;Efficiency 값이 1인 학교는 투입대비 산출 즉 효율성이 20개의 DMU 와 상대적으로 비교했을 때 가장 높다고 할 수 있다.&lt;br /&gt;
하지만 이는 절대적인 효율성 평가가 아닌 상대적 효율성 평가라는 것을 항상 염두해야 한다.&lt;/p&gt;
&lt;p&gt;Efficiency 값이 1 미만인 학교는&lt;br /&gt;
1의 값을 가진 학교보다 비효율이 발생하고 있다는것을 의미하며&lt;br /&gt;
그 값이 작으면 작을수록 비효율이 크다고 해석은 가능하다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://book.naver.com/bookdb/book_detail.nhn?bid=6874299&quot;&gt;책 : 효율성분석이론 DEA 자료포락분석법 - 이정동, 오동현 (지필미디어) 2012.03.30&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;자료포괄분석 으로도 불리는데 무엇이 맞는지는 모르겠다&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn2&quot;&gt;&lt;p&gt;원 데이터의 개수는 70개이며 이중 20개의 랜덤샘플링을 의미함&lt;a href=&quot;#fnref2&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Mon, 22 Jan 2018 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2018/01/22/EDA.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2018/01/22/EDA.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>변동계수의 개념과 R에서의 실습</title>
        <description>&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;변동계수(coefficient of variation, C.V)는 평균이 크게 다른 두개 이상의 집단이 있을때&lt;br /&gt;
각 집단의 상대적 동질성을 감안한 산포도의 척도이다.&lt;/p&gt;
&lt;p&gt;변동계수에 대한설명을 위하여 아래 예시를 준비했다.&lt;/p&gt;
&lt;p&gt;3개의 샘플에 대한 물 용량을 측정한 예시가 있다.&lt;br /&gt;
이 3개의 샘플을 두 사람이 측정해 보고했다고 치자.&lt;br /&gt;
그런데 측정 단위에 대한 언급이 따로 없어 한사람은 리터 단위로, 한사람은 밀리리터 단위로 조사를 했다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;l &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;54&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;50&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;52&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# 물 리터단위(L)측정&lt;/span&gt;
ml &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;54017&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;49980&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;52003&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# 물 밀리리터단위(mL)측정&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;mean&lt;/span&gt;(l)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] 52&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;mean&lt;/span&gt;(ml)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] 52000&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;sd&lt;/span&gt;(l)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] 2&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;sd&lt;/span&gt;(ml)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] 2018.502&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;분명 같은 집단을 두 조사자는 조사했지만 측정단위의 차이로 인해 평균과 표준편차가 확연히 다르므로&lt;br /&gt;
이 내막을 모르는 사람에게는, 그리고 샘플의 개수가 인지하기 힘들정도로 많았을 때&lt;br /&gt;
두 집단이 다른것으로 대강 판단할 위험이 있다.&lt;/p&gt;
&lt;p&gt;리터단위로 측정시 표준편차는 2, 평균은 52로 계산되고&lt;br /&gt;
밀리리터단위로 측정시 표준편차와 평균은 리터단위로 계산한 표준편차보다 1000배 정도 높히 계산된다.&lt;/p&gt;
&lt;p&gt;여기서 단위의 차이로 생겨버린 이 1000배를 보정하는것이 변동계수의 기능이라고 볼 수 있는데&lt;br /&gt;
변동계수는 표준편차를 평균으로 나누는것으로 간단히 계산된다.&lt;br /&gt;
결과적으로 단위와 무관하게 계산되어 다른단위로 측정된 자료들의 산포를 비교할때 표준편차보다 유용한 지표가 된다.&lt;br /&gt;
이러한 점에서 변동계수를 상대표준편차(relative standard deviation, RSD)라고도 부른다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;sd&lt;/span&gt;(l) /&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;mean&lt;/span&gt;(l) &lt;span class=&quot;co&quot;&gt;# 리터단위 측정 샘플에 대한 변동계수&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.03846154&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;sd&lt;/span&gt;(ml) /&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;mean&lt;/span&gt;(ml) &lt;span class=&quot;co&quot;&gt;# 밀리리터단위 측정 샘플에 대한 변동계수&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.03881734&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;직접 계산해 보면 거의 비슷한 값으로 계산된다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;other-example&quot;&gt;other example&lt;/h2&gt;
&lt;p&gt;어떠한 백분율 값을 측정한 것으로 보이는 두 그룹이 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;group1 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;86&lt;/span&gt;,   &lt;span class=&quot;dv&quot;&gt;85&lt;/span&gt;,   &lt;span class=&quot;dv&quot;&gt;92&lt;/span&gt;,   &lt;span class=&quot;dv&quot;&gt;89&lt;/span&gt;,   &lt;span class=&quot;dv&quot;&gt;83&lt;/span&gt;,   &lt;span class=&quot;dv&quot;&gt;90&lt;/span&gt;,   &lt;span class=&quot;dv&quot;&gt;88&lt;/span&gt;,   &lt;span class=&quot;dv&quot;&gt;91&lt;/span&gt;,   &lt;span class=&quot;dv&quot;&gt;79&lt;/span&gt;,   &lt;span class=&quot;dv&quot;&gt;83&lt;/span&gt;)
group2 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;fl&quot;&gt;0.88&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;0.91&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;0.94&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;0.84&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;0.97&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;0.89&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;0.99&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;0.88&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;0.89&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;0.96&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;group1&lt;/code&gt; 은 100을 곱한 백분율의 상태 &lt;code&gt;group2&lt;/code&gt; 는 0~1 범위의 백분율 상태이다.&lt;br /&gt;
실제로 위와 같은 예는 조사자의 취향에 따라 단위가 통일되지 못하는 사례로 많다.&lt;/p&gt;
&lt;p&gt;당연히 이 둘의 데이터 산포도를 측정하고자&lt;br /&gt;
표준편차를 구하게 될 때 &lt;code&gt;group1&lt;/code&gt; 의 표준편차가 작을것이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;sd&lt;/span&gt;(group1)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] 4.141927&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;sd&lt;/span&gt;(group2)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.04790036&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;산포도의 공평한 비교가 될 수 없기에&lt;br /&gt;
&lt;code&gt;group2&lt;/code&gt; 자료에 100을 곱한 후 표준편차를 다시 구하거나&lt;br /&gt;
반대로 &lt;code&gt;group1&lt;/code&gt; 자료에 100을 나누어 표준편차를 구하게 될 것이다.&lt;br /&gt;
하지만 이는 급한마음에 거치는 긁어 부스럼 같은 절차이며&lt;br /&gt;
원 데이터를 보존하지 못하는 방법이므로 상황에 따라 위험성이 있을 것이다.&lt;br /&gt;
이때 변동계수를 이용하는것이 좋을것이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;sd&lt;/span&gt;(group1) /&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;mean&lt;/span&gt;(group1)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.04782825&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;sd&lt;/span&gt;(group2) /&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;mean&lt;/span&gt;(group2)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.05235012&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;변동계수를 구한결과 &lt;code&gt;group2&lt;/code&gt; 이 &lt;code&gt;group1&lt;/code&gt; 보다 변동계수가 더 컸다.&lt;br /&gt;
즉 상대적으로 &lt;code&gt;group2&lt;/code&gt; 의 퍼짐정도가 &lt;code&gt;group1&lt;/code&gt; 보다 크다는 결론을 낼 수 있다.&lt;/p&gt;
</description>
        <pubDate>Sun, 14 Jan 2018 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2018/01/14/CV.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2018/01/14/CV.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>라즈베리파이 초기상태의 pi 계정에서 root 비밀번호 변경</title>
        <description>&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;라즈베리파이를 처음 구동하면 pi 계정으로 로그인이 된다.&lt;br /&gt;
구입 후 초기상태의 상황에서&lt;br /&gt;
나는 분명분명 라즈베리파이의 주인인데도 불구하고&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ apt-get update&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;를 할때 Permission denied 이 발생하는 등 root 권한을 사용할 수 없는 상태어서 당황스러웠다 &lt;i class=&quot;fa fa-meh-o&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ su&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;로 root 로그인을 하려했으나&lt;br /&gt;
당연하게도 비밀번호를 알 수 없어 불가능하다.&lt;/p&gt;
&lt;p&gt;이때&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo passwd root&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;로 root 비밀번호를 처음으로 설정할 수 있고 이후 root 권한을 이용할 수 있다.&lt;/p&gt;
</description>
        <pubDate>Sat, 13 Jan 2018 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/etc/2018/01/13/raspberrypi_rootpasswd.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/etc/2018/01/13/raspberrypi_rootpasswd.html</guid>
        
        
        <category>etc</category>
        
      </item>
    
      <item>
        <title>R에서 all.equal() 함수를 이용한 객체의 동일성 확인하기</title>
        <description>&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;수학을 공부할 때 종종 이런일이 많았다.&lt;/p&gt;
&lt;p&gt;원 공식에 의해 계산이 불가하거나 손으로 풀기 복잡할 경우 근사치에 대한 간편공식을 배우게 되는 경우가 있다.&lt;br /&gt;
그 간편공식으로써 풀은 결과물이 원 공식으로 풀은 결과물과 동일한지 비교해보는 작업을 R을 이용하여 자주 하곤 했다.&lt;br /&gt;
만약 그 결과물이 어떤 하나의 스칼라값으로 나온다면,&lt;br /&gt;
금방 비교하여 동일한지 여부를 파악할 수 있다.&lt;br /&gt;
R을 이용한다면 논리연산자를 이용해 빠르고 정확하게 비교가 가능할 것이다.&lt;br /&gt;
&lt;code&gt;==&lt;/code&gt; 의 기호는 데이터셋의 원소별로 동일하면 TRUE, 틀리면 FALSE 를 반환하게 되므로 좌변과 우변이 같은지를 아래처럼 확인할 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;/&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; ==&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;804&lt;/span&gt;/&lt;span class=&quot;dv&quot;&gt;1206&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위의 예시처럼 쉽게 같은지 구분하기 힘든것을 논리연산자를 통해 동일한지 파악할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;all.equal-함수&quot;&gt;&lt;code&gt;all.equal()&lt;/code&gt; 함수&lt;/h2&gt;
&lt;p&gt;그런데 이러한 논리연산자 말고, R에서는 오늘 알아볼 &lt;code&gt;all.equal()&lt;/code&gt; 이란 함수가 있다.&lt;br /&gt;
이 함수의 쓰임은 비교하고자 하는 2개의 R객체가 동일한지를 확인해 준다.&lt;/p&gt;
&lt;p&gt;가끔, 아니 곧잘 대용량의 크기가 큰 데이터셋의 동일여부를 파악해야 할 때도 있을것이다.&lt;br /&gt;
아래와 같은 상황을 예로 들어 보겠다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;## 일반 행렬곱셈
A &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;matrix&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;round&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;rnorm&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;600&lt;/span&gt; *&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;400&lt;/span&gt;)), &lt;span class=&quot;dt&quot;&gt;nrow =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;600&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;ncol =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;400&lt;/span&gt;)
B &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;matrix&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;round&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;rnorm&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;400&lt;/span&gt; *&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;800&lt;/span&gt;)), &lt;span class=&quot;dt&quot;&gt;nrow =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;400&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;ncol =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;800&lt;/span&gt;)
AB &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;A %*%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;B

## 분할행렬 생성
A11 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;A[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;200&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;200&lt;/span&gt;]
A12 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;A[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;200&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;201&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;400&lt;/span&gt;]
A21 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;A[&lt;span class=&quot;dv&quot;&gt;201&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;600&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;200&lt;/span&gt;]
A22 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;A[&lt;span class=&quot;dv&quot;&gt;201&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;600&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;201&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;400&lt;/span&gt;]

B11 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;B[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;200&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;200&lt;/span&gt;]
B12 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;B[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;200&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;201&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;800&lt;/span&gt;]
B21 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;B[&lt;span class=&quot;dv&quot;&gt;201&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;400&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;200&lt;/span&gt;]
B22 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;B[&lt;span class=&quot;dv&quot;&gt;201&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;400&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;201&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;800&lt;/span&gt;]

partition_AB &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;rbind&lt;/span&gt;(
  &lt;span class=&quot;kw&quot;&gt;cbind&lt;/span&gt;(A11 %*%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;B11 +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;A12 %*%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;B21, A11 %*%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;B12 +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;A12 %*%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;B22),
  &lt;span class=&quot;kw&quot;&gt;cbind&lt;/span&gt;(A21 %*%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;B11 +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;A22 %*%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;B21, A21 %*%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;B12 +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;A22 %*%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;B22)
  ) &lt;span class=&quot;co&quot;&gt;# 분할행렬 생성 후 행렬곱셈&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위의 코드가 무엇인지 간략하게 설명하면&lt;br /&gt;
첫번째는 임의의 행렬 &lt;code&gt;A&lt;/code&gt;와 행렬 &lt;code&gt;B&lt;/code&gt;를 생성시킨 후, 두 행렬의 곱셈을 &lt;code&gt;AB&lt;/code&gt;로 할당한 것이며,&lt;br /&gt;
두번째는 행렬 &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt; 를 이와 같이 알맞게 분할한 후&lt;/p&gt;
&lt;center&gt;
&lt;br&gt;&lt;img src=&quot;/assets/allequal_1.png&quot;&gt;&lt;br&gt;
&lt;/center&gt;
&lt;p&gt;단 &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;A&lt;/em&gt;&lt;sub&gt;11&lt;/sub&gt;&lt;/span&gt;, &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;B&lt;/em&gt;&lt;sub&gt;11&lt;/sub&gt;&lt;/span&gt; 은 200×200 행렬&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;로 분할한 행렬을 이용하여 행렬 &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;를 곱한 것 이다.&lt;/p&gt;
&lt;center&gt;
&lt;br&gt;&lt;img src=&quot;/assets/allequal_2.png&quot;&gt;&lt;br&gt;
&lt;/center&gt;
&lt;p&gt;이처럼 곱한것을 객체 &lt;code&gt;partition_AB&lt;/code&gt;로 할당하였다.&lt;/p&gt;
&lt;p&gt;이론적으로는 첫번째 일반적인 곱셈과, 두번째 분할행렬을 이용한 곱셈과 값이 동일하다.&lt;br /&gt;
단 그것이 믿겨지지 않을 경우 직접 확인해 보고싶을 수 있다.&lt;br /&gt;
그런데 이때 애로사항이 있다.&lt;br /&gt;
&lt;code&gt;AB&lt;/code&gt; 와 &lt;code&gt;partition_AB&lt;/code&gt; 가 서로 동일하느냐 를 확인하기 위해선&lt;br /&gt;
두 행렬의 사이즈가 600×800 으로 매우 부담이 되는 크기이다.&lt;/p&gt;
&lt;p&gt;물론 논리연산자 == 를 써도 되겠지만, 문제는 이 논리연산자를 써서 아래 코드를 실행하게 될 경우&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;AB ==&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;partition_AB&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;행렬의 원소별 값이 동일한지에 대한 논리값을 600 × 800 = 480,000 개를 행렬 타입으로 거대하게 반환할 것이다. 거대하므로 눈으로 동일한지 확인이 어려울 것이다.&lt;br /&gt;
480,000개의 원소가 모두 &lt;code&gt;TRUE&lt;/code&gt; 인지를 확인하기 위해&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;all&lt;/span&gt;(AB ==&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;partition_AB)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;처럼 &lt;code&gt;all()&lt;/code&gt; 함수의 도움을 받을 수도 있겠지만&lt;br /&gt;
&lt;code&gt;all.equal()&lt;/code&gt; 함수를 사용하는것이 더 유용할 때가 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;all.equal&lt;/span&gt;(AB, partition_AB)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;함수이름 그대로 all equal 하면 &lt;code&gt;TRUE&lt;/code&gt;&lt;br /&gt;
그렇지 않을 경우 어디가 어떻게 틀린지 구체적으로 설명한다.&lt;br /&gt;
본 예제의 경우 원래의 행렬곱과 분할행렬의 곱이 같은경우의 예제이므로 &lt;code&gt;TRUE&lt;/code&gt; 를 반환한다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;all.equal()&lt;/code&gt; 함수는 객체가 동일한지의 판단하는 함수로써도 편리한 기능의 함수이지만,&lt;br /&gt;
기본적으로는 얼마나 가깝게 동일한지 정도를 확인할 수 있는 일종의 비교함수로 보고 사용하는것이 좋다.&lt;br /&gt;
함수 도움말의 제목에서도 &#39;Test if Two Objects are (Nearly) Equal&#39; 로 나와있고 괄호의 &amp;quot;Nearly&amp;quot; 가 눈에 띈다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;조금 더 체감하기 좋은 행렬의 연산예시를 들어보겠다.&lt;br /&gt;
R에서는 순환소수, 무한소수를 계산할 때, 즉 유리수가 아닌 무리수를 연산할 때 아주 미세한 값의 차이가 존재할 수 있다.&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;br /&gt;
하지만 이는 무리수를 굳이 소수점으로 표현하여 어떤 소수점자리 이후는 절단되어 버려지는 시스템 적인 문제일 뿐이다.&lt;/p&gt;
&lt;p&gt;아래 예시는 임의행렬 X와 그의 역행렬을 곱한것을 단위행렬과 비교해본 시뮬레이션이다.&lt;br /&gt;
행렬 X는 5×5 행렬이며 이론상으로는&lt;/p&gt;
&lt;center&gt;
&lt;br&gt;&lt;img src=&quot;/assets/allequal_3.png&quot;&gt;&lt;br&gt;
&lt;/center&gt;
&lt;p&gt;이 성립한다. 하지만&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;X &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;matrix&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;rnorm&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;25&lt;/span&gt;), &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;)
XtX &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;solve&lt;/span&gt;(X) %*%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;X

I_5 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;diag&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;)

XtX ==&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;I_5&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##       [,1]  [,2]  [,3]  [,4]  [,5]
## [1,] FALSE FALSE FALSE FALSE FALSE
## [2,] FALSE FALSE FALSE FALSE FALSE
## [3,] FALSE FALSE FALSE  TRUE FALSE
## [4,] FALSE FALSE FALSE  TRUE  TRUE
## [5,] FALSE FALSE FALSE FALSE FALSE&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;결과는 여기저기서 &lt;code&gt;FALSE&lt;/code&gt; 가 있고 실제로 값이 다르다. 전부 TRUE 이어야 하지만&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;table&lt;/span&gt;(XtX ==&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;I_5)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## 
## FALSE  TRUE 
##    22     3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이처럼 3개만 &lt;code&gt;TRUE&lt;/code&gt; 로 인식한다.&lt;br /&gt;
이처럼 무리수를 컴퓨터가 정확하게 표현할 수 없기 때문에 일어나는 일로 &lt;code&gt;XtX&lt;/code&gt; 나, &lt;code&gt;I_5&lt;/code&gt; 를 같지 않다고 판단하는것은 상황에 따라서 용인해야할 때가 있다.&lt;br /&gt;
이때 방금 언급한 &lt;code&gt;all.equal()&lt;/code&gt; 함수를 사용해 보면 어떨까?&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;all.equal&lt;/span&gt;(XtX, I_5)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;all.equal()&lt;/code&gt; 함수 내에는 &lt;code&gt;tolerance&lt;/code&gt; 인자가 존재하여 어느 정도의 차이는 단어 뜻대로 관용, 아량을 베풀어주는 로직이 있다.&lt;br /&gt;
따라서 &lt;code&gt;XtX&lt;/code&gt; 와, &lt;code&gt;I_5&lt;/code&gt; 는 그정도 차이는 무시하고 서로 동일하다고 판단하여 &lt;code&gt;TRUE&lt;/code&gt; 를 반환한다.&lt;br /&gt;
만약 관용, 아량을 전혀 베풀지 않는(&lt;code&gt;tolerance = 0&lt;/code&gt;)다면&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;all.equal&lt;/span&gt;(XtX, I_5, &lt;span class=&quot;dt&quot;&gt;tolerance =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;Mean relative difference: 2.806783e-15&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;두 객체간 차이의 아주 정확한 값을 반환한다.&lt;br /&gt;
분석을 하다보면 위의 예제 말고도 동등성을 확인하여야 할 때가 사뭇 많다.&lt;br /&gt;
이럴 때 &lt;code&gt;all.equal()&lt;/code&gt; 함수는 유용하게 사용될 수 있을것이다.&lt;/p&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;이는 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EB%B6%80%EB%8F%99%EC%86%8C%EC%88%98%EC%A0%90&quot;&gt;부동소수점&lt;/a&gt;으로 인한 문제이다&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Tue, 02 Jan 2018 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2018/01/02/allequal.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2018/01/02/allequal.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>인터넷 접속이 안되는 CentOS 머신에서 Python3 및 패키지 설치하기</title>
        <description>&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;본 글은 CentOS 최소설치버전으로 설치된 서버에서 (내부망 운용등의 이유로)인터넷 접속이 불가한 상황일 때 Python3 및 패키지를 설치하는 법에 대해 설명하기 위한 글이다.&lt;br /&gt;
패키지의 예시는 &lt;a href=&quot;http://konlpy-ko.readthedocs.io/ko/v0.4.3/&quot;&gt;konlpy&lt;/a&gt; 이다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;가상환경-준비&quot;&gt;가상환경 준비&lt;/h2&gt;
&lt;p&gt;설명을 위하여&lt;br /&gt;
설치의 대상이 되는 CentOS 최소설치 환경을 똑같이 재현할 필요가 있다.&lt;br /&gt;
CentOS 최소설치가 된 가상환경을 &lt;a href=&quot;https://www.docker.com/&quot;&gt;Docker&lt;/a&gt; 을 통해 준비해 보았다.&lt;br /&gt;
(Docker를 모른다면 본 장은 설명을 위한 CentOS 환경을 그대로 재현하기 위함이구나 하고 넘어가면 되겠다)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker run -it centos /bin/bash&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;CentOS 최소설치버전 이미지 다운로드한 후 컨테이너 실행하여 &lt;code&gt;/bin/bash&lt;/code&gt; 를 실행해 CentOS 쉘로 접속하게 된다.&lt;br /&gt;
접속된 환경은 인터넷이 가능한 상황이지만, 인터넷이 안되는 상황을 전제하에 Python3 및 konlpy 패키지를 수동으로 설치해 볼 것이다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;python3-설치파일-준비&quot;&gt;Python3 설치파일 준비&lt;/h2&gt;
&lt;p&gt;이제부턴 CentOS 쉘에서의 상황임을 염두해 둔다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ yum install -y https://centos7.iuscommunity.org/ius-release.rpm
$ yum search python36&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;IUS Community Project의 리포지토리를 yum의 리포지토리에 추가한 후 python36 검색해 본다.&lt;br /&gt;
&amp;quot;python36&amp;quot; 으로 시작되는 다양한 리스트들이 출력될 것이다.&lt;br /&gt;
참고로 yum 의 &lt;code&gt;-y&lt;/code&gt; 옵션 의미는 무조건 Yes로 입력하여 설치를 진행토록 하는 의미이다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mkdir ~/python3
$ cd ~/python3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;적당한 곳에 &lt;code&gt;python3&lt;/code&gt; 디렉토리를 만들고 그곳으로 간다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ yum install -y --downloadonly --downloaddir=. python36u python36u-libs python36u-devel python36u-pip&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Python3.6 버전대 패키지들을 설치하지 않고 다운로드만 하는 명령어이다. &lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;br /&gt;
위 명령어를 실행하면 관련된 패키지들의 rpm 을 워킹디렉토리(&lt;code&gt;~/python3&lt;/code&gt;)에 저장하게 된다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@e1e70169f547 python3]# ll
-rw-r--r-- 1 root root   56192 Aug  3 04:20 python36u-3.6.2-1.ius.centos7.x86_64.rpm
-rw-r--r-- 1 root root  204112 Aug  3 04:20 python36u-devel-3.6.2-1.ius.centos7.x86_64.rpm
-rw-r--r-- 1 root root 9689852 Aug  3 04:20 python36u-libs-3.6.2-1.ius.centos7.x86_64.rpm
-rw-r--r-- 1 root root 1841528 Feb  3  2017 python36u-pip-9.0.1-1.ius.centos7.noarch.rpm
-rw-r--r-- 1 root root  663324 Mar 22  2017 python36u-setuptools-33.1.1-1.ius.centos7.noarch.rpm&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;실제로 확인해 볼 경우 5개의 rpm 파일들이 준비된 것을 확인할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;konlpy-패키지-리소스-준비&quot;&gt;konlpy 패키지 리소스 준비&lt;/h2&gt;
&lt;p&gt;파이썬의 패키지를 준비하기 위해선 &lt;code&gt;pip&lt;/code&gt; 를 이용하는것이 좋다.&lt;br /&gt;
&lt;code&gt;pip&lt;/code&gt; 를 이용하기 위해서 방금 받은 rpm 을 이용해 파이썬을 설치한다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ yum install -y *&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;정상적으로 설치되면 이때부터 &lt;code&gt;python3.6&lt;/code&gt;, &lt;code&gt;pip3.6&lt;/code&gt; 명령어를 이용할 수 있게 된다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mkdir packages
$ cd packages&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;적당히 &lt;code&gt;~/python3/packages&lt;/code&gt; 디렉토리를 만들고 그곳으로 가자.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ pip3.6 install --download=. tag
$ pip3.6 install --download=. konlpy
$ pip3.6 install --download=. JPype1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위 명령어 중 첫번째는 tag package 에 대한 리소스 압축파일 (&lt;code&gt;.tag.gz&lt;/code&gt;) 을 포함한 의존성이 있는 리소스를 모두 현 워킹디렉토리에 저장만 한다.&lt;br /&gt;
즉 패키지들이 설치되지는 않는다.&lt;br /&gt;
konlpy 와 JPype1 패키지 역시 마찬가지로 리소스를 준비시킨다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@e1e70169f547 package]# ll
-rw-r--r-- 1 root root   147893 Oct 20 00:51 JPype1-0.6.2.tar.gz
-rw-r--r-- 1 root root    38404 Oct 20 00:52 intervaltree-2.1.0.tar.gz
-rw-r--r-- 1 root root 22454979 Oct 20 00:52 konlpy-0.4.4-py2.py3-none-any.whl
-rw-r--r-- 1 root root    32267 Oct 20 00:52 sortedcontainers-1.5.7-py2.py3-none-any.whl
-rw-r--r-- 1 root root    34414 Oct 20 00:52 tag-0.3.3.tar.gz&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;package 리소스 파일들이 준비되어 있는것을 확인할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;인터넷이-불가한-centos-에서의-python3.6-packages-설치&quot;&gt;인터넷이 불가한 CentOS 에서의 python3.6, packages 설치&lt;/h2&gt;
&lt;p&gt;인터넷이 불가했던 머신으로 시점을 옮긴다.&lt;br /&gt;
인터넷 접속이 안되었던 CentOS 서버에서 위에서 준비한 rpm, package 리소스들을 물리적으로 복사하여 가져온다.&lt;/p&gt;
&lt;p&gt;본 예제의 경우 Docker 가상환경을 기준으로 설명했는데&lt;br /&gt;
컨테이너 안에서 빠져나온 후 (&lt;code&gt;exit&lt;/code&gt; 로 빠져나올 수 있음)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker cp &amp;lt;컨테이너명&amp;gt;:~/python3/ &amp;lt;호스트 경로&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;의 방식으로 가상환경에 있던 rpm, package 리소스 들을&lt;br /&gt;
호스트로 떨어트린 후 USB 메모리등을 이용해 복사하여 인터넷이 불가한 CentOS 서버머신에 복사하면 되겠다.&lt;br /&gt;
참고로 컨테이너 명은 &lt;code&gt;docker ps -a&lt;/code&gt; 를 통해 확인이 가능하다.&lt;br /&gt;
아래 docker cp 명령어는 나의 컴퓨터에 꽂혀 있는 USB 메모리로 리소스들을 복사하는 예이다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker cp e1e70169f547:~/python3/ /Volumes/lovetoken_usb/&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(이외의 docker 를 이용하지 않은 상황에선 각자 상황에 따라 대처... 자세한 설명은 생략)&lt;/p&gt;
&lt;p&gt;자 이제부터는 인터넷이 불가한 CentOS 서버상황이라고 가정한다.&lt;br /&gt;
편의상 &lt;code&gt;~/python3&lt;/code&gt; 에 복사한 것을 붙어넣었다고 가정하겠다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd ~/python3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;복사한 python3 폴더로 간다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ yum install -y python36u-3.6.2-1.ius.centos7.x86_64.rpm python36u-devel-3.6.2-1.ius.centos7.x86_64.rpm python36u-libs-3.6.2-1.ius.centos7.x86_64.rpm python36u-pip-9.0.1-1.ius.centos7.noarch.rpm python36u-setuptools-33.1.1-1.ius.centos7.noarch.rpm&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 명령어를 통해서&lt;br /&gt;
yum 은 원격레파지토리를 검색하지 않고 &lt;code&gt;~/python3&lt;/code&gt; 에 있는 rpm 에 의존하여 파이썬을 설치하기 시작한다.&lt;br /&gt;
즉 수동으로 설치가 되는것이다.&lt;br /&gt;
역시 정상적으로 설치되면 &lt;code&gt;python3.6&lt;/code&gt;, &lt;code&gt;pip3.6&lt;/code&gt; 을 실행할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd packages&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;~/python3/packages&lt;/code&gt; 폴더로 가서 이젠 konlpy 패캐지 설치를 시도할 것이다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pip3.6 install *&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 명령어를 통해서 인터넷 연결없이 konlpy 관련 패키지들을 수동설치하게 된다.&lt;/p&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;덧붙임 : Ubuntu 에선 &lt;code&gt;apt-get -d install &amp;lt;package name&amp;gt;&lt;/code&gt; 으로 설치하지 않고 &lt;code&gt;.deb&lt;/code&gt; 파일들을 다운로드만 할 수 있다&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Sun, 22 Oct 2017 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/python/2017/10/22/python3_install_on_CentOS_manually.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/python/2017/10/22/python3_install_on_CentOS_manually.html</guid>
        
        
        <category>Python</category>
        
      </item>
    
      <item>
        <title>R에서 readr package 의 guess_encoding() 함수를 이용한 Text 파일의 인코딩 타입 추론</title>
        <description>&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;파일을 읽어 들일 때 인코딩 타입에 대한 이슈는 상당히 짜증 나는 유형의 이슈 중 하나라고 생각된다.&lt;br /&gt;
분석환경이 단독 운영체계만을 이용하여 분석한다면 큰 문제는 없겠지만&lt;br /&gt;
Linux 머신이나 Mac, Windows 등으로 넘나들게 되는 순간 데이터의 인코딩 타입을 고려해야 할 것이다.&lt;br /&gt;
통상적으로 이럴 때는 UTF-8 인코딩으로 통일하여 관리하지만&lt;br /&gt;
이것이 어려울 때 2개 이상의 인코딩 타입으로 데이터가 존재하게 될 것이다.&lt;/p&gt;
&lt;p&gt;그런데 인코딩 타입이 2개 이상 혼용되기 시작하면, 데이터를 읽어 들이고 내보내는 단계에서 인코딩타입까지 추가적으로 신경써야 한다는 점이 여러모로 피곤하게 느껴질 것이다.&lt;br /&gt;
데이터 I/O 단계에서 인코딩까지 신경써서 읽어들이는 것은 번거로운 일 일 수 있다.&lt;br /&gt;
애초에 이를 신경쓰는거 자체가 분석 본연에 있어 불필요한 요소일 수 있다.&lt;/p&gt;
&lt;p&gt;이번 글에서는 R에서 readr package 에 있는 &lt;code&gt;guess_encoding()&lt;/code&gt; 의 함수를 설명하고 소개할 것인데, R에서 데이터를 읽어 들이고 내보낼 시 인코딩 타입으로 인한 이슈들과 불편함을 겪는 사람들께 조금이나마 편의와 팁, 힌트를 주고자 작성한 글이다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;상황재현&quot;&gt;상황재현&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;d &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;read.csv&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;text =&lt;/span&gt; 
  &lt;span class=&quot;st&quot;&gt;&amp;quot;이름, 점수&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;  홍길동, 80&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;  철수, 91&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;  영희, 99&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;  Steve, 85&amp;quot;&lt;/span&gt;
)

&lt;span class=&quot;kw&quot;&gt;dir.create&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;data&amp;quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;write.csv&lt;/span&gt;(d, &lt;span class=&quot;st&quot;&gt;&amp;quot;data/Testdata_EUC-KR.csv&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;fileEncoding =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;EUC-KR&amp;quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;write.csv&lt;/span&gt;(d, &lt;span class=&quot;st&quot;&gt;&amp;quot;data/Testdata_UTF-8.csv&amp;quot;&lt;/span&gt;,  &lt;span class=&quot;dt&quot;&gt;fileEncoding =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;UTF-8&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위 코드는 &amp;quot;EUC-KR&amp;quot; 형과 &amp;quot;UTF-8&amp;quot; 형으로 작성된 간단한 데이터 테이블을 data 폴더안 &lt;code&gt;csv&lt;/code&gt; 포맷으로 저장시키는 코드이다.&lt;br /&gt;
두개의 다른 인코딩 형의 똑같은 내용의 데이터가 2개 준비된 것이다.&lt;br /&gt;
이 데이터의 인코딩형의 정보를 모른다고 가정하고 R로 읽어 들일 때 어떠한 문제들이 있는지 보겠다.&lt;/p&gt;
&lt;p&gt;csv 포맷의 데이터를 읽어들이는 방법은 여러가지가 있다.&lt;br /&gt;
가장 기본적인 &lt;code&gt;read.csv()&lt;/code&gt;함수의 경우이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;read.csv&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;data/Testdata_UTF-8.csv&amp;quot;&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# on Mac&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##   X     이름 점수
## 1 1   홍길동   80
## 2 2     철수   91
## 3 3     영희   99
## 4 4    Steve   85&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;quot;UTF-8&amp;quot; 형인 데이터를 먼저 불러와 보았는데 필자는 Mac 으로 동작시켰기 때문에 정상적으로 읽어들여진다.&lt;br /&gt;
하지만 Windows 환경에서는 저렇게 읽어들여지지 않을 것이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;read.csv&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;data/Testdata_UTF-8.csv&amp;quot;&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# on Windows&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Error in make.names(col.names, unique = TRUE) : invalid multibyte string at &amp;#39;&amp;lt;ec&amp;gt;&amp;lt;9d&amp;gt;&amp;lt;b4&amp;gt;由&amp;lt;84&amp;gt;&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Windows 환경에선 이와 같은 에러가 나면서 정말 간단한 예제의 데이터 테이블임에도 불구하고 읽어들이지 못한다.&lt;br /&gt;
이는 &lt;code&gt;read.csv()&lt;/code&gt; 함수가 동작할 때 내부적으로 &lt;code&gt;fileEncoding&lt;/code&gt; 인자값이 &lt;code&gt;Sys.getlocale(&amp;quot;LC_CTYPE&amp;quot;)&lt;/code&gt; 로 반환되는 환경변수값에 의존되어 실행된다.&lt;br /&gt;
Windows 환경에선 결과적으로 &lt;code&gt;read.csv()&lt;/code&gt; 함수가 &amp;quot;CP949&amp;quot; 라는 인코딩형으로 읽어들이게 되고,&lt;br /&gt;
이 인코딩 형이 원본파일의 인코딩 형(&amp;quot;UTF-8&amp;quot;)과 불일치 하기 때문에,&lt;br /&gt;
한글인 변수명이 유효하지 않은 문자열로 일그러져 인식할 수 없기 때문이다.&lt;/p&gt;
&lt;p&gt;이러한 원리 때문에 반대로 &amp;quot;EUC-KR&amp;quot; 형 데이터를 Mac 환경에서 읽어 들일 경우 마찬가지이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;read.csv&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;data/Testdata_EUC-KR.csv&amp;quot;&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# on Mac&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Error in make.names(col.names, unique = TRUE) : invalid multibyte string at &amp;#39;&amp;lt;c0≯&amp;lt;a7&amp;gt;&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;우선 에러없이 데이터를 R로 읽어들이는 해결방법은 이렇다.&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;일어들일 데이터의 텍스트 인코딩형을 알아낸다.&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;read.csv()&lt;/code&gt; 함수의 &lt;code&gt;fileEncoding&lt;/code&gt; 인자값을 알아낸 인코딩형으로 직접 입력한다.&lt;/li&gt;
&lt;li&gt;예를 들면 &lt;code&gt;read.csv(&amp;quot;data/Testdata_UTF-8.csv&amp;quot;, fileEncoding = &amp;quot;UTF-8&amp;quot;)&lt;/code&gt; 이런 코드가 되겠다. 이 코드를 실행하여 정상적으로 일어졌는지 확인한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;3단계 스텝을 통해 데이터를 읽어들이는데 성공한다.&lt;br /&gt;
굳이 세번째 스텝을 설명한 이유는 에러없이 데이터를 일어들였다 하더라도,&lt;br /&gt;
첫번째 스텝에 인코딩형을 제대로 알지 못하여 막장으로 일어들여질 가능성이 있기 때문에&lt;br /&gt;
확인하는 과정이 필요하므로 생겨난 부수적인 스텝이라 할 수 있겠다.&lt;/p&gt;
&lt;p&gt;여하튼 (분석을 하기도 전에) 데이터를 일어들이기 위한 이 3단계는 많은 에너지를 소모하게 만든다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;readrguess_encoding-함수&quot;&gt;&lt;code&gt;readr::guess_encoding()&lt;/code&gt; 함수&lt;/h2&gt;
&lt;p&gt;이제 본 글의 주제인 readr package 의 &lt;code&gt;guess_encoding()&lt;/code&gt; 함수를 소개한다.&lt;br /&gt;
함수명칭에서 볼 수 있듯이 이 함수의 쓰임은 인코딩형을 추론하는 함수인데&lt;br /&gt;
이를 잘 이용하면 위에서 설명한 번잡한 3단계 스텝을 1스텝으로 점프할 수 있다.&lt;/p&gt;
&lt;p&gt;우선 &lt;code&gt;guess_encoding()&lt;/code&gt; 함수를 살펴보자.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(readr) &lt;span class=&quot;co&quot;&gt;# for guess_encoding()&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;guess_encoding&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;data/Testdata_EUC-KR.csv&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 3 x 2
##     encoding confidence
##        &amp;lt;chr&amp;gt;      &amp;lt;dbl&amp;gt;
## 1     EUC-KR       1.00
## 2    GB18030       0.71
## 3 ISO-8859-1       0.21&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;guess_encoding&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;data/Testdata_UTF-8.csv&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1 x 2
##   encoding confidence
##      &amp;lt;chr&amp;gt;      &amp;lt;dbl&amp;gt;
## 1    UTF-8          1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;guess_encoding()&lt;/code&gt; 함수사용법은 간단하다.&lt;br /&gt;
외부 텍스트 파일에 대한 경로를 입력하고 실행하면 된다.&lt;br /&gt;
그러면 외부 텍스트파일의 인코딩형이 무엇일지 자동적으로 추론하고 가능성(confidence) 이 높은 순으로 출력된다.&lt;br /&gt;
&amp;quot;EUC-KR&amp;quot; 형 csv 파일을 일어들여 인코딩을 추론한 결과를 보면 &amp;quot;EUC-KR&amp;quot; 형일 가능성이 가장 높고, 그다음 &amp;quot;GB18030&amp;quot;, &amp;quot;ISO-8859-1&amp;quot; 형을 추론하는것을 볼 수 있다.&lt;br /&gt;
위에서 설명한 3단계 스텝에서 첫번째 스텝을 자동적으로 더 정확하게 추론함으로써 수고를 덜어준다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;read.csv&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;data/Testdata_EUC-KR.csv&amp;quot;&lt;/span&gt;, 
         &lt;span class=&quot;dt&quot;&gt;fileEncoding =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;guess_encoding&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;data/Testdata_EUC-KR.csv&amp;quot;&lt;/span&gt;)[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;] %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;as.character)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##   X     이름 점수
## 1 1   홍길동   80
## 2 2     철수   91
## 3 3     영희   99
## 4 4    Steve   85&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;아예 이런 식으로 내재화시켜버리면 3단계 스텝을 거치지 않고 어떠한 운영체계, 환경이든 융통성 있게 데이터를 잘 읽어 들일 것이다.&lt;br /&gt;
실제로 위 코드는 필자의 Mac 에서 동작했는데도 불구하고 인코딩이슈 없이 한글을 잘 읽어 들인 것을 볼 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;맺음말&quot;&gt;맺음말&lt;/h2&gt;
&lt;p&gt;본 글은 &lt;code&gt;read.csv()&lt;/code&gt; 함수에서 예시로 들었지만 외부 텍스트형 데이터를 읽어들이는 방법은 이 함수 말고도 다양하다.&lt;br /&gt;
필자는 csv 포맷 파일을 읽어들일 때 &lt;code&gt;data.table::fread()&lt;/code&gt;, &lt;code&gt;readr::read_csv()&lt;/code&gt; 등의 함수를 즐겨쓰는 편인데, 이 때도 마찬가지로 &lt;code&gt;guess_encoding()&lt;/code&gt; 함수를 이용해 인코딩 형을 신경쓰지 않고 최대한 분석에 집중하고 있다.&lt;/p&gt;
</description>
        <pubDate>Sat, 07 Oct 2017 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2017/10/07/guessEncoding.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2017/10/07/guessEncoding.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>R에서 기본 내장 graphics package를 이용한 데이터 시각화</title>
        <description>&lt;p&gt;본 글은 R에서 기본 내장 graphics package에 대표격인 &lt;code&gt;plot()&lt;/code&gt; 함수의 기초를 설명해보고자 한다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;plot-함수&quot;&gt;&lt;code&gt;plot()&lt;/code&gt; 함수&lt;/h2&gt;
&lt;p&gt;x 와 y 의 2개 축을 기준으로 좌표를 찍는 컨셉을 가진 함수이다.&lt;br /&gt;
가장 대표적으로 산점도를 표현할 때 간단하게 구현이 가능한 함수로 소개되나,&lt;br /&gt;
범용적으로 사용이 가능한 제너릭 함수 (generic function) 이기 때문에&lt;br /&gt;
입력되는 데이터의 타입과 클래스에 따라 성격에 맞게 다양한 모습으로 데이터 시각화 결과물이 출력된다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;좌표-찍기&quot;&gt;좌표 찍기&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/plotFunction_1-1.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;plot()&lt;/code&gt; 함수는 &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; 인자 2개를 기본적으로 받는다.&lt;br /&gt;
위의 코드를 실행하면 (2, 1)이라는 좌표 한곳에 점을 찍는 모습을 볼 수 있다.&lt;br /&gt;
이러한 특성을 잘 이용하면 복수개의 좌표에 점을 찍을 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;), &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/plotFunction_2-1.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;2개의 점이 찍히는데 각각 (1,1), (2,5) 좌표에 찍히는 것을 볼 수 있다.&lt;/p&gt;
&lt;p&gt;이런 좌표 찍기 특성을 이용하여 자신이 가지고 있는 데이터셋을 &lt;code&gt;plot()&lt;/code&gt; 함수의 &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; 인자에게 넘김으로써 산점도를 표현할 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;names&lt;/span&gt;(cars)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;speed&amp;quot; &amp;quot;dist&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(cars$speed, cars$dist)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/plotFunction_3-1.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;built-in 객체 &lt;code&gt;cars&lt;/code&gt;에서 차의 속도 정보를 담은 벡터 &lt;code&gt;cars$speed&lt;/code&gt; 가 x축으로,&lt;br /&gt;
주행거리 정보를 담은 벡터 &lt;code&gt;cars$dist&lt;/code&gt; 가 y축으로 입력됨으로써&lt;br /&gt;
차량의 속도와 거리 간의 관계를 대략적으로 살펴볼 수 있는 산점도를 보여주는 예제이다.&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;참고로 위의 코드 &lt;code&gt;plot(cars$speed, cars$dist)&lt;/code&gt; 는 아래의 코드를 실행하는 것과 같다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(dist ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;speed, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; cars)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;type-인자&quot;&gt;&lt;code&gt;type&lt;/code&gt; 인자&lt;/h3&gt;
&lt;p&gt;위의 좌표 찍기 두번째 예시인&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;), &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/plotFunction_4-1.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;에서 두 좌표 간 직선을 그리고 싶다면 &lt;code&gt;type&lt;/code&gt; 인자를 조정해보면 된다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;), &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;), &lt;span class=&quot;dt&quot;&gt;type =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;l&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/plotFunction_5-1.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;quot;line&amp;quot;을 의미할 것 같은 &amp;quot;l&amp;quot; 문자를 &lt;code&gt;type&lt;/code&gt; 인자로 넘겨주면 두 좌표가 연결된 선을 그린다.&lt;br /&gt;
&lt;code&gt;type&lt;/code&gt; 는 그림을 어떻게 그릴 것인지 묻는 인자로써, 이 인자값을 입력하지 않으면 기본적으로 &amp;quot;point&amp;quot;의 의미인 &amp;quot;p&amp;quot; 가 대부분 설정된다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;type&lt;/code&gt; 인자가 받을 수 있는 값들은 아래와 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;type = &amp;quot;p&amp;quot;&lt;/code&gt; : 점으로&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type = &amp;quot;l&amp;quot;&lt;/code&gt; : 선으로&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type = &amp;quot;b&amp;quot;&lt;/code&gt; : 점과 선 둘 다 동시에&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type = &amp;quot;o&amp;quot;&lt;/code&gt; : 점과 선 둘 다 동시에 (단 겹쳐짐 : over plotted)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type = &amp;quot;h&amp;quot;&lt;/code&gt; : 히스토그램과 비슷한 형태로 (histogram)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type = &amp;quot;s&amp;quot;&lt;/code&gt; : 계단모양으로 (stair steps)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type = &amp;quot;S&amp;quot;&lt;/code&gt; : 계단모양으로 (upper stair steps)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type = &amp;quot;n&amp;quot;&lt;/code&gt; : 좌표찍지 않음&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;type = n&lt;/code&gt;인 경우는 특이하게 plot의 토대인 축은 표현되나, 좌표가 찍히지 않음으로써&lt;br /&gt;
마치 그림을 그리기 이전 스케치북을 펼치는 것과 같다고 볼 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;), &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;), &lt;span class=&quot;dt&quot;&gt;type =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;n&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/plotFunction_6-1.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;이외의-다양한-인자들&quot;&gt;이외의 다양한 인자들&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;plot()&lt;/code&gt; 함수는 그래픽스 파라미터 &lt;code&gt;par&lt;/code&gt;를 상속받게 되어 다양한 인자들을 사용할 수 있는데, 이 특성을 잘 살리면 더 세부적인 조정이 가능하다.&lt;/p&gt;
&lt;p&gt;그래픽스 파라미터 (Graphical Parameters)의 자세한 내용과 사용 가능 인자가 무엇이 있는지 알고 싶다면&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;?par&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;를 실행시켜 도움말을 볼 수 있다.&lt;br /&gt;
&lt;code&gt;cex&lt;/code&gt;, &lt;code&gt;fg&lt;/code&gt;, &lt;code&gt;lty&lt;/code&gt;, &lt;code&gt;pch&lt;/code&gt; 등의 인자만 살펴보자&lt;/p&gt;
&lt;p&gt;만약 plotting 결과물에서 좌표 포인트의 크기를 조정하고 싶다면 &lt;code&gt;cex&lt;/code&gt; 인자값을 조정한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(dist ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;speed, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; cars, &lt;span class=&quot;dt&quot;&gt;cex =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# 디폴트로 cex=1 임, 즉 2배 크게&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/plotFunction_7-1.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(dist ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;speed, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; cars, &lt;span class=&quot;dt&quot;&gt;cex =&lt;/span&gt; .&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# 2배 작게&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/plotFunction_7-2.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;축의 색깔을 바꾸고 싶다면 전경색을 조절할 수 있는 &lt;code&gt;fg&lt;/code&gt; 인자값을 조정한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(dist ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;speed, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; cars, &lt;span class=&quot;dt&quot;&gt;fg =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;blue&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/plotFunction_8-1.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;만약 line type의 그림을 그렸다면 선의 성격을 &lt;code&gt;lty&lt;/code&gt; 인자를 통해 바꿀 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;), &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;), &lt;span class=&quot;dt&quot;&gt;type =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;l&amp;quot;&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# lty 를 언급하지 않았을 때&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/plotFunction_9-1.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;), &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;), &lt;span class=&quot;dt&quot;&gt;type =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;l&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;lty=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&amp;quot;dashed&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/plotFunction_9-2.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;만약 point type의 그림을 그렸다면 점의 모양을 &lt;code&gt;pch&lt;/code&gt; 인자를 통해 바꿀 수도 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(dist ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;speed, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; cars) &lt;span class=&quot;co&quot;&gt;# pch 를 언급하지 않았을 때&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/plotFunction_10-1.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(dist ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;speed, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; cars, &lt;span class=&quot;dt&quot;&gt;pch =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/plotFunction_10-2.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(dist ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;speed, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; cars, &lt;span class=&quot;dt&quot;&gt;pch =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;25&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# 1 ~ 25개의 모양이 준비되어 있음&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/plotFunction_10-3.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;좌표-찍기의-특성을-어기는-아니-똑똑한-제너릭-함수&quot;&gt;좌표 찍기의 특성을 어기는, 아니 똑똑한 제너릭 함수&lt;/h3&gt;
&lt;p&gt;지금까지 보았듯이 &lt;code&gt;plot()&lt;/code&gt;은 좌표 찍기의 컨셉을 이용하여 데이터시각화 결과물을 출력한다.&lt;br /&gt;
하지만 좌표 찍기에 적합하지 않은 클래스의 데이터가 입력되면 그에 알맞게 좌표 찍기의 컨셉을 버리고 다른 형태로 출력한다.&lt;/p&gt;
&lt;p&gt;아래 코드를 보면&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;fit &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;lm&lt;/span&gt;(dist ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;speed, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; cars)
&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(fit)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/plotFunction_11-1.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;img src=&quot;/assets/plotFunction_11-2.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;img src=&quot;/assets/plotFunction_11-3.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;img src=&quot;/assets/plotFunction_11-4.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;위의 코드는 &lt;code&gt;cars&lt;/code&gt; 를 대상으로 단순회귀적합을 한 lm class의 &lt;code&gt;fit&lt;/code&gt; 객체를 &lt;code&gt;plot()&lt;/code&gt; 함수에 입력한 결과인데 뭔가 많다.&lt;br /&gt;
분명 산점도이긴 산점도인데 더 복잡하고 어떠한 선분과 겹쳐져 그려진 4개의 패널로 구분된 시각화 결과물이 출력된다.&lt;br /&gt;
이는 회귀 적합 이후 모형진단 시 자주 사용하는 데이터 시각화 결과물을 &lt;code&gt;plot()&lt;/code&gt; 함수가 자동으로 알아서 모두 출력해준 것이다.&lt;br /&gt;
산점도 뿐만 아니라 완전히 성격이 바뀐 결과물을 출력하기도 한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(data.tree)
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt;(acme, &lt;span class=&quot;dt&quot;&gt;package =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;data.tree&amp;quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(acme)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/plotFunction_12.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;data.tree 라는 패키지가 있는데,&lt;br /&gt;
이 패키지에 포함되어 있는 &lt;code&gt;acme&lt;/code&gt; 데이터셋은 class 가 &lt;code&gt;data.tree&lt;/code&gt; 로써 특이한 구조를 가지고 있는 데이터셋 이다.&lt;br /&gt;
이를 &lt;code&gt;plot()&lt;/code&gt; 함수에 입력하여 plotting 하면 우리가 기존에 알고 있던 방식의 결과물이 나오지 않고 색다른 결과물이 나온다.&lt;br /&gt;
이러한 이유는 &lt;code&gt;plot()&lt;/code&gt; 이란 함수는 입력되는 데이터의 class에 알맞게 최적으로 표현해줄 수 있는 방법의 코드로 실행되기 때문이다.&lt;br /&gt;
그리고 이러한 특징을 가진 함수는 R에서 generic function이라고 부른다.&lt;br /&gt;
generic function은 사용자가 함수에 대한 문법을 정확하게 지키지 않더라도 최대한 사용자가 기대할 것 같은 결과물을 내보내기 위함이다.&lt;br /&gt;
이러한 R 시스템은 사용자 편의를 올릴 수 있게 해준다.&lt;/p&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;R을 공부하다 보면 눈에 자주 띄는 대표적인 그림이기도 하다&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Fri, 16 Jun 2017 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/data_visualization/2017/06/16/plotFunction.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/data_visualization/2017/06/16/plotFunction.html</guid>
        
        
        <category>R</category>
        
        <category>Data_Visualization</category>
        
      </item>
    
      <item>
        <title>Hello Scala! (스칼라 시작하기)</title>
        <description>&lt;p&gt;대용량 분산처리 분석시스템인 스파크(Spark)를 알기 위해 항상 마주쳤던, 그리고 발목을 잡는것이 스칼라(Scala)이었다.&lt;br /&gt;
스파크를 제대로 이용하기 위해선 스크립팅 기술이 필요한데 가장 대중적인 것이 스칼라이고 그다음이 파이썬(Python) 인 듯 보인다.&lt;br /&gt;
파이썬으로 해도 되지만 스파크의 철학을 제대로 물려받아 활용하기 위해선 스칼라를 이용할 것을 많은 곳에서 권장했다.&lt;br /&gt;
스파크에 관련된 구글링 검색만을 해보아도 예제의 코드는 스칼라코드가 더 많이 검색되었고, 이러한 이유가 분명 있을 것이기에 스칼라 공부를 시작했다.&lt;/p&gt;
&lt;p&gt;첫 공부의 시작에 앞서 책한권은 있어야 마음가짐이 잘 잡힐 것인데&lt;br /&gt;
필자는 아래의 책이 스칼라를 공부하기 위한 첫 책이다.&lt;/p&gt;
&lt;br&gt;&lt;br&gt;&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;image/HelloScala1.jpg&quot;&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&amp;amp;mallGb=KOR&amp;amp;barcode=9791185890791&amp;amp;orderClick=LAH&amp;amp;Kc=#N&quot;&gt;러닝 스칼라 - 제이슨 스와츠 지음 | 김정인, 강성용 옮김 | 제이펍 | 2017년 04월 17일 출간&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;본 글에선 &lt;strong&gt;스칼라 설치와 &amp;quot;Hello world&amp;quot; 의 출력정도의 기본적인 것을 정리&lt;/strong&gt;하는 걸 목표로 한다.&lt;br /&gt;
(단 앞으로의 내용은 Unix 계열 머신을 기준으로 설명함을 알립니다.)&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;스칼라-설치&quot;&gt;스칼라 설치&lt;/h2&gt;
&lt;p&gt;스칼라는 수동으로 설치하는 방법과 자동으로 설치하는 방법으로 나뉜다.&lt;/p&gt;
&lt;h3 id=&quot;수동설치&quot;&gt;수동설치&lt;/h3&gt;
&lt;p&gt;스칼라를 배포하는 &lt;a href=&quot;http://www.scala-lang.org/&quot;&gt;scala-lang.org&lt;/a&gt; 를 들어가면 다운로드 페이지가 있다.&lt;br /&gt;
&lt;code&gt;scala-2.XX.X.tgz&lt;/code&gt; 를 다운로드 한 이후 &lt;code&gt;bin&lt;/code&gt; 폴더를 경로에 추가하면 되겠다.&lt;/p&gt;
&lt;h3 id=&quot;자동설치&quot;&gt;자동설치&lt;/h3&gt;
&lt;p&gt;수동설치가 번거로우면 패키지 매니저를 이용해 설치하면 된다.&lt;br /&gt;
OSX 에선 Homebrew 를 통해 &lt;a href=&quot;https://opentutorials.org/course/128/11129&quot;&gt;Homebrew 설치법은 생활코딩 참고&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;sh&quot;&gt;&lt;code&gt;brew install scala&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;리눅스에선 apt-get&lt;/p&gt;
&lt;pre class=&quot;sh&quot;&gt;&lt;code&gt;apt-get install scala&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;혹은 yum 을 통해&lt;/p&gt;
&lt;pre class=&quot;sh&quot;&gt;&lt;code&gt;yum install scala&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;스칼라 설치가 가능하다.&lt;/p&gt;
수동설치 혹은 자동설치가 성공했다면 명령줄에서 &lt;code&gt;scala&lt;/code&gt; 명령어를 통해 실행 가능하다.
&lt;center&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;https://asciinema.org/a/123507.js&quot; id=&quot;asciicast-123507&quot; async&gt;&lt;/script&gt;
&lt;/center&gt;
&lt;p&gt;위의 예제는 스칼라에서 &lt;code&gt;println()&lt;/code&gt; 함수로 &amp;quot;Hello world&amp;quot; 를 출력하는 예제이다.&lt;br /&gt;
터미널 상에서 스칼라를 쓰기에는 많은 불편함이 있을 것이다.&lt;br /&gt;
적당한 텍스트 에디터에 REPL(Read Evaluate Print Loop) 을 연동시켜 사용하거나, 적절한 IDE(ntegrated Development Environment) 를 이용하는 것이 여러모로 이점이 많겠다.&lt;br /&gt;
이부분은 개인취향이므로 무언가를 추천하지는 않겠지만 필자는 &lt;a href=&quot;https://www.sublimetext.com/&quot;&gt;Sublime text 3&lt;/a&gt; 의 &lt;a href=&quot;https://packagecontrol.io/packages/SublimeREPL&quot;&gt;SublimeREPL 패키지&lt;/a&gt;를 사용해서 스칼라 스크립트를 작성하고 이 글을 작성함을 밝힌다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;값-할당&quot;&gt;값 할당&lt;/h2&gt;
&lt;p&gt;스칼라의 값 할당 방법은 다음과 같은 구문으로 약속되어 있다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;val &amp;lt;식별자&amp;gt;[: &amp;lt;타입&amp;gt;] = &amp;lt;데이터&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;값(value) 의 앞글자 &amp;quot;val&amp;quot; 로 시작하고 식별자 다음에 데이터 타입을 명시하기 위해 &lt;code&gt;:&lt;/code&gt; 로 구분한다.&lt;br /&gt;
그다음 할당할 데이터를 &lt;code&gt;=&lt;/code&gt; 이후에 입력한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode scala&quot;&gt;&lt;code class=&quot;sourceCode scala&quot;&gt;&lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; x: Int = &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; y: Int = &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;
x * y&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;https://asciinema.org/a/123515.js&quot; id=&quot;asciicast-123515&quot; async&gt;&lt;/script&gt;
&lt;/center&gt;
&lt;p&gt;데이터 타입을 항상 명시해야 하는 것은 아니다.&lt;br /&gt;
데이터 타입을 입력하지 않을 경우 타입추론에 의해 자동으로 적당한 타입을 판단하여 실행한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode scala&quot;&gt;&lt;code class=&quot;sourceCode scala&quot;&gt;&lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; x = &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; y = &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;
x * y&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;https://asciinema.org/a/123516.js&quot; id=&quot;asciicast-123516&quot; async&gt;&lt;/script&gt;
&lt;/center&gt;
&lt;p&gt;데이터 타입을 정수(Int)형으로 명시하지 않았음에도 불구하고 &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; 를 정수형으로 정의한 것을 확인할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;res-변수&quot;&gt;&lt;code&gt;res&lt;/code&gt; 변수&lt;/h2&gt;
&lt;p&gt;스칼라에선 &amp;quot;res&amp;quot; 그 뒤에 순차적으로 매겨지는 번호와 결합된 변수를 만들어 결과값 정보를 담는다.&lt;br /&gt;
이 특징을 이용하여 이전에 계산되었던 값을 불러와 재사용할 수 있을 것이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode scala&quot;&gt;&lt;code class=&quot;sourceCode scala&quot;&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;
res0 * res1&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;https://asciinema.org/a/123517.js&quot; id=&quot;asciicast-123517&quot; async&gt;&lt;/script&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;boolean&quot;&gt;Boolean&lt;/h2&gt;
&lt;p&gt;스칼라의 Boolean 타입은 &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; 값을 이용한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode scala&quot;&gt;&lt;code class=&quot;sourceCode scala&quot;&gt;&lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt; &amp;gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt; &amp;lt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt; == &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt; == &lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;https://asciinema.org/a/123520.js&quot; id=&quot;asciicast-123520&quot; async&gt;&lt;/script&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;tuple&quot;&gt;Tuple&lt;/h2&gt;
&lt;p&gt;튜풀은 데이터를 담는 컨테이너 중에서 순서가 있고 복수개의 값들을 담는 컨테이너를 의미한다.&lt;br /&gt;
소괄호를 이용하면 데이터 타입을 명시하지 않고도 튜플을 만들 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode scala&quot;&gt;&lt;code class=&quot;sourceCode scala&quot;&gt;&lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; tuple = (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;4.0&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;Five&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;https://asciinema.org/a/123522.js&quot; id=&quot;asciicast-123522&quot; async&gt;&lt;/script&gt;
&lt;/center&gt;
&lt;p&gt;튜플에 들어가는 각 원소들은 그 원소들끼리의 데이터타입이 통일될 필요는 없다.&lt;br /&gt;
위의 예제처럼 Int, Double, String 3개의 각기다른 데이터타입이 튜플이라는 컨테이너에 담을 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;표현식-블록&quot;&gt;표현식 블록&lt;/h2&gt;
&lt;p&gt;실행시킬 복수줄의 코드단위를 중괄호로 묶어 하나의 표현식(expression)으로 관리하는것이 스칼라에선 가능하다.&lt;br /&gt;
그리고 복잡한 표현식을 실행시킨 결과를 반환값으로 사용할 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode scala&quot;&gt;&lt;code class=&quot;sourceCode scala&quot;&gt;&lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; result = {
  &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; x: Double = &lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;
  x * &lt;span class=&quot;fl&quot;&gt;0.5&lt;/span&gt;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;https://asciinema.org/a/123525.js&quot; id=&quot;asciicast-123525&quot; async&gt;&lt;/script&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;주석&quot;&gt;주석&lt;/h2&gt;
&lt;p&gt;스칼라에서 주석은 &lt;code&gt;//&lt;/code&gt; 을 이용한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode scala&quot;&gt;&lt;code class=&quot;sourceCode scala&quot;&gt;&lt;span class=&quot;co&quot;&gt;// println(&amp;quot;Comment&amp;quot;)&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;Not comment&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;https://asciinema.org/a/123526.js&quot; id=&quot;asciicast-123526&quot; async&gt;&lt;/script&gt;
&lt;/center&gt;
&lt;p&gt;주석이 처리된 코드는 실행되지 않는 것을 확인할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;매치표현식을-이용한-조건부-로직&quot;&gt;매치표현식을 이용한 조건부 로직&lt;/h2&gt;
&lt;p&gt;스칼라에선 if else 구문의 조건문보다 매치표현식을 이용한 조건문을 즐겨 사용한다고 한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode scala&quot;&gt;&lt;code class=&quot;sourceCode scala&quot;&gt;&lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; today = &lt;span class=&quot;st&quot;&gt;&amp;quot;Tue&amp;quot;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (today == &lt;span class=&quot;st&quot;&gt;&amp;quot;Mon&amp;quot;&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;Weekday&amp;quot;&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (today == &lt;span class=&quot;st&quot;&gt;&amp;quot;Tue&amp;quot;&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;Weekday&amp;quot;&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (today == &lt;span class=&quot;st&quot;&gt;&amp;quot;Wed&amp;quot;&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;Weekday&amp;quot;&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (today == &lt;span class=&quot;st&quot;&gt;&amp;quot;Thu&amp;quot;&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;Weekday&amp;quot;&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (today == &lt;span class=&quot;st&quot;&gt;&amp;quot;Fri&amp;quot;&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;Weekday&amp;quot;&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (today == &lt;span class=&quot;st&quot;&gt;&amp;quot;Sat&amp;quot;&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;Weekend&amp;quot;&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (today == &lt;span class=&quot;st&quot;&gt;&amp;quot;Sun&amp;quot;&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;Weekend&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;https://asciinema.org/a/125089.js&quot; id=&quot;asciicast-125089&quot; async&gt;&lt;/script&gt;
&lt;/center&gt;
&lt;p&gt;위의 if else 구문 코드는 &lt;code&gt;today&lt;/code&gt; 요일이 언제인지에 따라 &amp;quot;Weekday&amp;quot;, &amp;quot;Weekend&amp;quot; 로 주중인지 주말인지를 출력한다.&lt;/p&gt;
&lt;p&gt;매치표현식을 이용해본 코드는&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode scala&quot;&gt;&lt;code class=&quot;sourceCode scala&quot;&gt;&lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; today = &lt;span class=&quot;st&quot;&gt;&amp;quot;Tue&amp;quot;&lt;/span&gt;

today &lt;span class=&quot;kw&quot;&gt;match&lt;/span&gt; {
  &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;Mon&amp;quot;&lt;/span&gt; | &lt;span class=&quot;st&quot;&gt;&amp;quot;Tue&amp;quot;&lt;/span&gt; | &lt;span class=&quot;st&quot;&gt;&amp;quot;Wed&amp;quot;&lt;/span&gt; | &lt;span class=&quot;st&quot;&gt;&amp;quot;Thu&amp;quot;&lt;/span&gt; | &lt;span class=&quot;st&quot;&gt;&amp;quot;Fri&amp;quot;&lt;/span&gt; =&amp;gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;Weekday&amp;quot;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;Sat&amp;quot;&lt;/span&gt; | &lt;span class=&quot;st&quot;&gt;&amp;quot;Sun&amp;quot;&lt;/span&gt; =&amp;gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;Weekend&amp;quot;&lt;/span&gt;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;https://asciinema.org/a/125090.js&quot; id=&quot;asciicast-125090&quot; async&gt;&lt;/script&gt;
&lt;/center&gt;
&lt;p&gt;&lt;code&gt;match&lt;/code&gt;, &lt;code&gt;case&lt;/code&gt; 를 통해 간결해 진 코드를 볼 때 if else 구문이 상당히 조악하게 보여졌다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;for-loop&quot;&gt;for loop&lt;/h2&gt;
&lt;p&gt;반복문 for loop 역시 스칼라에서 지원되며 강력한 기능들을 더할 수 있었다.&lt;br /&gt;
기본적인 사용법은 아래 구문 형태를 이용한다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;for (&amp;lt;식별자&amp;gt; &amp;lt;- &amp;lt;반복범위&amp;gt;) &amp;lt;표현식&amp;gt;&lt;/code&gt; 혹은 &lt;code&gt;for {&amp;lt;식별자&amp;gt; &amp;lt;- &amp;lt;반복범위&amp;gt;} &amp;lt;표현식&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;아래는 for 문을 이용하여 &amp;quot;Day1)&amp;quot; 부터 &amp;quot;Day10)&amp;quot; 까지 10개의 날을 출력하는 예제코드이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode scala&quot;&gt;&lt;code class=&quot;sourceCode scala&quot;&gt;&lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; {x &amp;lt;- &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; to &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;} &lt;span class=&quot;fu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;Day&amp;quot;&lt;/span&gt; + x + &lt;span class=&quot;st&quot;&gt;&amp;quot;) &amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;https://asciinema.org/a/125091.js&quot; id=&quot;asciicast-125091&quot; async&gt;&lt;/script&gt;
&lt;/center&gt;
&lt;h3 id=&quot;nested-for-loop&quot;&gt;Nested for loop&lt;/h3&gt;
&lt;p&gt;for 반복문을 중첩시키는 예제의 경우 스칼라에선 세련된 방법이 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode scala&quot;&gt;&lt;code class=&quot;sourceCode scala&quot;&gt;&lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; {x &amp;lt;- &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; to &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;}{
  &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; {y &amp;lt;- &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; to &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;}{
    &lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(x * y)
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위의 예제는 for문 안에 for문이 중첩하여 여섯경우의 곱 결과를 보여준다.&lt;br /&gt;
그런데 이것을 아래와 같이 간단하게 코딩을 줄이는것이 가능하다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode scala&quot;&gt;&lt;code class=&quot;sourceCode scala&quot;&gt;&lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; {x &amp;lt;- &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; to &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;; y &amp;lt;- &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; to &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;} &lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(x * y)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;두 반복자를 &lt;code&gt;;&lt;/code&gt; 를 이용해 for 문에 한꺼번에 입력하거나&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode scala&quot;&gt;&lt;code class=&quot;sourceCode scala&quot;&gt;&lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; {x &amp;lt;- &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; to &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;
     y &amp;lt;- &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; to &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;} &lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(x * y)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;문단을 나누어도 되겠다.&lt;/p&gt;
&lt;center&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;https://asciinema.org/a/130236.js&quot; id=&quot;asciicast-130236&quot; async&gt;&lt;/script&gt;
&lt;/center&gt;
</description>
        <pubDate>Tue, 06 Jun 2017 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/scala/2017/06/06/HelloScala.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/scala/2017/06/06/HelloScala.html</guid>
        
        
        <category>Scala</category>
        
      </item>
    
  </channel>
</rss>
