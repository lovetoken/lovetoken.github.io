<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description></description>
    <link>https://lovetoken.github.io/</link>
    <atom:link href="https://lovetoken.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 14 Jan 2018 15:28:41 +0900</pubDate>
    <lastBuildDate>Sun, 14 Jan 2018 15:28:41 +0900</lastBuildDate>
    <generator>Jekyll v3.1.6</generator>
    
      <item>
        <title>변동계수의 개념과 R에서의 실습</title>
        <description>&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;변동계수(coefficient of variation, C.V)는 평균이 크게 다른 두개 이상의 집단이 있을때&lt;br /&gt;
각 집단의 상대적 동질성을 감안한 산포도의 척도이다.&lt;/p&gt;
&lt;p&gt;변동계수에 대한설명을 위하여 아래 예시를 준비했다.&lt;/p&gt;
&lt;p&gt;3개의 샘플에 대한 물 용량을 측정한 예시가 있다.&lt;br /&gt;
이 3개의 샘플을 두 사람이 측정해 보고했다고 치자.&lt;br /&gt;
그런데 측정 단위에 대한 언급이 따로 없어 한사람은 리터 단위로, 한사람은 밀리리터 단위로 조사를 했다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;l &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;54&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;50&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;52&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# 물 리터단위(L)측정&lt;/span&gt;
ml &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;54017&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;49980&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;52003&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# 물 밀리리터단위(mL)측정&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;mean&lt;/span&gt;(l)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] 52&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;mean&lt;/span&gt;(ml)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] 52000&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;sd(l)
sd(ml)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;분명 같은 집단을 두 조사자는 조사했지만 측정단위의 차이로 인해 평균과 표준편차가 확연히 다르므로&lt;br /&gt;
이 내막을 모르는 사람에게는, 그리고 샘플의 개수가 인지하기 힘들정도로 많았을 때&lt;br /&gt;
두 집단이 다른것으로 대강 판단할 위험이 있다.&lt;/p&gt;
&lt;p&gt;리터단위로 측정시 표준편차는 2, 평균은 52로 계산되고&lt;br /&gt;
밀리리터단위로 측정시 표준편차와 평균은 리터단위로 계산한 표준편차보다 1000배 정도 높히 계산된다.&lt;/p&gt;
&lt;p&gt;여기서 단위의 차이로 생겨버린 이 1000배를 보정하는것이 변동계수의 기능이라고 볼 수 있는데&lt;br /&gt;
변동계수는 표준편차를 평균으로 나누는것으로 간단히 계산된다.&lt;br /&gt;
결과적으로 단위와 무관하게 계산되어 다른단위로 측정된 자료들의 산포를 비교할때 표준편차보다 유용한 지표가 된다.&lt;br /&gt;
이러한 점에서 변동계수를 상대표준편차(relative standard deviation, RSD)라고도 부른다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;sd&lt;/span&gt;(l) /&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;mean&lt;/span&gt;(l) &lt;span class=&quot;co&quot;&gt;# 리터단위 측정 샘플에 대한 변동계수&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.03846154&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;sd&lt;/span&gt;(ml) /&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;mean&lt;/span&gt;(ml) &lt;span class=&quot;co&quot;&gt;# 밀리리터단위 측정 샘플에 대한 변동계수&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.03881734&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;직접 계산해 보면 거의 비슷한 값으로 계산된다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;other-example&quot;&gt;other example&lt;/h2&gt;
&lt;p&gt;어떠한 백분율 값을 측정한 것으로 보이는 두 그룹이 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;group1 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;86&lt;/span&gt;,   &lt;span class=&quot;dv&quot;&gt;85&lt;/span&gt;,   &lt;span class=&quot;dv&quot;&gt;92&lt;/span&gt;,   &lt;span class=&quot;dv&quot;&gt;89&lt;/span&gt;,   &lt;span class=&quot;dv&quot;&gt;83&lt;/span&gt;,   &lt;span class=&quot;dv&quot;&gt;90&lt;/span&gt;,   &lt;span class=&quot;dv&quot;&gt;88&lt;/span&gt;,   &lt;span class=&quot;dv&quot;&gt;91&lt;/span&gt;,   &lt;span class=&quot;dv&quot;&gt;79&lt;/span&gt;,   &lt;span class=&quot;dv&quot;&gt;83&lt;/span&gt;)
group2 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;fl&quot;&gt;0.88&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;0.91&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;0.94&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;0.84&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;0.97&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;0.89&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;0.99&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;0.88&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;0.89&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;0.96&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;group1&lt;/code&gt; 은 100을 곱한 백분율의 상태 &lt;code&gt;group2&lt;/code&gt; 는 0~1 범위의 백분율 상태이다.&lt;br /&gt;
실제로 위와 같은 예는 조사자의 취향에 따라 단위가 통일되지 못하는 사례로 많다.&lt;/p&gt;
&lt;p&gt;당연히 이 둘의 데이터 산포도를 측정하고자&lt;br /&gt;
표준편차를 구하게 될 때 &lt;code&gt;group1&lt;/code&gt; 의 표준편차가 작을것이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;sd&lt;/span&gt;(group1)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] 4.141927&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;sd&lt;/span&gt;(group2)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.04790036&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;산포도의 공평한 비교가 될 수 없기에&lt;br /&gt;
&lt;code&gt;group2&lt;/code&gt; 자료에 100을 곱한 후 표준편차를 다시 구하거나&lt;br /&gt;
반대로 &lt;code&gt;group1&lt;/code&gt; 자료에 100을 나누어 표준편차를 구하게 될 것이다.&lt;br /&gt;
하지만 이는 급한마음에 거치는 긁어 부스럼 같은 절차이며&lt;br /&gt;
원 데이터를 보존하지 못하는 방법이므로 상황에 따라 위험성이 있을 것이다.&lt;br /&gt;
이때 변동계수를 이용하는것이 좋을것이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;sd&lt;/span&gt;(group1) /&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;mean&lt;/span&gt;(group1)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.04782825&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;sd&lt;/span&gt;(group2) /&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;mean&lt;/span&gt;(group2)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.05235012&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;변동계수를 구한결과 &lt;code&gt;group2&lt;/code&gt; 이 &lt;code&gt;group1&lt;/code&gt; 보다 변동계수가 더 컸다.&lt;br /&gt;
즉 상대적으로 &lt;code&gt;group2&lt;/code&gt; 의 퍼짐정도가 &lt;code&gt;group1&lt;/code&gt; 보다 크다는 결론을 낼 수 있다.&lt;/p&gt;
</description>
        <pubDate>Sun, 14 Jan 2018 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2018/01/14/CV.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2018/01/14/CV.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>라즈베리파이 초기상태의 pi 계정에서 root 비밀번호 변경</title>
        <description>&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;라즈베리파이를 처음 구동하면 pi 계정으로 로그인이 된다.&lt;br /&gt;
구입 후 초기상태의 상황에서&lt;br /&gt;
나는 분명분명 라즈베리파이의 주인인데도 불구하고&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ apt-get update&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;를 할때 Permission denied 이 발생하는 등 root 권한을 사용할 수 없는 상태어서 당황스러웠다 &lt;i class=&quot;fa fa-meh-o&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ su&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;로 root 로그인을 하려했으나&lt;br /&gt;
당연하게도 비밀번호를 알 수 없어 불가능하다.&lt;/p&gt;
&lt;p&gt;이때&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo passwd root&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;로 root 비밀번호를 처음으로 설정할 수 있고 이후 root 권한을 이용할 수 있다.&lt;/p&gt;
</description>
        <pubDate>Sat, 13 Jan 2018 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/etc/2018/01/13/raspberrypi_rootpasswd.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/etc/2018/01/13/raspberrypi_rootpasswd.html</guid>
        
        
        <category>etc</category>
        
      </item>
    
      <item>
        <title>R에서 all.equal() 함수를 이용한 객체의 동일성 확인하기</title>
        <description>&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;수학을 공부할 때 종종 이런일이 많았다.&lt;/p&gt;
&lt;p&gt;원 공식에 의해 계산이 불가하거나 손으로 풀기 복잡할 경우 근사치에 대한 간편공식을 배우게 되는 경우가 있다.&lt;br /&gt;
그 간편공식으로써 풀은 결과물이 원 공식으로 풀은 결과물과 동일한지 비교해보는 작업을 R을 이용하여 자주 하곤 했다.&lt;br /&gt;
만약 그 결과물이 어떤 하나의 스칼라값으로 나온다면,&lt;br /&gt;
금방 비교하여 동일한지 여부를 파악할 수 있다.&lt;br /&gt;
R을 이용한다면 논리연산자를 이용해 빠르고 정확하게 비교가 가능할 것이다.&lt;br /&gt;
&lt;code&gt;==&lt;/code&gt; 의 기호는 데이터셋의 원소별로 동일하면 TRUE, 틀리면 FALSE 를 반환하게 되므로 좌변과 우변이 같은지를 아래처럼 확인할 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;/&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; ==&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;804&lt;/span&gt;/&lt;span class=&quot;dv&quot;&gt;1206&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위의 예시처럼 쉽게 같은지 구분하기 힘든것을 논리연산자를 통해 동일한지 파악할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;all.equal-함수&quot;&gt;&lt;code&gt;all.equal()&lt;/code&gt; 함수&lt;/h2&gt;
&lt;p&gt;그런데 이러한 논리연산자 말고, R에서는 오늘 알아볼 &lt;code&gt;all.equal()&lt;/code&gt; 이란 함수가 있다.&lt;br /&gt;
이 함수의 쓰임은 비교하고자 하는 2개의 R객체가 동일한지를 확인해 준다.&lt;/p&gt;
&lt;p&gt;가끔, 아니 곧잘 대용량의 크기가 큰 데이터셋의 동일여부를 파악해야 할 때도 있을것이다.&lt;br /&gt;
아래와 같은 상황을 예로 들어 보겠다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;## 일반 행렬곱셈
A &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;matrix&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;round&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;rnorm&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;600&lt;/span&gt; *&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;400&lt;/span&gt;)), &lt;span class=&quot;dt&quot;&gt;nrow =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;600&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;ncol =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;400&lt;/span&gt;)
B &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;matrix&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;round&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;rnorm&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;400&lt;/span&gt; *&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;800&lt;/span&gt;)), &lt;span class=&quot;dt&quot;&gt;nrow =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;400&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;ncol =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;800&lt;/span&gt;)
AB &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;A %*%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;B

## 분할행렬 생성
A11 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;A[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;200&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;200&lt;/span&gt;]
A12 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;A[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;200&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;201&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;400&lt;/span&gt;]
A21 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;A[&lt;span class=&quot;dv&quot;&gt;201&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;600&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;200&lt;/span&gt;]
A22 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;A[&lt;span class=&quot;dv&quot;&gt;201&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;600&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;201&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;400&lt;/span&gt;]

B11 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;B[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;200&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;200&lt;/span&gt;]
B12 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;B[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;200&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;201&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;800&lt;/span&gt;]
B21 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;B[&lt;span class=&quot;dv&quot;&gt;201&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;400&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;200&lt;/span&gt;]
B22 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;B[&lt;span class=&quot;dv&quot;&gt;201&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;400&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;201&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;800&lt;/span&gt;]

partition_AB &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;rbind&lt;/span&gt;(
  &lt;span class=&quot;kw&quot;&gt;cbind&lt;/span&gt;(A11 %*%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;B11 +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;A12 %*%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;B21, A11 %*%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;B12 +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;A12 %*%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;B22),
  &lt;span class=&quot;kw&quot;&gt;cbind&lt;/span&gt;(A21 %*%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;B11 +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;A22 %*%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;B21, A21 %*%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;B12 +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;A22 %*%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;B22)
  ) &lt;span class=&quot;co&quot;&gt;# 분할행렬 생성 후 행렬곱셈&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위의 코드가 무엇인지 간략하게 설명하면&lt;br /&gt;
첫번째는 임의의 행렬 &lt;code&gt;A&lt;/code&gt;와 행렬 &lt;code&gt;B&lt;/code&gt;를 생성시킨 후, 두 행렬의 곱셈을 &lt;code&gt;AB&lt;/code&gt;로 할당한 것이며,&lt;br /&gt;
두번째는 행렬 &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt; 를 이와 같이 알맞게 분할한 후&lt;/p&gt;
&lt;center&gt;
&lt;br&gt;&lt;img src=&quot;/assets/allequal_1.png&quot;&gt;&lt;br&gt;
&lt;/center&gt;
&lt;p&gt;단 &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;A&lt;/em&gt;&lt;sub&gt;11&lt;/sub&gt;&lt;/span&gt;, &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;B&lt;/em&gt;&lt;sub&gt;11&lt;/sub&gt;&lt;/span&gt; 은 200×200 행렬&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;로 분할한 행렬을 이용하여 행렬 &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;를 곱한 것 이다.&lt;/p&gt;
&lt;center&gt;
&lt;br&gt;&lt;img src=&quot;/assets/allequal_2.png&quot;&gt;&lt;br&gt;
&lt;/center&gt;
&lt;p&gt;이처럼 곱한것을 객체 &lt;code&gt;partition_AB&lt;/code&gt;로 할당하였다.&lt;/p&gt;
&lt;p&gt;이론적으로는 첫번째 일반적인 곱셈과, 두번째 분할행렬을 이용한 곱셈과 값이 동일하다.&lt;br /&gt;
단 그것이 믿겨지지 않을 경우 직접 확인해 보고싶을 수 있다.&lt;br /&gt;
그런데 이때 애로사항이 있다.&lt;br /&gt;
&lt;code&gt;AB&lt;/code&gt; 와 &lt;code&gt;partition_AB&lt;/code&gt; 가 서로 동일하느냐 를 확인하기 위해선&lt;br /&gt;
두 행렬의 사이즈가 600×800 으로 매우 부담이 되는 크기이다.&lt;/p&gt;
&lt;p&gt;물론 논리연산자 == 를 써도 되겠지만, 문제는 이 논리연산자를 써서 아래 코드를 실행하게 될 경우&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;AB ==&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;partition_AB&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;행렬의 원소별 값이 동일한지에 대한 논리값을 600 × 800 = 480,000 개를 행렬 타입으로 거대하게 반환할 것이다. 거대하므로 눈으로 동일한지 확인이 어려울 것이다.&lt;br /&gt;
480,000개의 원소가 모두 &lt;code&gt;TRUE&lt;/code&gt; 인지를 확인하기 위해&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;all&lt;/span&gt;(AB ==&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;partition_AB)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;처럼 &lt;code&gt;all()&lt;/code&gt; 함수의 도움을 받을 수도 있겠지만&lt;br /&gt;
&lt;code&gt;all.equal()&lt;/code&gt; 함수를 사용하는것이 더 유용할 때가 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;all.equal&lt;/span&gt;(AB, partition_AB)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;함수이름 그대로 all equal 하면 &lt;code&gt;TRUE&lt;/code&gt;&lt;br /&gt;
그렇지 않을 경우 어디가 어떻게 틀린지 구체적으로 설명한다.&lt;br /&gt;
본 예제의 경우 원래의 행렬곱과 분할행렬의 곱이 같은경우의 예제이므로 &lt;code&gt;TRUE&lt;/code&gt; 를 반환한다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;all.equal()&lt;/code&gt; 함수는 객체가 동일한지의 판단하는 함수로써도 편리한 기능의 함수이지만,&lt;br /&gt;
기본적으로는 얼마나 가깝게 동일한지 정도를 확인할 수 있는 일종의 비교함수로 보고 사용하는것이 좋다.&lt;br /&gt;
함수 도움말의 제목에서도 &#39;Test if Two Objects are (Nearly) Equal&#39; 로 나와있고 괄호의 &amp;quot;Nearly&amp;quot; 가 눈에 띈다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;조금 더 체감하기 좋은 행렬의 연산예시를 들어보겠다.&lt;br /&gt;
R에서는 순환소수, 무한소수를 계산할 때, 즉 유리수가 아닌 무리수를 연산할 때 아주 미세한 값의 차이가 존재할 수 있다.&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;br /&gt;
하지만 이는 무리수를 굳이 소수점으로 표현하여 어떤 소수점자리 이후는 절단되어 버려지는 시스템 적인 문제일 뿐이다.&lt;/p&gt;
&lt;p&gt;아래 예시는 임의행렬 X와 그의 역행렬을 곱한것을 단위행렬과 비교해본 시뮬레이션이다.&lt;br /&gt;
행렬 X는 5×5 행렬이며 이론상으로는&lt;/p&gt;
&lt;center&gt;
&lt;br&gt;&lt;img src=&quot;/assets/allequal_3.png&quot;&gt;&lt;br&gt;
&lt;/center&gt;
&lt;p&gt;이 성립한다. 하지만&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;X &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;matrix&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;rnorm&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;25&lt;/span&gt;), &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;)
XtX &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;solve&lt;/span&gt;(X) %*%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;X

I_5 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;diag&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;)

XtX ==&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;I_5&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##       [,1]  [,2]  [,3]  [,4]  [,5]
## [1,] FALSE FALSE FALSE FALSE FALSE
## [2,] FALSE FALSE FALSE FALSE FALSE
## [3,] FALSE FALSE FALSE  TRUE FALSE
## [4,] FALSE FALSE FALSE  TRUE  TRUE
## [5,] FALSE FALSE FALSE FALSE FALSE&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;결과는 여기저기서 &lt;code&gt;FALSE&lt;/code&gt; 가 있고 실제로 값이 다르다. 전부 TRUE 이어야 하지만&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;table&lt;/span&gt;(XtX ==&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;I_5)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## 
## FALSE  TRUE 
##    22     3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이처럼 3개만 &lt;code&gt;TRUE&lt;/code&gt; 로 인식한다.&lt;br /&gt;
이처럼 무리수를 컴퓨터가 정확하게 표현할 수 없기 때문에 일어나는 일로 &lt;code&gt;XtX&lt;/code&gt; 나, &lt;code&gt;I_5&lt;/code&gt; 를 같지 않다고 판단하는것은 상황에 따라서 용인해야할 때가 있다.&lt;br /&gt;
이때 방금 언급한 &lt;code&gt;all.equal()&lt;/code&gt; 함수를 사용해 보면 어떨까?&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;all.equal&lt;/span&gt;(XtX, I_5)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;all.equal()&lt;/code&gt; 함수 내에는 &lt;code&gt;tolerance&lt;/code&gt; 인자가 존재하여 어느 정도의 차이는 단어 뜻대로 관용, 아량을 베풀어주는 로직이 있다.&lt;br /&gt;
따라서 &lt;code&gt;XtX&lt;/code&gt; 와, &lt;code&gt;I_5&lt;/code&gt; 는 그정도 차이는 무시하고 서로 동일하다고 판단하여 &lt;code&gt;TRUE&lt;/code&gt; 를 반환한다.&lt;br /&gt;
만약 관용, 아량을 전혀 베풀지 않는(&lt;code&gt;tolerance = 0&lt;/code&gt;)다면&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;all.equal&lt;/span&gt;(XtX, I_5, &lt;span class=&quot;dt&quot;&gt;tolerance =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;Mean relative difference: 2.806783e-15&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;두 객체간 차이의 아주 정확한 값을 반환한다.&lt;br /&gt;
분석을 하다보면 위의 예제 말고도 동등성을 확인하여야 할 때가 사뭇 많다.&lt;br /&gt;
이럴 때 &lt;code&gt;all.equal()&lt;/code&gt; 함수는 유용하게 사용될 수 있을것이다.&lt;/p&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;이는 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EB%B6%80%EB%8F%99%EC%86%8C%EC%88%98%EC%A0%90&quot;&gt;부동소수점&lt;/a&gt;으로 인한 문제이다&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Tue, 02 Jan 2018 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2018/01/02/allequal.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2018/01/02/allequal.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>인터넷 접속이 안되는 CentOS 머신에서 Python3 및 패키지 설치하기</title>
        <description>&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;본 글은 CentOS 최소설치버전으로 설치된 서버에서 (내부망 운용등의 이유로)인터넷 접속이 불가한 상황일 때 Python3 및 패키지를 설치하는 법에 대해 설명하기 위한 글이다.&lt;br /&gt;
패키지의 예시는 &lt;a href=&quot;http://konlpy-ko.readthedocs.io/ko/v0.4.3/&quot;&gt;konlpy&lt;/a&gt; 이다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;가상환경-준비&quot;&gt;가상환경 준비&lt;/h2&gt;
&lt;p&gt;설명을 위하여&lt;br /&gt;
설치의 대상이 되는 CentOS 최소설치 환경을 똑같이 재현할 필요가 있다.&lt;br /&gt;
CentOS 최소설치가 된 가상환경을 &lt;a href=&quot;https://www.docker.com/&quot;&gt;Docker&lt;/a&gt; 을 통해 준비해 보았다.&lt;br /&gt;
(Docker를 모른다면 본 장은 설명을 위한 CentOS 환경을 그대로 재현하기 위함이구나 하고 넘어가면 되겠다)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker run -it centos /bin/bash&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;CentOS 최소설치버전 이미지 다운로드한 후 컨테이너 실행하여 &lt;code&gt;/bin/bash&lt;/code&gt; 를 실행해 CentOS 쉘로 접속하게 된다.&lt;br /&gt;
접속된 환경은 인터넷이 가능한 상황이지만, 인터넷이 안되는 상황을 전제하에 Python3 및 konlpy 패키지를 수동으로 설치해 볼 것이다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;python3-설치파일-준비&quot;&gt;Python3 설치파일 준비&lt;/h2&gt;
&lt;p&gt;이제부턴 CentOS 쉘에서의 상황임을 염두해 둔다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ yum install -y https://centos7.iuscommunity.org/ius-release.rpm
$ yum search python36&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;IUS Community Project의 리포지토리를 yum의 리포지토리에 추가한 후 python36 검색해 본다.&lt;br /&gt;
&amp;quot;python36&amp;quot; 으로 시작되는 다양한 리스트들이 출력될 것이다.&lt;br /&gt;
참고로 yum 의 &lt;code&gt;-y&lt;/code&gt; 옵션 의미는 무조건 Yes로 입력하여 설치를 진행토록 하는 의미이다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mkdir ~/python3
$ cd ~/python3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;적당한 곳에 &lt;code&gt;python3&lt;/code&gt; 디렉토리를 만들고 그곳으로 간다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ yum install -y --downloadonly --downloaddir=. python36u python36u-libs python36u-devel python36u-pip&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Python3.6 버전대 패키지들을 설치하지 않고 다운로드만 하는 명령어이다. &lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;br /&gt;
위 명령어를 실행하면 관련된 패키지들의 rpm 을 워킹디렉토리(&lt;code&gt;~/python3&lt;/code&gt;)에 저장하게 된다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@e1e70169f547 python3]# ll
-rw-r--r-- 1 root root   56192 Aug  3 04:20 python36u-3.6.2-1.ius.centos7.x86_64.rpm
-rw-r--r-- 1 root root  204112 Aug  3 04:20 python36u-devel-3.6.2-1.ius.centos7.x86_64.rpm
-rw-r--r-- 1 root root 9689852 Aug  3 04:20 python36u-libs-3.6.2-1.ius.centos7.x86_64.rpm
-rw-r--r-- 1 root root 1841528 Feb  3  2017 python36u-pip-9.0.1-1.ius.centos7.noarch.rpm
-rw-r--r-- 1 root root  663324 Mar 22  2017 python36u-setuptools-33.1.1-1.ius.centos7.noarch.rpm&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;실제로 확인해 볼 경우 5개의 rpm 파일들이 준비된 것을 확인할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;konlpy-패키지-리소스-준비&quot;&gt;konlpy 패키지 리소스 준비&lt;/h2&gt;
&lt;p&gt;파이썬의 패키지를 준비하기 위해선 &lt;code&gt;pip&lt;/code&gt; 를 이용하는것이 좋다.&lt;br /&gt;
&lt;code&gt;pip&lt;/code&gt; 를 이용하기 위해서 방금 받은 rpm 을 이용해 파이썬을 설치한다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ yum install -y *&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;정상적으로 설치되면 이때부터 &lt;code&gt;python3.6&lt;/code&gt;, &lt;code&gt;pip3.6&lt;/code&gt; 명령어를 이용할 수 있게 된다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mkdir packages
$ cd packages&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;적당히 &lt;code&gt;~/python3/packages&lt;/code&gt; 디렉토리를 만들고 그곳으로 가자.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ pip3.6 install --download=. tag
$ pip3.6 install --download=. konlpy
$ pip3.6 install --download=. JPype1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위 명령어 중 첫번째는 tag package 에 대한 리소스 압축파일 (&lt;code&gt;.tag.gz&lt;/code&gt;) 을 포함한 의존성이 있는 리소스를 모두 현 워킹디렉토리에 저장만 한다.&lt;br /&gt;
즉 패키지들이 설치되지는 않는다.&lt;br /&gt;
konlpy 와 JPype1 패키지 역시 마찬가지로 리소스를 준비시킨다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@e1e70169f547 package]# ll
-rw-r--r-- 1 root root   147893 Oct 20 00:51 JPype1-0.6.2.tar.gz
-rw-r--r-- 1 root root    38404 Oct 20 00:52 intervaltree-2.1.0.tar.gz
-rw-r--r-- 1 root root 22454979 Oct 20 00:52 konlpy-0.4.4-py2.py3-none-any.whl
-rw-r--r-- 1 root root    32267 Oct 20 00:52 sortedcontainers-1.5.7-py2.py3-none-any.whl
-rw-r--r-- 1 root root    34414 Oct 20 00:52 tag-0.3.3.tar.gz&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;package 리소스 파일들이 준비되어 있는것을 확인할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;인터넷이-불가한-centos-에서의-python3.6-packages-설치&quot;&gt;인터넷이 불가한 CentOS 에서의 python3.6, packages 설치&lt;/h2&gt;
&lt;p&gt;인터넷이 불가했던 머신으로 시점을 옮긴다.&lt;br /&gt;
인터넷 접속이 안되었던 CentOS 서버에서 위에서 준비한 rpm, package 리소스들을 물리적으로 복사하여 가져온다.&lt;/p&gt;
&lt;p&gt;본 예제의 경우 Docker 가상환경을 기준으로 설명했는데&lt;br /&gt;
컨테이너 안에서 빠져나온 후 (&lt;code&gt;exit&lt;/code&gt; 로 빠져나올 수 있음)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker cp &amp;lt;컨테이너명&amp;gt;:~/python3/ &amp;lt;호스트 경로&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;의 방식으로 가상환경에 있던 rpm, package 리소스 들을&lt;br /&gt;
호스트로 떨어트린 후 USB 메모리등을 이용해 복사하여 인터넷이 불가한 CentOS 서버머신에 복사하면 되겠다.&lt;br /&gt;
참고로 컨테이너 명은 &lt;code&gt;docker ps -a&lt;/code&gt; 를 통해 확인이 가능하다.&lt;br /&gt;
아래 docker cp 명령어는 나의 컴퓨터에 꽂혀 있는 USB 메모리로 리소스들을 복사하는 예이다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker cp e1e70169f547:~/python3/ /Volumes/lovetoken_usb/&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(이외의 docker 를 이용하지 않은 상황에선 각자 상황에 따라 대처... 자세한 설명은 생략)&lt;/p&gt;
&lt;p&gt;자 이제부터는 인터넷이 불가한 CentOS 서버상황이라고 가정한다.&lt;br /&gt;
편의상 &lt;code&gt;~/python3&lt;/code&gt; 에 복사한 것을 붙어넣었다고 가정하겠다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd ~/python3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;복사한 python3 폴더로 간다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ yum install -y python36u-3.6.2-1.ius.centos7.x86_64.rpm python36u-devel-3.6.2-1.ius.centos7.x86_64.rpm python36u-libs-3.6.2-1.ius.centos7.x86_64.rpm python36u-pip-9.0.1-1.ius.centos7.noarch.rpm python36u-setuptools-33.1.1-1.ius.centos7.noarch.rpm&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 명령어를 통해서&lt;br /&gt;
yum 은 원격레파지토리를 검색하지 않고 &lt;code&gt;~/python3&lt;/code&gt; 에 있는 rpm 에 의존하여 파이썬을 설치하기 시작한다.&lt;br /&gt;
즉 수동으로 설치가 되는것이다.&lt;br /&gt;
역시 정상적으로 설치되면 &lt;code&gt;python3.6&lt;/code&gt;, &lt;code&gt;pip3.6&lt;/code&gt; 을 실행할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd packages&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;~/python3/packages&lt;/code&gt; 폴더로 가서 이젠 konlpy 패캐지 설치를 시도할 것이다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pip3.6 install *&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 명령어를 통해서 인터넷 연결없이 konlpy 관련 패키지들을 수동설치하게 된다.&lt;/p&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;덧붙임 : Ubuntu 에선 &lt;code&gt;apt-get -d install &amp;lt;package name&amp;gt;&lt;/code&gt; 으로 설치하지 않고 &lt;code&gt;.deb&lt;/code&gt; 파일들을 다운로드만 할 수 있다&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Sun, 22 Oct 2017 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/python/2017/10/22/python3_install_on_CentOS_manually.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/python/2017/10/22/python3_install_on_CentOS_manually.html</guid>
        
        
        <category>Python</category>
        
      </item>
    
      <item>
        <title>R에서 readr package 의 guess_encoding() 함수를 이용한 Text 파일의 인코딩 타입 추론</title>
        <description>&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;파일을 읽어 들일 때 인코딩 타입에 대한 이슈는 상당히 짜증 나는 유형의 이슈 중 하나라고 생각된다.&lt;br /&gt;
분석환경이 단독 운영체계만을 이용하여 분석한다면 큰 문제는 없겠지만&lt;br /&gt;
Linux 머신이나 Mac, Windows 등으로 넘나들게 되는 순간 데이터의 인코딩 타입을 고려해야 할 것이다.&lt;br /&gt;
통상적으로 이럴 때는 UTF-8 인코딩으로 통일하여 관리하지만&lt;br /&gt;
이것이 어려울 때 2개 이상의 인코딩 타입으로 데이터가 존재하게 될 것이다.&lt;/p&gt;
&lt;p&gt;그런데 인코딩 타입이 2개 이상 혼용되기 시작하면, 데이터를 읽어 들이고 내보내는 단계에서 인코딩타입까지 추가적으로 신경써야 한다는 점이 여러모로 피곤하게 느껴질 것이다.&lt;br /&gt;
데이터 I/O 단계에서 인코딩까지 신경써서 읽어들이는 것은 번거로운 일 일 수 있다.&lt;br /&gt;
애초에 이를 신경쓰는거 자체가 분석 본연에 있어 불필요한 요소일 수 있다.&lt;/p&gt;
&lt;p&gt;이번 글에서는 R에서 readr package 에 있는 &lt;code&gt;guess_encoding()&lt;/code&gt; 의 함수를 설명하고 소개할 것인데, R에서 데이터를 읽어 들이고 내보낼 시 인코딩 타입으로 인한 이슈들과 불편함을 겪는 사람들께 조금이나마 편의와 팁, 힌트를 주고자 작성한 글이다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;상황재현&quot;&gt;상황재현&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;d &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;read.csv&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;text =&lt;/span&gt; 
  &lt;span class=&quot;st&quot;&gt;&amp;quot;이름, 점수&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;  홍길동, 80&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;  철수, 91&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;  영희, 99&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;  Steve, 85&amp;quot;&lt;/span&gt;
)

&lt;span class=&quot;kw&quot;&gt;dir.create&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;data&amp;quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;write.csv&lt;/span&gt;(d, &lt;span class=&quot;st&quot;&gt;&amp;quot;data/Testdata_EUC-KR.csv&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;fileEncoding =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;EUC-KR&amp;quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;write.csv&lt;/span&gt;(d, &lt;span class=&quot;st&quot;&gt;&amp;quot;data/Testdata_UTF-8.csv&amp;quot;&lt;/span&gt;,  &lt;span class=&quot;dt&quot;&gt;fileEncoding =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;UTF-8&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위 코드는 &amp;quot;EUC-KR&amp;quot; 형과 &amp;quot;UTF-8&amp;quot; 형으로 작성된 간단한 데이터 테이블을 data 폴더안 &lt;code&gt;csv&lt;/code&gt; 포맷으로 저장시키는 코드이다.&lt;br /&gt;
두개의 다른 인코딩 형의 똑같은 내용의 데이터가 2개 준비된 것이다.&lt;br /&gt;
이 데이터의 인코딩형의 정보를 모른다고 가정하고 R로 읽어 들일 때 어떠한 문제들이 있는지 보겠다.&lt;/p&gt;
&lt;p&gt;csv 포맷의 데이터를 읽어들이는 방법은 여러가지가 있다.&lt;br /&gt;
가장 기본적인 &lt;code&gt;read.csv()&lt;/code&gt;함수의 경우이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;read.csv&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;data/Testdata_UTF-8.csv&amp;quot;&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# on Mac&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##   X     이름 점수
## 1 1   홍길동   80
## 2 2     철수   91
## 3 3     영희   99
## 4 4    Steve   85&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;quot;UTF-8&amp;quot; 형인 데이터를 먼저 불러와 보았는데 필자는 Mac 으로 동작시켰기 때문에 정상적으로 읽어들여진다.&lt;br /&gt;
하지만 Windows 환경에서는 저렇게 읽어들여지지 않을 것이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;read.csv&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;data/Testdata_UTF-8.csv&amp;quot;&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# on Windows&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Error in make.names(col.names, unique = TRUE) : invalid multibyte string at &amp;#39;&amp;lt;ec&amp;gt;&amp;lt;9d&amp;gt;&amp;lt;b4&amp;gt;由&amp;lt;84&amp;gt;&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Windows 환경에선 이와 같은 에러가 나면서 정말 간단한 예제의 데이터 테이블임에도 불구하고 읽어들이지 못한다.&lt;br /&gt;
이는 &lt;code&gt;read.csv()&lt;/code&gt; 함수가 동작할 때 내부적으로 &lt;code&gt;fileEncoding&lt;/code&gt; 인자값이 &lt;code&gt;Sys.getlocale(&amp;quot;LC_CTYPE&amp;quot;)&lt;/code&gt; 로 반환되는 환경변수값에 의존되어 실행된다.&lt;br /&gt;
Windows 환경에선 결과적으로 &lt;code&gt;read.csv()&lt;/code&gt; 함수가 &amp;quot;CP949&amp;quot; 라는 인코딩형으로 읽어들이게 되고,&lt;br /&gt;
이 인코딩 형이 원본파일의 인코딩 형(&amp;quot;UTF-8&amp;quot;)과 불일치 하기 때문에,&lt;br /&gt;
한글인 변수명이 유효하지 않은 문자열로 일그러져 인식할 수 없기 때문이다.&lt;/p&gt;
&lt;p&gt;이러한 원리 때문에 반대로 &amp;quot;EUC-KR&amp;quot; 형 데이터를 Mac 환경에서 읽어 들일 경우 마찬가지이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;read.csv&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;data/Testdata_EUC-KR.csv&amp;quot;&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# on Mac&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Error in make.names(col.names, unique = TRUE) : invalid multibyte string at &amp;#39;&amp;lt;c0≯&amp;lt;a7&amp;gt;&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;우선 에러없이 데이터를 R로 읽어들이는 해결방법은 이렇다.&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;일어들일 데이터의 텍스트 인코딩형을 알아낸다.&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;read.csv()&lt;/code&gt; 함수의 &lt;code&gt;fileEncoding&lt;/code&gt; 인자값을 알아낸 인코딩형으로 직접 입력한다.&lt;/li&gt;
&lt;li&gt;예를 들면 &lt;code&gt;read.csv(&amp;quot;data/Testdata_UTF-8.csv&amp;quot;, fileEncoding = &amp;quot;UTF-8&amp;quot;)&lt;/code&gt; 이런 코드가 되겠다. 이 코드를 실행하여 정상적으로 일어졌는지 확인한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;3단계 스텝을 통해 데이터를 읽어들이는데 성공한다.&lt;br /&gt;
굳이 세번째 스텝을 설명한 이유는 에러없이 데이터를 일어들였다 하더라도,&lt;br /&gt;
첫번째 스텝에 인코딩형을 제대로 알지 못하여 막장으로 일어들여질 가능성이 있기 때문에&lt;br /&gt;
확인하는 과정이 필요하므로 생겨난 부수적인 스텝이라 할 수 있겠다.&lt;/p&gt;
&lt;p&gt;여하튼 (분석을 하기도 전에) 데이터를 일어들이기 위한 이 3단계는 많은 에너지를 소모하게 만든다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;readrguess_encoding-함수&quot;&gt;&lt;code&gt;readr::guess_encoding()&lt;/code&gt; 함수&lt;/h2&gt;
&lt;p&gt;이제 본 글의 주제인 readr package 의 &lt;code&gt;guess_encoding()&lt;/code&gt; 함수를 소개한다.&lt;br /&gt;
함수명칭에서 볼 수 있듯이 이 함수의 쓰임은 인코딩형을 추론하는 함수인데&lt;br /&gt;
이를 잘 이용하면 위에서 설명한 번잡한 3단계 스텝을 1스텝으로 점프할 수 있다.&lt;/p&gt;
&lt;p&gt;우선 &lt;code&gt;guess_encoding()&lt;/code&gt; 함수를 살펴보자.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(readr) &lt;span class=&quot;co&quot;&gt;# for guess_encoding()&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;guess_encoding&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;data/Testdata_EUC-KR.csv&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 3 x 2
##     encoding confidence
##        &amp;lt;chr&amp;gt;      &amp;lt;dbl&amp;gt;
## 1     EUC-KR       1.00
## 2    GB18030       0.71
## 3 ISO-8859-1       0.21&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;guess_encoding&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;data/Testdata_UTF-8.csv&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1 x 2
##   encoding confidence
##      &amp;lt;chr&amp;gt;      &amp;lt;dbl&amp;gt;
## 1    UTF-8          1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;guess_encoding()&lt;/code&gt; 함수사용법은 간단하다.&lt;br /&gt;
외부 텍스트 파일에 대한 경로를 입력하고 실행하면 된다.&lt;br /&gt;
그러면 외부 텍스트파일의 인코딩형이 무엇일지 자동적으로 추론하고 가능성(confidence) 이 높은 순으로 출력된다.&lt;br /&gt;
&amp;quot;EUC-KR&amp;quot; 형 csv 파일을 일어들여 인코딩을 추론한 결과를 보면 &amp;quot;EUC-KR&amp;quot; 형일 가능성이 가장 높고, 그다음 &amp;quot;GB18030&amp;quot;, &amp;quot;ISO-8859-1&amp;quot; 형을 추론하는것을 볼 수 있다.&lt;br /&gt;
위에서 설명한 3단계 스텝에서 첫번째 스텝을 자동적으로 더 정확하게 추론함으로써 수고를 덜어준다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;read.csv&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;data/Testdata_EUC-KR.csv&amp;quot;&lt;/span&gt;, 
         &lt;span class=&quot;dt&quot;&gt;fileEncoding =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;guess_encoding&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;data/Testdata_EUC-KR.csv&amp;quot;&lt;/span&gt;)[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;] %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;as.character)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##   X     이름 점수
## 1 1   홍길동   80
## 2 2     철수   91
## 3 3     영희   99
## 4 4    Steve   85&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;아예 이런 식으로 내재화시켜버리면 3단계 스텝을 거치지 않고 어떠한 운영체계, 환경이든 융통성 있게 데이터를 잘 읽어 들일 것이다.&lt;br /&gt;
실제로 위 코드는 필자의 Mac 에서 동작했는데도 불구하고 인코딩이슈 없이 한글을 잘 읽어 들인 것을 볼 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;맺음말&quot;&gt;맺음말&lt;/h2&gt;
&lt;p&gt;본 글은 &lt;code&gt;read.csv()&lt;/code&gt; 함수에서 예시로 들었지만 외부 텍스트형 데이터를 읽어들이는 방법은 이 함수 말고도 다양하다.&lt;br /&gt;
필자는 csv 포맷 파일을 읽어들일 때 &lt;code&gt;data.table::fread()&lt;/code&gt;, &lt;code&gt;readr::read_csv()&lt;/code&gt; 등의 함수를 즐겨쓰는 편인데, 이 때도 마찬가지로 &lt;code&gt;guess_encoding()&lt;/code&gt; 함수를 이용해 인코딩 형을 신경쓰지 않고 최대한 분석에 집중하고 있다.&lt;/p&gt;
</description>
        <pubDate>Sat, 07 Oct 2017 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2017/10/07/guessEncoding.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2017/10/07/guessEncoding.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>R에서 기본 내장 graphics package를 이용한 데이터 시각화</title>
        <description>&lt;p&gt;본 글은 R에서 기본 내장 graphics package에 대표격인 &lt;code&gt;plot()&lt;/code&gt; 함수의 기초를 설명해보고자 한다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;plot-함수&quot;&gt;&lt;code&gt;plot()&lt;/code&gt; 함수&lt;/h2&gt;
&lt;p&gt;x 와 y 의 2개 축을 기준으로 좌표를 찍는 컨셉을 가진 함수이다.&lt;br /&gt;
가장 대표적으로 산점도를 표현할 때 간단하게 구현이 가능한 함수로 소개되나,&lt;br /&gt;
범용적으로 사용이 가능한 제너릭 함수 (generic function) 이기 때문에&lt;br /&gt;
입력되는 데이터의 타입과 클래스에 따라 성격에 맞게 다양한 모습으로 데이터 시각화 결과물이 출력된다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;좌표-찍기&quot;&gt;좌표 찍기&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/plotFunction_1-1.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;plot()&lt;/code&gt; 함수는 &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; 인자 2개를 기본적으로 받는다.&lt;br /&gt;
위의 코드를 실행하면 (2, 1)이라는 좌표 한곳에 점을 찍는 모습을 볼 수 있다.&lt;br /&gt;
이러한 특성을 잘 이용하면 복수개의 좌표에 점을 찍을 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;), &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/plotFunction_2-1.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;2개의 점이 찍히는데 각각 (1,1), (2,5) 좌표에 찍히는 것을 볼 수 있다.&lt;/p&gt;
&lt;p&gt;이런 좌표 찍기 특성을 이용하여 자신이 가지고 있는 데이터셋을 &lt;code&gt;plot()&lt;/code&gt; 함수의 &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; 인자에게 넘김으로써 산점도를 표현할 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;names&lt;/span&gt;(cars)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;speed&amp;quot; &amp;quot;dist&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(cars$speed, cars$dist)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/plotFunction_3-1.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;built-in 객체 &lt;code&gt;cars&lt;/code&gt;에서 차의 속도 정보를 담은 벡터 &lt;code&gt;cars$speed&lt;/code&gt; 가 x축으로,&lt;br /&gt;
주행거리 정보를 담은 벡터 &lt;code&gt;cars$dist&lt;/code&gt; 가 y축으로 입력됨으로써&lt;br /&gt;
차량의 속도와 거리 간의 관계를 대략적으로 살펴볼 수 있는 산점도를 보여주는 예제이다.&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;참고로 위의 코드 &lt;code&gt;plot(cars$speed, cars$dist)&lt;/code&gt; 는 아래의 코드를 실행하는 것과 같다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(dist ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;speed, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; cars)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;type-인자&quot;&gt;&lt;code&gt;type&lt;/code&gt; 인자&lt;/h3&gt;
&lt;p&gt;위의 좌표 찍기 두번째 예시인&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;), &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/plotFunction_4-1.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;에서 두 좌표 간 직선을 그리고 싶다면 &lt;code&gt;type&lt;/code&gt; 인자를 조정해보면 된다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;), &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;), &lt;span class=&quot;dt&quot;&gt;type =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;l&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/plotFunction_5-1.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;quot;line&amp;quot;을 의미할 것 같은 &amp;quot;l&amp;quot; 문자를 &lt;code&gt;type&lt;/code&gt; 인자로 넘겨주면 두 좌표가 연결된 선을 그린다.&lt;br /&gt;
&lt;code&gt;type&lt;/code&gt; 는 그림을 어떻게 그릴 것인지 묻는 인자로써, 이 인자값을 입력하지 않으면 기본적으로 &amp;quot;point&amp;quot;의 의미인 &amp;quot;p&amp;quot; 가 대부분 설정된다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;type&lt;/code&gt; 인자가 받을 수 있는 값들은 아래와 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;type = &amp;quot;p&amp;quot;&lt;/code&gt; : 점으로&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type = &amp;quot;l&amp;quot;&lt;/code&gt; : 선으로&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type = &amp;quot;b&amp;quot;&lt;/code&gt; : 점과 선 둘 다 동시에&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type = &amp;quot;o&amp;quot;&lt;/code&gt; : 점과 선 둘 다 동시에 (단 겹쳐짐 : over plotted)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type = &amp;quot;h&amp;quot;&lt;/code&gt; : 히스토그램과 비슷한 형태로 (histogram)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type = &amp;quot;s&amp;quot;&lt;/code&gt; : 계단모양으로 (stair steps)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type = &amp;quot;S&amp;quot;&lt;/code&gt; : 계단모양으로 (upper stair steps)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type = &amp;quot;n&amp;quot;&lt;/code&gt; : 좌표찍지 않음&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;type = n&lt;/code&gt;인 경우는 특이하게 plot의 토대인 축은 표현되나, 좌표가 찍히지 않음으로써&lt;br /&gt;
마치 그림을 그리기 이전 스케치북을 펼치는 것과 같다고 볼 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;), &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;), &lt;span class=&quot;dt&quot;&gt;type =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;n&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/plotFunction_6-1.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;이외의-다양한-인자들&quot;&gt;이외의 다양한 인자들&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;plot()&lt;/code&gt; 함수는 그래픽스 파라미터 &lt;code&gt;par&lt;/code&gt;를 상속받게 되어 다양한 인자들을 사용할 수 있는데, 이 특성을 잘 살리면 더 세부적인 조정이 가능하다.&lt;/p&gt;
&lt;p&gt;그래픽스 파라미터 (Graphical Parameters)의 자세한 내용과 사용 가능 인자가 무엇이 있는지 알고 싶다면&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;?par&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;를 실행시켜 도움말을 볼 수 있다.&lt;br /&gt;
&lt;code&gt;cex&lt;/code&gt;, &lt;code&gt;fg&lt;/code&gt;, &lt;code&gt;lty&lt;/code&gt;, &lt;code&gt;pch&lt;/code&gt; 등의 인자만 살펴보자&lt;/p&gt;
&lt;p&gt;만약 plotting 결과물에서 좌표 포인트의 크기를 조정하고 싶다면 &lt;code&gt;cex&lt;/code&gt; 인자값을 조정한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(dist ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;speed, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; cars, &lt;span class=&quot;dt&quot;&gt;cex =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# 디폴트로 cex=1 임, 즉 2배 크게&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/plotFunction_7-1.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(dist ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;speed, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; cars, &lt;span class=&quot;dt&quot;&gt;cex =&lt;/span&gt; .&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# 2배 작게&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/plotFunction_7-2.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;축의 색깔을 바꾸고 싶다면 전경색을 조절할 수 있는 &lt;code&gt;fg&lt;/code&gt; 인자값을 조정한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(dist ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;speed, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; cars, &lt;span class=&quot;dt&quot;&gt;fg =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;blue&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/plotFunction_8-1.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;만약 line type의 그림을 그렸다면 선의 성격을 &lt;code&gt;lty&lt;/code&gt; 인자를 통해 바꿀 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;), &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;), &lt;span class=&quot;dt&quot;&gt;type =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;l&amp;quot;&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# lty 를 언급하지 않았을 때&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/plotFunction_9-1.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;), &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;), &lt;span class=&quot;dt&quot;&gt;type =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;l&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;lty=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&amp;quot;dashed&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/plotFunction_9-2.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;만약 point type의 그림을 그렸다면 점의 모양을 &lt;code&gt;pch&lt;/code&gt; 인자를 통해 바꿀 수도 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(dist ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;speed, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; cars) &lt;span class=&quot;co&quot;&gt;# pch 를 언급하지 않았을 때&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/plotFunction_10-1.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(dist ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;speed, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; cars, &lt;span class=&quot;dt&quot;&gt;pch =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/plotFunction_10-2.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(dist ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;speed, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; cars, &lt;span class=&quot;dt&quot;&gt;pch =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;25&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# 1 ~ 25개의 모양이 준비되어 있음&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/plotFunction_10-3.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;좌표-찍기의-특성을-어기는-아니-똑똑한-제너릭-함수&quot;&gt;좌표 찍기의 특성을 어기는, 아니 똑똑한 제너릭 함수&lt;/h3&gt;
&lt;p&gt;지금까지 보았듯이 &lt;code&gt;plot()&lt;/code&gt;은 좌표 찍기의 컨셉을 이용하여 데이터시각화 결과물을 출력한다.&lt;br /&gt;
하지만 좌표 찍기에 적합하지 않은 클래스의 데이터가 입력되면 그에 알맞게 좌표 찍기의 컨셉을 버리고 다른 형태로 출력한다.&lt;/p&gt;
&lt;p&gt;아래 코드를 보면&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;fit &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;lm&lt;/span&gt;(dist ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;speed, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; cars)
&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(fit)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/plotFunction_11-1.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;img src=&quot;/assets/plotFunction_11-2.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;img src=&quot;/assets/plotFunction_11-3.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;img src=&quot;/assets/plotFunction_11-4.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;위의 코드는 &lt;code&gt;cars&lt;/code&gt; 를 대상으로 단순회귀적합을 한 lm class의 &lt;code&gt;fit&lt;/code&gt; 객체를 &lt;code&gt;plot()&lt;/code&gt; 함수에 입력한 결과인데 뭔가 많다.&lt;br /&gt;
분명 산점도이긴 산점도인데 더 복잡하고 어떠한 선분과 겹쳐져 그려진 4개의 패널로 구분된 시각화 결과물이 출력된다.&lt;br /&gt;
이는 회귀 적합 이후 모형진단 시 자주 사용하는 데이터 시각화 결과물을 &lt;code&gt;plot()&lt;/code&gt; 함수가 자동으로 알아서 모두 출력해준 것이다.&lt;br /&gt;
산점도 뿐만 아니라 완전히 성격이 바뀐 결과물을 출력하기도 한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(data.tree)
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt;(acme, &lt;span class=&quot;dt&quot;&gt;package =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;data.tree&amp;quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(acme)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/plotFunction_12.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;data.tree 라는 패키지가 있는데,&lt;br /&gt;
이 패키지에 포함되어 있는 &lt;code&gt;acme&lt;/code&gt; 데이터셋은 class 가 &lt;code&gt;data.tree&lt;/code&gt; 로써 특이한 구조를 가지고 있는 데이터셋 이다.&lt;br /&gt;
이를 &lt;code&gt;plot()&lt;/code&gt; 함수에 입력하여 plotting 하면 우리가 기존에 알고 있던 방식의 결과물이 나오지 않고 색다른 결과물이 나온다.&lt;br /&gt;
이러한 이유는 &lt;code&gt;plot()&lt;/code&gt; 이란 함수는 입력되는 데이터의 class에 알맞게 최적으로 표현해줄 수 있는 방법의 코드로 실행되기 때문이다.&lt;br /&gt;
그리고 이러한 특징을 가진 함수는 R에서 generic function이라고 부른다.&lt;br /&gt;
generic function은 사용자가 함수에 대한 문법을 정확하게 지키지 않더라도 최대한 사용자가 기대할 것 같은 결과물을 내보내기 위함이다.&lt;br /&gt;
이러한 R 시스템은 사용자 편의를 올릴 수 있게 해준다.&lt;/p&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;R을 공부하다 보면 눈에 자주 띄는 대표적인 그림이기도 하다&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Fri, 16 Jun 2017 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/data_visualization/2017/06/16/plotFunction.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/data_visualization/2017/06/16/plotFunction.html</guid>
        
        
        <category>R</category>
        
        <category>Data_Visualization</category>
        
      </item>
    
      <item>
        <title>Hello Scala! (스칼라 시작하기)</title>
        <description>&lt;p&gt;대용량 분산처리 분석시스템인 스파크(Spark)를 알기 위해 항상 마주쳤던, 그리고 발목을 잡는것이 스칼라(Scala)이었다.&lt;br /&gt;
스파크를 제대로 이용하기 위해선 스크립팅 기술이 필요한데 가장 대중적인 것이 스칼라이고 그다음이 파이썬(Python) 인 듯 보인다.&lt;br /&gt;
파이썬으로 해도 되지만 스파크의 철학을 제대로 물려받아 활용하기 위해선 스칼라를 이용할 것을 많은 곳에서 권장했다.&lt;br /&gt;
스파크에 관련된 구글링 검색만을 해보아도 예제의 코드는 스칼라코드가 더 많이 검색되었고, 이러한 이유가 분명 있을 것이기에 스칼라 공부를 시작했다.&lt;/p&gt;
&lt;p&gt;첫 공부의 시작에 앞서 책한권은 있어야 마음가짐이 잘 잡힐 것인데&lt;br /&gt;
필자는 아래의 책이 스칼라를 공부하기 위한 첫 책이다.&lt;/p&gt;
&lt;br&gt;&lt;br&gt;&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;image/HelloScala1.jpg&quot;&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&amp;amp;mallGb=KOR&amp;amp;barcode=9791185890791&amp;amp;orderClick=LAH&amp;amp;Kc=#N&quot;&gt;러닝 스칼라 - 제이슨 스와츠 지음 | 김정인, 강성용 옮김 | 제이펍 | 2017년 04월 17일 출간&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;본 글에선 &lt;strong&gt;스칼라 설치와 &amp;quot;Hello world&amp;quot; 의 출력정도의 기본적인 것을 정리&lt;/strong&gt;하는 걸 목표로 한다.&lt;br /&gt;
(단 앞으로의 내용은 Unix 계열 머신을 기준으로 설명함을 알립니다.)&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;스칼라-설치&quot;&gt;스칼라 설치&lt;/h2&gt;
&lt;p&gt;스칼라는 수동으로 설치하는 방법과 자동으로 설치하는 방법으로 나뉜다.&lt;/p&gt;
&lt;h3 id=&quot;수동설치&quot;&gt;수동설치&lt;/h3&gt;
&lt;p&gt;스칼라를 배포하는 &lt;a href=&quot;http://www.scala-lang.org/&quot;&gt;scala-lang.org&lt;/a&gt; 를 들어가면 다운로드 페이지가 있다.&lt;br /&gt;
&lt;code&gt;scala-2.XX.X.tgz&lt;/code&gt; 를 다운로드 한 이후 &lt;code&gt;bin&lt;/code&gt; 폴더를 경로에 추가하면 되겠다.&lt;/p&gt;
&lt;h3 id=&quot;자동설치&quot;&gt;자동설치&lt;/h3&gt;
&lt;p&gt;수동설치가 번거로우면 패키지 매니저를 이용해 설치하면 된다.&lt;br /&gt;
OSX 에선 Homebrew 를 통해 &lt;a href=&quot;https://opentutorials.org/course/128/11129&quot;&gt;Homebrew 설치법은 생활코딩 참고&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;sh&quot;&gt;&lt;code&gt;brew install scala&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;리눅스에선 apt-get&lt;/p&gt;
&lt;pre class=&quot;sh&quot;&gt;&lt;code&gt;apt-get install scala&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;혹은 yum 을 통해&lt;/p&gt;
&lt;pre class=&quot;sh&quot;&gt;&lt;code&gt;yum install scala&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;스칼라 설치가 가능하다.&lt;/p&gt;
수동설치 혹은 자동설치가 성공했다면 명령줄에서 &lt;code&gt;scala&lt;/code&gt; 명령어를 통해 실행 가능하다.
&lt;center&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;https://asciinema.org/a/123507.js&quot; id=&quot;asciicast-123507&quot; async&gt;&lt;/script&gt;
&lt;/center&gt;
&lt;p&gt;위의 예제는 스칼라에서 &lt;code&gt;println()&lt;/code&gt; 함수로 &amp;quot;Hello world&amp;quot; 를 출력하는 예제이다.&lt;br /&gt;
터미널 상에서 스칼라를 쓰기에는 많은 불편함이 있을 것이다.&lt;br /&gt;
적당한 텍스트 에디터에 REPL(Read Evaluate Print Loop) 을 연동시켜 사용하거나, 적절한 IDE(ntegrated Development Environment) 를 이용하는 것이 여러모로 이점이 많겠다.&lt;br /&gt;
이부분은 개인취향이므로 무언가를 추천하지는 않겠지만 필자는 &lt;a href=&quot;https://www.sublimetext.com/&quot;&gt;Sublime text 3&lt;/a&gt; 의 &lt;a href=&quot;https://packagecontrol.io/packages/SublimeREPL&quot;&gt;SublimeREPL 패키지&lt;/a&gt;를 사용해서 스칼라 스크립트를 작성하고 이 글을 작성함을 밝힌다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;값-할당&quot;&gt;값 할당&lt;/h2&gt;
&lt;p&gt;스칼라의 값 할당 방법은 다음과 같은 구문으로 약속되어 있다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;val &amp;lt;식별자&amp;gt;[: &amp;lt;타입&amp;gt;] = &amp;lt;데이터&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;값(value) 의 앞글자 &amp;quot;val&amp;quot; 로 시작하고 식별자 다음에 데이터 타입을 명시하기 위해 &lt;code&gt;:&lt;/code&gt; 로 구분한다.&lt;br /&gt;
그다음 할당할 데이터를 &lt;code&gt;=&lt;/code&gt; 이후에 입력한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode scala&quot;&gt;&lt;code class=&quot;sourceCode scala&quot;&gt;&lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; x: Int = &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; y: Int = &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;
x * y&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;https://asciinema.org/a/123515.js&quot; id=&quot;asciicast-123515&quot; async&gt;&lt;/script&gt;
&lt;/center&gt;
&lt;p&gt;데이터 타입을 항상 명시해야 하는 것은 아니다.&lt;br /&gt;
데이터 타입을 입력하지 않을 경우 타입추론에 의해 자동으로 적당한 타입을 판단하여 실행한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode scala&quot;&gt;&lt;code class=&quot;sourceCode scala&quot;&gt;&lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; x = &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; y = &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;
x * y&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;https://asciinema.org/a/123516.js&quot; id=&quot;asciicast-123516&quot; async&gt;&lt;/script&gt;
&lt;/center&gt;
&lt;p&gt;데이터 타입을 정수(Int)형으로 명시하지 않았음에도 불구하고 &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; 를 정수형으로 정의한 것을 확인할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;res-변수&quot;&gt;&lt;code&gt;res&lt;/code&gt; 변수&lt;/h2&gt;
&lt;p&gt;스칼라에선 &amp;quot;res&amp;quot; 그 뒤에 순차적으로 매겨지는 번호와 결합된 변수를 만들어 결과값 정보를 담는다.&lt;br /&gt;
이 특징을 이용하여 이전에 계산되었던 값을 불러와 재사용할 수 있을 것이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode scala&quot;&gt;&lt;code class=&quot;sourceCode scala&quot;&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;
res0 * res1&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;https://asciinema.org/a/123517.js&quot; id=&quot;asciicast-123517&quot; async&gt;&lt;/script&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;boolean&quot;&gt;Boolean&lt;/h2&gt;
&lt;p&gt;스칼라의 Boolean 타입은 &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; 값을 이용한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode scala&quot;&gt;&lt;code class=&quot;sourceCode scala&quot;&gt;&lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt; &amp;gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt; &amp;lt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt; == &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt; == &lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;https://asciinema.org/a/123520.js&quot; id=&quot;asciicast-123520&quot; async&gt;&lt;/script&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;tuple&quot;&gt;Tuple&lt;/h2&gt;
&lt;p&gt;튜풀은 데이터를 담는 컨테이너 중에서 순서가 있고 복수개의 값들을 담는 컨테이너를 의미한다.&lt;br /&gt;
소괄호를 이용하면 데이터 타입을 명시하지 않고도 튜플을 만들 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode scala&quot;&gt;&lt;code class=&quot;sourceCode scala&quot;&gt;&lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; tuple = (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;4.0&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;Five&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;https://asciinema.org/a/123522.js&quot; id=&quot;asciicast-123522&quot; async&gt;&lt;/script&gt;
&lt;/center&gt;
&lt;p&gt;튜플에 들어가는 각 원소들은 그 원소들끼리의 데이터타입이 통일될 필요는 없다.&lt;br /&gt;
위의 예제처럼 Int, Double, String 3개의 각기다른 데이터타입이 튜플이라는 컨테이너에 담을 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;표현식-블록&quot;&gt;표현식 블록&lt;/h2&gt;
&lt;p&gt;실행시킬 복수줄의 코드단위를 중괄호로 묶어 하나의 표현식(expression)으로 관리하는것이 스칼라에선 가능하다.&lt;br /&gt;
그리고 복잡한 표현식을 실행시킨 결과를 반환값으로 사용할 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode scala&quot;&gt;&lt;code class=&quot;sourceCode scala&quot;&gt;&lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; result = {
  &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; x: Double = &lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;
  x * &lt;span class=&quot;fl&quot;&gt;0.5&lt;/span&gt;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;https://asciinema.org/a/123525.js&quot; id=&quot;asciicast-123525&quot; async&gt;&lt;/script&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;주석&quot;&gt;주석&lt;/h2&gt;
&lt;p&gt;스칼라에서 주석은 &lt;code&gt;//&lt;/code&gt; 을 이용한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode scala&quot;&gt;&lt;code class=&quot;sourceCode scala&quot;&gt;&lt;span class=&quot;co&quot;&gt;// println(&amp;quot;Comment&amp;quot;)&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;Not comment&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;https://asciinema.org/a/123526.js&quot; id=&quot;asciicast-123526&quot; async&gt;&lt;/script&gt;
&lt;/center&gt;
&lt;p&gt;주석이 처리된 코드는 실행되지 않는 것을 확인할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;매치표현식을-이용한-조건부-로직&quot;&gt;매치표현식을 이용한 조건부 로직&lt;/h2&gt;
&lt;p&gt;스칼라에선 if else 구문의 조건문보다 매치표현식을 이용한 조건문을 즐겨 사용한다고 한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode scala&quot;&gt;&lt;code class=&quot;sourceCode scala&quot;&gt;&lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; today = &lt;span class=&quot;st&quot;&gt;&amp;quot;Tue&amp;quot;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (today == &lt;span class=&quot;st&quot;&gt;&amp;quot;Mon&amp;quot;&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;Weekday&amp;quot;&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (today == &lt;span class=&quot;st&quot;&gt;&amp;quot;Tue&amp;quot;&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;Weekday&amp;quot;&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (today == &lt;span class=&quot;st&quot;&gt;&amp;quot;Wed&amp;quot;&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;Weekday&amp;quot;&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (today == &lt;span class=&quot;st&quot;&gt;&amp;quot;Thu&amp;quot;&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;Weekday&amp;quot;&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (today == &lt;span class=&quot;st&quot;&gt;&amp;quot;Fri&amp;quot;&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;Weekday&amp;quot;&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (today == &lt;span class=&quot;st&quot;&gt;&amp;quot;Sat&amp;quot;&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;Weekend&amp;quot;&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (today == &lt;span class=&quot;st&quot;&gt;&amp;quot;Sun&amp;quot;&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;Weekend&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;https://asciinema.org/a/125089.js&quot; id=&quot;asciicast-125089&quot; async&gt;&lt;/script&gt;
&lt;/center&gt;
&lt;p&gt;위의 if else 구문 코드는 &lt;code&gt;today&lt;/code&gt; 요일이 언제인지에 따라 &amp;quot;Weekday&amp;quot;, &amp;quot;Weekend&amp;quot; 로 주중인지 주말인지를 출력한다.&lt;/p&gt;
&lt;p&gt;매치표현식을 이용해본 코드는&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode scala&quot;&gt;&lt;code class=&quot;sourceCode scala&quot;&gt;&lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; today = &lt;span class=&quot;st&quot;&gt;&amp;quot;Tue&amp;quot;&lt;/span&gt;

today &lt;span class=&quot;kw&quot;&gt;match&lt;/span&gt; {
  &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;Mon&amp;quot;&lt;/span&gt; | &lt;span class=&quot;st&quot;&gt;&amp;quot;Tue&amp;quot;&lt;/span&gt; | &lt;span class=&quot;st&quot;&gt;&amp;quot;Wed&amp;quot;&lt;/span&gt; | &lt;span class=&quot;st&quot;&gt;&amp;quot;Thu&amp;quot;&lt;/span&gt; | &lt;span class=&quot;st&quot;&gt;&amp;quot;Fri&amp;quot;&lt;/span&gt; =&amp;gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;Weekday&amp;quot;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;Sat&amp;quot;&lt;/span&gt; | &lt;span class=&quot;st&quot;&gt;&amp;quot;Sun&amp;quot;&lt;/span&gt; =&amp;gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;Weekend&amp;quot;&lt;/span&gt;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;https://asciinema.org/a/125090.js&quot; id=&quot;asciicast-125090&quot; async&gt;&lt;/script&gt;
&lt;/center&gt;
&lt;p&gt;&lt;code&gt;match&lt;/code&gt;, &lt;code&gt;case&lt;/code&gt; 를 통해 간결해 진 코드를 볼 때 if else 구문이 상당히 조악하게 보여졌다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;for-loop&quot;&gt;for loop&lt;/h2&gt;
&lt;p&gt;반복문 for loop 역시 스칼라에서 지원되며 강력한 기능들을 더할 수 있었다.&lt;br /&gt;
기본적인 사용법은 아래 구문 형태를 이용한다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;for (&amp;lt;식별자&amp;gt; &amp;lt;- &amp;lt;반복범위&amp;gt;) &amp;lt;표현식&amp;gt;&lt;/code&gt; 혹은 &lt;code&gt;for {&amp;lt;식별자&amp;gt; &amp;lt;- &amp;lt;반복범위&amp;gt;} &amp;lt;표현식&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;아래는 for 문을 이용하여 &amp;quot;Day1)&amp;quot; 부터 &amp;quot;Day10)&amp;quot; 까지 10개의 날을 출력하는 예제코드이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode scala&quot;&gt;&lt;code class=&quot;sourceCode scala&quot;&gt;&lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; {x &amp;lt;- &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; to &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;} &lt;span class=&quot;fu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;Day&amp;quot;&lt;/span&gt; + x + &lt;span class=&quot;st&quot;&gt;&amp;quot;) &amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;https://asciinema.org/a/125091.js&quot; id=&quot;asciicast-125091&quot; async&gt;&lt;/script&gt;
&lt;/center&gt;
&lt;h3 id=&quot;nested-for-loop&quot;&gt;Nested for loop&lt;/h3&gt;
&lt;p&gt;for 반복문을 중첩시키는 예제의 경우 스칼라에선 세련된 방법이 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode scala&quot;&gt;&lt;code class=&quot;sourceCode scala&quot;&gt;&lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; {x &amp;lt;- &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; to &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;}{
  &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; {y &amp;lt;- &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; to &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;}{
    &lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(x * y)
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위의 예제는 for문 안에 for문이 중첩하여 여섯경우의 곱 결과를 보여준다.&lt;br /&gt;
그런데 이것을 아래와 같이 간단하게 코딩을 줄이는것이 가능하다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode scala&quot;&gt;&lt;code class=&quot;sourceCode scala&quot;&gt;&lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; {x &amp;lt;- &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; to &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;; y &amp;lt;- &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; to &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;} &lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(x * y)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;두 반복자를 &lt;code&gt;;&lt;/code&gt; 를 이용해 for 문에 한꺼번에 입력하거나&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode scala&quot;&gt;&lt;code class=&quot;sourceCode scala&quot;&gt;&lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; {x &amp;lt;- &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; to &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;
     y &amp;lt;- &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; to &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;} &lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(x * y)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;문단을 나누어도 되겠다.&lt;/p&gt;
&lt;center&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;https://asciinema.org/a/130236.js&quot; id=&quot;asciicast-130236&quot; async&gt;&lt;/script&gt;
&lt;/center&gt;
</description>
        <pubDate>Tue, 06 Jun 2017 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/scala/2017/06/06/HelloScala.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/scala/2017/06/06/HelloScala.html</guid>
        
        
        <category>Scala</category>
        
      </item>
    
      <item>
        <title>클라우드 스토리지 서비스 이용을 권장하고 보편화 하려는 이유</title>
        <description>&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;오늘 작성하는 문서는 내일의 작업을 더 효율적으로 만들어야 한다. - Git for Teams (엠마 제인 호그빈 웨스트비) 과 보이스카우트 규칙&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;필자는 2인 이상 공동작업 프로젝트 시 최소한 &lt;strong&gt;클라우드 스토리지 서비스를 이용해 파일을 관리하자&lt;/strong&gt;는 주장을 많이 펼치는 편이다.&lt;br /&gt;
나는 클라우드 스토리지 서비스를 &lt;a href=&quot;https://www.dropbox.com/business/landing-t61fl?_tk=sem_b_goog&amp;amp;_camp=sem-b-goog-korea&amp;amp;_kw=dropbox%7Ce&amp;amp;_ad=50011987662%7C1t1%7Cc&amp;amp;gclid=CjwKEAjw07nJBRDG_tvshefHhWQSJABRcE-ZOBclGlASA1UBYKhUJhnawAiVLXnyP748IVb2hAQswxoCEoTw_wcB&quot;&gt;드롭박스(Dropbox)&lt;/a&gt;를 통해 처음 알게 되었다.&lt;br /&gt;
드롭박스라는 서비스가 처음 출시되었을 때 (약 2007년)부터 사용했는데 그 이전과 이후의 삶을 비교해보면 확연히 다름이 느껴진다.&lt;br /&gt;
08학번인 나는 운 좋게도 이러한 서비스를 대학생이 되었을 때부터 사용할 수 있었던 환경이었다.&lt;br /&gt;
따라서 학생 시절 클라우드 스토리지 서비스에 대한 거부감이 없는 시절을 보낸 시대인 듯싶다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/CI1.png&quot;&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;본론으로 들어가 보려 한다.&lt;br /&gt;
&lt;strong&gt;글의 주제는 &amp;quot;클라우드 스토리지 서비스 이용을 권장하고 보편화하려는 이유&amp;quot; 이다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;혼자 일할 때는 개인의 컴퓨터 하드에 개인적으로만 파일을 관리하는 것은 전혀 문제 되지 않는다.&lt;br /&gt;
하지만 팀 차원에서 2인 이상이 일할 땐 위의 방식은 경험적으론 언젠간 문제가 닥쳐왔었고, 이 문제는 프로젝트가 장기적이면 장기적일수록 심각한 문제로 파생되고 뜯어고치기 쉽지 않다.&lt;/p&gt;
&lt;p&gt;자 이제 &amp;quot;개인의 컴퓨터 하드에 개인적으로만 파일을 관리&amp;quot; 의 방식을 대조군으로 설정하고 사견을 정리해 보고자 한다.&lt;/p&gt;
&lt;p&gt;팀이 만들어지는 이유를 잠깐 곱씹어 보면, 2명 이상이 바라보는 동일한 목적을 이루기 위한 이합집산이다.&lt;br /&gt;
조금 엄격하게 말한 측면도 있지만 사실은 사실이다.&lt;br /&gt;
또 한가지 엄격하게 더 말하자면 팀의 개개인별 역량과 성격은 서로 다르게 된다.&lt;br /&gt;
우리가 바라보는 그 원대한 목적은 조금 거대하고 어려워서 다양한 역량이 필요하다.&lt;br /&gt;
따라서 팀은 최대한 다른 성격, 서로 다른 역량을 가진 팀원들이 모이게 되는 것이라 생각한다.&lt;br /&gt;
개개인별로 각기 다른 역량을 발휘해 동일한 목적을 좀 더 빠르고 잘 이룰 수 있게 하려는 방법을 사회적으로 고민했고 많은 시행착오가 과거에 있었을 것이다.&lt;br /&gt;
그 결과 많은 곳에선 지속적 통합(Continuous Integration)을 대안으로 제시했다.&lt;br /&gt;
지속적 통합 없이 개개인의 역량이 꾸준하게 발휘될 경우 공동목표에서 벗어나 배가 산으로 가는 경우가 많아질 것이다.&lt;br /&gt;
이처럼 별개의 독립된 환경 속에서 각자 작업을 하다가 끝에 가서 통합을 해야 할 경우 속칭 &lt;strong&gt;&lt;a href=&quot;http://wiki.c2.com/?IntegrationHell&quot;&gt;&amp;quot;통합의 지옥&amp;quot;&lt;/a&gt; 이라 불리는 상황에 빠지게 된다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;팀단위로 일하는 프로젝트에서 &amp;quot;통합의 지옥&amp;quot;에 빠지지 않기 위해선 많은 의사소통이 필요하며, 이 소통에 투자되는 시간은 중요함과 동시에 많이 소요된다.&lt;br /&gt;
이 중요성을 정말 많은 사람들이 잘 알고 있어서인지 대부분의 업무시간이 &amp;quot;회의&amp;quot;로 꽉꽉 채워지는 사례도 많다.&lt;br /&gt;
얼마나 중요하면 정말 일을 못하고 회의만 하다가 하루를 다 보내는 걸까? 왜 이런 일이 일어나는 것일까?&lt;/p&gt;
&lt;p&gt;필자는 이 의문을 항상 가지고 근본적인 원인이 무엇 때문인지 많은 고민해 보았다.&lt;br /&gt;
그 끝에는 대조군으로 설정한 위의 방식 때문이란 결론으로 다다른다.&lt;br /&gt;
어디까지나 사견이고 과장된 생각일 수 있지만 위의 대조군 방식의 가장 우려하는 부분은&lt;br /&gt;
개개인별로 의도한 적은 없어도 자연스럽게 &amp;quot;통합의 지옥&amp;quot;을 필연적으로 만날 수 밖에 없는 틀이고, 더불어 &lt;a href=&quot;http://mstockblog.com/220816437407&quot;&gt;사일로 효과&lt;/a&gt;를 내는 근본적 원인이라는 점이다.&lt;/p&gt;
&lt;p&gt;다시 한번 말하지만, 지금은 지속적 통합을 대안으로 제시하고 있다.&lt;br /&gt;
그리고 개발자에게만 친숙할 것 같은 이 지속적 통합의 단어를 다른 일반인들에게도 손쉽게 적용코자 하는 수많은 서비스가 성공하고 있고 자리를 잡아가고 있다.&lt;br /&gt;
가장 손쉽게 적용할 수 있는 서비스가 바로 클라우드 스토리지 서비스이다.&lt;/p&gt;
&lt;p&gt;클라우드 스토리지 서비스를 이용하게 되면 다양한 이득들이 있지만&lt;br /&gt;
지금 강조하고자 하는 강점은 누구든지 공유폴더를 쉽게 만들 수 있다는 점이고, 이어서 &lt;strong&gt;팀원이 똑같은 곳을 바라보면서(Keep everyone on the same page) 지속적 통합을 유도할 수 있다&lt;/strong&gt;는 것이다.&lt;br /&gt;
인터넷만 연결된 환경이라면 &lt;a href=&quot;https://namu.wiki/w/NAS(%EC%A0%80%EC%9E%A5%EC%9E%A5%EC%B9%98)&quot;&gt;NAS(Network Attached Storage)&lt;/a&gt;처럼 일정 비용과 구축준비가 필요한 방법보단 클라우드 스토리지 서비스를 통해 이 지속적 통합을 간단히 구현할 수 있고,&lt;br /&gt;
자연스럽게 통합된 서로의 생각이 조화되면서 결과물이 만들어 질 수 있으므로 공통된 목표로 달려가는데 도움이 될 것이라 단언한다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/CI2.jpg&quot;&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://brunch.co.kr/@lunarshore/55&quot;&gt;빅데이터와 비즈니스 프로세스 - 정보 처리가 기업 경쟁력 (취합받고 깨진 파일 신경 쓰느라 날린 시간들)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;팀을 위한 Git(Git for Teams) - 엠마 제인 호그빈 웨스트비&lt;/li&gt;
&lt;li&gt;훌륭한 프로그래머 되는 법(Becoming a Better Programmer) - 피트 구들리프&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 01 Jun 2017 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/etc/2017/06/01/Continuous_Integrations.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/etc/2017/06/01/Continuous_Integrations.html</guid>
        
        
        <category>etc</category>
        
      </item>
    
      <item>
        <title>R에서 행렬 간 이루어지는 다양한 곱셈에 대해 알아보기 (행렬의 곱셈, 하다마드 곱셈, 크로네커 곱셈)</title>
        <description>&lt;p&gt;행렬과 행렬간 곱셈은 행렬 A와 B가 아래와 같이 주어졌을 때&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;img src=&quot;/assets/MatrixProduct_1.png&quot; width=&quot;500&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;행렬 A와 행렬 B의 곱은&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;img src=&quot;/assets/MatrixProduct_2.png&quot; width=&quot;450&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;이며, 이때 앞에 위치한 행렬의 열의 수와 뒤에 위치한 행렬의 행의 수가 같아야 행렬곱이 가능하다.&lt;br /&gt;
R에서 위와 같은 행렬의 곱셈을 실행하기 위해서는 &lt;code&gt;*&lt;/code&gt; 연산자가 아닌 &lt;code&gt;%*%&lt;/code&gt; 를 이용한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;(A &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;matrix&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;( &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,  &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;), &lt;span class=&quot;dt&quot;&gt;nrow =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;ncol =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] [,2]
## [1,]    2    1
## [2,]    7    3&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;(B &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;matrix&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(-&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, -&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;), &lt;span class=&quot;dt&quot;&gt;nrow =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;ncol =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] [,2]
## [1,]   -2    1
## [2,]    7   -3&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;A %*%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;B&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] [,2]
## [1,]    3   -1
## [2,]    7   -2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;일반적인 행렬의 곱셈은 &lt;code&gt;%*%&lt;/code&gt; 을 이용해야 한다고 했는데&lt;br /&gt;
그럼 &lt;code&gt;*&lt;/code&gt; 이것을 이용하면 어떻게 될까?&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;하다마드-곱셈-hadamard-product&quot;&gt;하다마드 곱셈 (Hadamard Product)&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;A *&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;B&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] [,2]
## [1,]   -4    1
## [2,]   49   -9&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;동일한 위치의 원소끼리의 곱이 되어 버린다.&lt;br /&gt;
사실 동일차원의 행렬끼리 동일위치원소와 곱해지는 곱셈을 하다마드 곱셈(Hadamard Product) 이라고도 부르는데, 위의 코드가 바로 하다마드 곱셈을 하는 코드로 볼 수 있겠다.&lt;br /&gt;
여하튼 R에서는 &lt;code&gt;%*%&lt;/code&gt; 사이에 행렬객체를 넣고 실행하면 행렬간 곱셈을,&lt;br /&gt;
&lt;code&gt;*&lt;/code&gt; 사이에 넣어주면 하다마드 곱셈을 실행킨다는 차이를 확인할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;크로네커-곱셈-kronecker-product&quot;&gt;크로네커 곱셈 (Kronecker Product)&lt;/h2&gt;
&lt;p&gt;행렬의 곱셈 중 크로네커 곱셈(Kronecker Product)이라는 것도 있다.&lt;br /&gt;
가끔 요긴하게 쓸 때가 있는 이 크로네커 곱셈은 이런 형태이다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;img src=&quot;/assets/MatrixProduct_3.png&quot; width=&quot;500&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;일 때 행렬 A와 행렬 B간 크로네커 곱셈 &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;A&lt;/em&gt; ⊗ &lt;em&gt;B&lt;/em&gt;&lt;/span&gt; 는 아래와 같다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;img src=&quot;/assets/MatrixProduct_4.png&quot; width=&quot;450&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;A&lt;/em&gt; ⊗ &lt;em&gt;B&lt;/em&gt;&lt;/span&gt; 를 계산한 후 행렬의 크기를 보게 된다면 &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;m&lt;/em&gt;&lt;em&gt;n&lt;/em&gt; × &lt;em&gt;n&lt;/em&gt;&lt;em&gt;p&lt;/em&gt;&lt;/span&gt; 행렬이 만들어 지게 될 것이다.&lt;/p&gt;
&lt;p&gt;크로네커 곱셈을 이용하면 행렬의 크기는 크되 일정한 규칙이 존재하는 행렬을 손쉽게 만들 수 있을 것이다.&lt;br /&gt;
예를들면 아래와 같은 행렬을 R에서 만들어 보겠다고 가정한다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;img src=&quot;/assets/MatrixProduct_5.png&quot; width=&quot;200&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;이 행렬 M을 만들기 위해&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;e &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;rep&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;32&lt;/span&gt;), &lt;span class=&quot;kw&quot;&gt;rep&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;24&lt;/span&gt;), &lt;span class=&quot;kw&quot;&gt;rep&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;), &lt;span class=&quot;kw&quot;&gt;rep&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;24&lt;/span&gt;), &lt;span class=&quot;kw&quot;&gt;rep&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;))
(M &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;matrix&lt;/span&gt;(e, &lt;span class=&quot;dt&quot;&gt;ncol =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##       [,1] [,2] [,3] [,4]
##  [1,]    1    1    0    0
##  [2,]    1    1    0    0
##  [3,]    1    1    0    0
##  [4,]    1    1    0    0
##  [5,]    1    1    0    0
##  [6,]    1    1    0    0
##  [7,]    1    1    0    0
##  [8,]    1    1    0    0
##  [9,]    1    0    1    0
## [10,]    1    0    1    0
## [11,]    1    0    1    0
## [12,]    1    0    1    0
## [13,]    1    0    1    0
## [14,]    1    0    1    0
## [15,]    1    0    1    0
## [16,]    1    0    1    0
## [17,]    1    0    0    1
## [18,]    1    0    0    1
## [19,]    1    0    0    1
## [20,]    1    0    0    1
## [21,]    1    0    0    1
## [22,]    1    0    0    1
## [23,]    1    0    0    1
## [24,]    1    0    0    1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;와 같은 형식의 코드를 짤 수도 있다.&lt;br /&gt;
하지만 &lt;code&gt;c(rep(1, 32), rep(0, 24), rep(1, 8), rep(0, 24), rep(1, 8))&lt;/code&gt; 처럼 손이 많이 가는 코드를 작성해야 하는데, 크로네커 곱셈을 약간 응용하면 행렬 M을 좀 더 편하게 만들 수 있을 것이다.&lt;br /&gt;
R에서 크로네커 곱셈을 수행하는 함수는 &lt;code&gt;kronecker()&lt;/code&gt; 이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;(A &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;matrix&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;), &lt;span class=&quot;dt&quot;&gt;ncol =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] [,2] [,3] [,4]
## [1,]    1    1    0    0
## [2,]    1    0    1    0
## [3,]    1    0    0    1&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;(B &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;matrix&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;rep&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;)))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##      [,1]
## [1,]    1
## [2,]    1
## [3,]    1
## [4,]    1
## [5,]    1
## [6,]    1
## [7,]    1
## [8,]    1&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;(M &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;kronecker&lt;/span&gt;(A, B))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##       [,1] [,2] [,3] [,4]
##  [1,]    1    1    0    0
##  [2,]    1    1    0    0
##  [3,]    1    1    0    0
##  [4,]    1    1    0    0
##  [5,]    1    1    0    0
##  [6,]    1    1    0    0
##  [7,]    1    1    0    0
##  [8,]    1    1    0    0
##  [9,]    1    0    1    0
## [10,]    1    0    1    0
## [11,]    1    0    1    0
## [12,]    1    0    1    0
## [13,]    1    0    1    0
## [14,]    1    0    1    0
## [15,]    1    0    1    0
## [16,]    1    0    1    0
## [17,]    1    0    0    1
## [18,]    1    0    0    1
## [19,]    1    0    0    1
## [20,]    1    0    0    1
## [21,]    1    0    0    1
## [22,]    1    0    0    1
## [23,]    1    0    0    1
## [24,]    1    0    0    1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이처럼 &lt;code&gt;kronecker(A, B)&lt;/code&gt; 코드를 실행하면 &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;A&lt;/em&gt; ⊗ &lt;em&gt;B&lt;/em&gt;&lt;/span&gt; 를 연산해준다.&lt;/p&gt;
</description>
        <pubDate>Tue, 30 May 2017 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2017/05/30/MatrixProduct.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2017/05/30/MatrixProduct.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>온라인 설문지 서비스 Typeform 소개, 설문조사 방법에 대한 설문조사</title>
        <description>&lt;p&gt;평범한 일상생활 속에서도 사람의 생각과 의견을 수렴할 일들은 참 많이 일어난다.&lt;br /&gt;
필자의 경우 학창시절을 돌이켜 볼 때 통계관련 수업시 툭하면 마주하는 프로젝트가 &amp;quot;설문조사&amp;quot; 와 관련된 것이었다.&lt;br /&gt;
이때마다 설문지를 워드나 한글로 타이핑하고 굳이 출력해서 손수 나눠준 후 일일이 되돌려 받는 형식의 설문조사가 일방적으로 이루어졌다.&lt;br /&gt;
설문지를 취합해서 코딩과 펀칭을 하는 수고는 즐겁기도 하면서 손이 많이 가고 큰 정성을 필요로 했다.&lt;br /&gt;
반대로 설문지를 응답하는 상황에서도 이러한 형태의 설문조사방식을 많이 겪는 편인 것 같다.&lt;/p&gt;
&lt;p&gt;설문조사자로서의 입장, 그리고 설문응답자로서의 입장들을 겪을 때마다 느껴지는 질문은&lt;br /&gt;
&amp;quot;의견을 온전하게 전달하고 받을 수 있는 최선의 방법은 무엇일까?&amp;quot; 이다.&lt;br /&gt;
소통은 &lt;strong&gt;말하는 사람&lt;/strong&gt;과 &lt;strong&gt;듣는 사람&lt;/strong&gt; 그리고 &lt;strong&gt;전달 매체(언어)&lt;/strong&gt; 이렇게 3가지 요소가 있는데&lt;br /&gt;
설문조사 측면에선 &lt;strong&gt;조사자&lt;/strong&gt;, &lt;strong&gt;응답자&lt;/strong&gt;, 그리고 &lt;strong&gt;조사방법&lt;/strong&gt; 이렇게 3가지 요소와 비슷하다고 생각한다.&lt;br /&gt;
소통에서 전달 매체의 선택이 잘못될 경우 소통이 불가하다.&lt;br /&gt;
이처럼 설문조사에서 조사방법을 잘 선택하고 설계하는 것은 중요한 문제이다.&lt;/p&gt;
&lt;p&gt;그런 의미에서 여러 시도를 해보고 있다.&lt;br /&gt;
지금까지도 많이 쓰이는 전통적인 종이 설문지 배포 및 수거 방법 외에 다른 방법들이 무엇이 있을까 찾아보고 있고&lt;br /&gt;
좀 더 현명한 방법은 무엇일지 실험을 해보고 있다.&lt;/p&gt;
&lt;p&gt;그중 최근 한 실험은 &lt;a href=&quot;https://www.typeform.com&quot;&gt;Typeform&lt;/a&gt; 과 같은 툴을 이용해 온라인 설문조사 방식이다.&lt;br /&gt;
아래는 Typeform 서비스의 힘을 빌려 만들어 본 설문지이다.&lt;br /&gt;
주제는 이글과 연관있는 &amp;quot;설문조사 방법에 대한 설문조사&amp;quot; 이다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;통계 R 프로그래밍 카페에 배포한 온라인 설문지 (관심있다면 설문응답 해주셔도 됩니다)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;typeform-widget&quot; data-url=&quot;https://lovetoken.typeform.com/to/oQCtip&quot; style=&quot;width: 100%; height: 1100px;&quot;&gt;

&lt;/div&gt;
&lt;script&gt;(function(){var qs,js,q,s,d=document,gi=d.getElementById,ce=d.createElement,gt=d.getElementsByTagName,id=&quot;typef_orm&quot;,b=&quot;https://s3-eu-west-1.amazonaws.com/share.typeform.com/&quot;;if(!gi.call(d,id)){js=ce.call(d,&quot;script&quot;);js.id=id;js.src=b+&quot;widget.js&quot;;q=gt.call(d,&quot;script&quot;)[0];q.parentNode.insertBefore(js,q)}})()&lt;/script&gt;
&lt;div style=&quot;font-family: Sans-Serif;font-size: 12px;color: #999;opacity: 0.5; padding-top: 5px;&quot;&gt;
powered by &lt;a href=&quot;https://www.typeform.com/examples/?utm_campaign=oQCtip&amp;amp;utm_source=typeform.com-7938314-Basic&amp;amp;utm_medium=typeform&amp;amp;utm_content=typeform-embedded-poweredbytypeform&amp;amp;utm_term=KO&quot; style=&quot;color: #999&quot; target=&quot;_blank&quot;&gt;Typeform&lt;/a&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;위와 같이 온라인 설문조사를 직접 만들고 배포를 도와주는 서비스는 여러 가지가 있다.&lt;/p&gt;
&lt;p&gt;가장 대중적인 &lt;a href=&quot;https://www.google.com/intl/ko_kr/forms/about/&quot;&gt;Google docs&lt;/a&gt; 부터 시작해 &lt;a href=&quot;https://ko.surveymonkey.com&quot;&gt;Surveymonkey&lt;/a&gt;, &lt;a href=&quot;https://www.mysurveyasia.co.kr&quot;&gt;Mysurvey&lt;/a&gt;, &lt;a href=&quot;https://www.typeform.com&quot;&gt;Typeform&lt;/a&gt; 등이 있으며&lt;br /&gt;
국내서비스로는 &lt;a href=&quot;http://www.nownsurvey.com&quot;&gt;나우서베이&lt;/a&gt;, &lt;a href=&quot;http://www.ozsurvey.co.kr&quot;&gt;오즈서베이&lt;/a&gt; 등이 있다.&lt;/p&gt;
&lt;p&gt;이 중에서 가장 최근에 서비스를 시작한(2014년)&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; Typeform 의 인기가 요즘 높다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;typeform-소개&quot;&gt;Typeform 소개&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Typeform.com Explainer Video&lt;/p&gt;
&lt;/blockquote&gt;
&lt;iframe width=&quot;100%&quot; height=&quot;350&quot; src=&quot;https://www.youtube.com/embed/5ghyOrFDdaY&quot; frameborder=&quot;0&quot; allowfullscreen&gt;
&lt;/iframe&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;온라인 설문서비스는 딱히 설명할 필요가 없을 정도로 GUI 가 매우 잘 되어있는 편이다.&lt;br /&gt;
&amp;quot;선 배움 후 실습&amp;quot; 이 아닌 &amp;quot;선 실습 후 배움&amp;quot; 이 가능한 서비스이다. 쉽기 때문에 이게 가능하다.&lt;br /&gt;
Typeform 역시 마찬가지이다. 가입 후에 로그인하는 즉시 웹상에서 동작한다.&lt;br /&gt;
이것저것 만져보고 단순한 설문문서를 만들어 보자.&lt;br /&gt;
필자가 만든 위 설문지 역시 &lt;a href=&quot;https://www.typeform.com/tour/&quot;&gt;공식 홈페이지의 튜토리얼&lt;/a&gt;을 1분도 안 보고 만든 첫 설문지이다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/tf1.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/tf2.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;설문 문항은 드래그 &amp;amp; 드랍 방식으로 원하는 곳에 배치할 수 있고&lt;br /&gt;
작은 글과 응답 유형별로 제공되는 메뉴를 통해 손쉽게 만들 수 있다.&lt;br /&gt;
구조적인 설문지가 아닌 이상 Multiple choice 기능만으로 설문지를 만드는데 아무 문제가 없을 것이다.&lt;/p&gt;
&lt;p&gt;만드는 즉시 설문지를 배포할 수 있는 링크가 생긴다.&lt;br /&gt;
그 링크는 상단에 Build, Design, Configure, Share, Analyze 5개의 메뉴 중 Share 로 들어가 보면&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/tf3.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;copy 버튼을 눌러 링크를 이용할 수 있다.&lt;br /&gt;
이 링크를 통해 언제 어디서든 응답자에게 설문지를 배포하고 시간과 장소 제약 없이 응답할 수 있게 된다.&lt;/p&gt;
&lt;p&gt;만약 응답자가 링크를 클릭 후 설문에 응답하여 제출버튼을 누른다면&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/tf4.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;설문지를 만든 관리자는&lt;br /&gt;
그 응답자의 결과뿐만 아니라 지금까지 모든 응답에 대해 취합한 report 를 Analyze 메뉴를 통해 확인할 수 있다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/tf5.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;취합결과 역시 &lt;a href=&quot;https://lovetoken.typeform.com/report/oQCtip/vVGD&quot;&gt;여기처럼&lt;/a&gt; 외부링크를 뽑아올 수 있어 공유가 가능하다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/tf6.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;Design 메뉴를 통해 설문지의 템플릿을 원하는 것으로 바꿀 수 있다.&lt;br /&gt;
클릭 몇 번만으로 수려한 디자인의 설문지를 만들 수 있겠다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/tf7.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/tf8.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;이정도만 알아도 사실 다 안 것이고 설문조사를 하는데 아무 문제 없다.&lt;br /&gt;
단 구조화된 설문지(조건부 별로 다른 조사항목이 출현하는 예), 응답완료에 대한 확인메일송신 기능, 파일 업로드 기능 활성화, 응답 및 조사항목 제한해제등을 위해선 요금을 내고 Pro upgrade 를 해야한다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;온라인-설문의-대중화&quot;&gt;온라인 설문의 대중화&lt;/h2&gt;
&lt;p&gt;전통적인 설문방법(설문지를 출력해서 손수 나눠준 후 되돌려 받는 형식)과 온라인 설문방법은 각기 장단점이 존재한다.&lt;br /&gt;
전통적인 설문방법의 장점은 누구든지 쉽게 떠올릴 수 있는 방법이고 펜과 종이만 있으면 가능하다.&lt;br /&gt;
상황에 따라 면대면으로 심층적인 설문을 할 수 있다.&lt;br /&gt;
무엇보다 가장 큰 장점은 전통적이라는 의미에는 전혀 거부감이 없다는 의미를 내포한다는 점에 있다.&lt;/p&gt;
&lt;p&gt;온라인 설문의 장점은 비대면 방식의 특징으로 생기는 것들에 있다.&lt;br /&gt;
설문조사자의 눈치를 보지 않고 언제 어디서든 자유롭게 응답할 수 있기 때문에 오히려 왜곡되지 않는 온전한 의견을 조사자가 응답받을 수도 있다.&lt;br /&gt;
간편한 방법을 통해 응답회수율을 높일 수 있으며,&lt;br /&gt;
응답 이후 관리 측면에서는 전통적인 설문방법과 비교될 수 없는 높은 생산성을 가지고 있다.&lt;/p&gt;
&lt;p&gt;이처럼 각자의 장점들이 있다.&lt;br /&gt;
그런데 (Typeform 서비스를 예로 들었지만 이러한) 온라인 설문 서비스를 알기 전에는 편의성이 얼마나 높은지 인지할 수 없었다.&lt;br /&gt;
그리고 인터넷 매체의 발전에 힘입어 온라인 설문은 자연스럽게 대중화되었고 많은 사람이 채택하는 방법이 되었다.&lt;br /&gt;
필자는 수백명 단위의 응답자와 종이 설문지들에 파묻혀 온 시간을 쏟아 리서치를 한 경험이 많았는데&lt;br /&gt;
자괴감을 많이 느낄 정도로 온라인 설문은 큰 강점을 가지고 있음을 뒤늦게 깨달은 것 같다.&lt;/p&gt;
&lt;p&gt;대세는 거스를 수 없다. 대중화되는 이유를 살펴보고 이용해 봄으로써 새로운 방법을 인지하고 싶다면,&lt;br /&gt;
특히 리서치를 사서 고생하는 느낌이 든다면 이러한 서비스를 적극적으로 사용해 보길 추천하고 싶다.&lt;/p&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;&lt;a href=&quot;https://thenextweb.com/apps/2014/02/12/typeform/#.tnw_KfglfLLI&quot;&gt;Steve O&#39;Hear (September 23, 2014). &amp;quot;Online Survey And Form Builder Typeform Raises €1.2M&amp;quot;.&lt;/a&gt;&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Thu, 04 May 2017 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/etc/2017/05/04/Typeform.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/etc/2017/05/04/Typeform.html</guid>
        
        
        <category>etc</category>
        
      </item>
    
  </channel>
</rss>
