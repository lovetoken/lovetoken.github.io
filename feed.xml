<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description></description>
    <link>https://lovetoken.github.io/</link>
    <atom:link href="https://lovetoken.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 11 May 2019 23:05:32 +0900</pubDate>
    <lastBuildDate>Sat, 11 May 2019 23:05:32 +0900</lastBuildDate>
    <generator>Jekyll v3.1.6</generator>
    
      <item>
        <title>Tidyverse before &amp; after (Comming Soon)</title>
        <description>&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://tidyverse-korea.github.io/r-meetup-x-presser/&quot;&gt;Tidyverse korea 의 데이터 사이언스 Meetup&lt;/a&gt; 에서 기회를 주셔서&lt;br /&gt;
5월 Meetup 의 마지막 순서에 &#39;Tidyverse before &amp;amp; after&#39; 의 제목을 가진 발표세션을 할 예정이다.&lt;/p&gt;
&lt;p&gt;블로깅이 너무 뜸해졌는데, 이 세션에서 &lt;a href=&quot;https://github.com/lovetoken/Tidyverse-before-after&quot;&gt;하고싶은 이야기 및 경험담을 정리&lt;/a&gt;하여 발표 한 후&lt;br /&gt;
요기에도 글을 정리해 볼 계획이다. (블로깅을 하기위한 좋은 재료를 찾았다...)&lt;/p&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/Tidyverse_before_and_after.png&quot;&gt;
&lt;/center&gt;
</description>
        <pubDate>Sat, 11 May 2019 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2019/05/11/tidyverse_before_after.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2019/05/11/tidyverse_before_after.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>R에서 dplyr 0.8.0 업데이트에 따른 요인별 집계의 신규 함수 중 group_map() 함수 활용예제 </title>
        <description>&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;발렌타인 데이 무렵 즈음 dplyr 패키지가 0.8.0 version 으로 업데이트 되면서 요인 별 집계(group by)의 편의성이 더 증대 되었다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tidyverse.org/articles/2018/12/dplyr-0-8-0-release-candidate/&quot;&gt;Tidyverse 에서 올라온 dplyr 0.8.0 버전 릴리즈에 대한 소개글&lt;/a&gt;에 신규 함수들에 대한 튜토리얼도 간략히 제시가 되어 있었는데&lt;br /&gt;
따라하다 보니 더더욱 편해진 느낌을 받았다.&lt;/p&gt;
&lt;p&gt;Grouping 의 메이저한 변화는 아래의 신규함수 이었으며&lt;br /&gt;
실험적으로 도입 및 관리해보는 함수라고 라벨링되어 있었다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;group_nest()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;group_split()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;group_cols()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;group_trim()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;group_map()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;group_walk()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 중 다살펴보진 못했고 &lt;code&gt;group_map()&lt;/code&gt; 의 활용예제를 생각해 보는 시간으로 글을 적어보았다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;group_nest-group_split&quot;&gt;&lt;code&gt;group_nest()&lt;/code&gt;, &lt;code&gt;group_split()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;group_map()&lt;/code&gt; 활용예제를 적기 전에 이 두개 신규함수는 그래도 언급해보고 싶었다.&lt;/p&gt;
&lt;p&gt;요인별 데이터를 묶어서 관리할 수 있는 &lt;code&gt;group_nest()&lt;/code&gt;&lt;br /&gt;
요인별로 데이터를 나누어서 볼 수 있는 &lt;code&gt;group_split()&lt;/code&gt; 의 새로운 함수가 요인별 현황을 간단히 보여주는데 쓰임이 좋을 거라 기대되었다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;co&quot;&gt;# group_nest() 를 통해 요인별로 묶기&lt;/span&gt;
mtcars %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;group_nest&lt;/span&gt;(cyl)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 3 x 2
##     cyl data              
##   &amp;lt;dbl&amp;gt; &amp;lt;list&amp;gt;            
## 1     4 &amp;lt;tibble [11 x 10]&amp;gt;
## 2     6 &amp;lt;tibble [7 x 10]&amp;gt; 
## 3     8 &amp;lt;tibble [14 x 10]&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;co&quot;&gt;# group_split() 를 통해 요인별 나누어서 데이터 보기&lt;/span&gt;
mtcars %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;group_split&lt;/span&gt;(cyl)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [[1]]
## # A tibble: 11 x 11
##      mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
##    &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
##  1  22.8     4 108      93  3.85  2.32  18.6     1     1     4     1
##  2  24.4     4 147.     62  3.69  3.19  20       1     0     4     2
##  3  22.8     4 141.     95  3.92  3.15  22.9     1     0     4     2
##  4  32.4     4  78.7    66  4.08  2.2   19.5     1     1     4     1
##  5  30.4     4  75.7    52  4.93  1.62  18.5     1     1     4     2
##  6  33.9     4  71.1    65  4.22  1.84  19.9     1     1     4     1
##  7  21.5     4 120.     97  3.7   2.46  20.0     1     0     3     1
##  8  27.3     4  79      66  4.08  1.94  18.9     1     1     4     1
##  9  26       4 120.     91  4.43  2.14  16.7     0     1     5     2
## 10  30.4     4  95.1   113  3.77  1.51  16.9     1     1     5     2
## 11  21.4     4 121     109  4.11  2.78  18.6     1     1     4     2
## 
## [[2]]
## # A tibble: 7 x 11
##     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
##   &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
## 1  21       6  160    110  3.9   2.62  16.5     0     1     4     4
## 2  21       6  160    110  3.9   2.88  17.0     0     1     4     4
## 3  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1
## 4  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1
## 5  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4
## 6  17.8     6  168.   123  3.92  3.44  18.9     1     0     4     4
## 7  19.7     6  145    175  3.62  2.77  15.5     0     1     5     6
## 
## [[3]]
## # A tibble: 14 x 11
##      mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
##    &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
##  1  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2
##  2  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4
##  3  16.4     8  276.   180  3.07  4.07  17.4     0     0     3     3
##  4  17.3     8  276.   180  3.07  3.73  17.6     0     0     3     3
##  5  15.2     8  276.   180  3.07  3.78  18       0     0     3     3
##  6  10.4     8  472    205  2.93  5.25  18.0     0     0     3     4
##  7  10.4     8  460    215  3     5.42  17.8     0     0     3     4
##  8  14.7     8  440    230  3.23  5.34  17.4     0     0     3     4
##  9  15.5     8  318    150  2.76  3.52  16.9     0     0     3     2
## 10  15.2     8  304    150  3.15  3.44  17.3     0     0     3     2
## 11  13.3     8  350    245  3.73  3.84  15.4     0     0     3     4
## 12  19.2     8  400    175  3.08  3.84  17.0     0     0     3     2
## 13  15.8     8  351    264  4.22  3.17  14.5     0     1     5     4
## 14  15       8  301    335  3.54  3.57  14.6     0     1     5     8&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;반환되는 결과가 list 이어서 &lt;code&gt;lapply()&lt;/code&gt; 와의 호환이 부드러워 질 수 있을 것 같아 개인적으로는 환영했다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;group_map&quot;&gt;&lt;code&gt;group_map()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;dplyr 0.8.0 업데이트 변화의 가장 큰 내용이지 않을까 싶다.&lt;br /&gt;
요인별 세부적인 연산을 적용시킬 수 있는 &lt;code&gt;group_map()&lt;/code&gt; 함수&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;가 특히 가장 눈에 띄었다.&lt;br /&gt;
purrr 패키지의 함수형 프로그래밍을 녹인 느낌이 강했는데, 개인적으로 이 함수를 잘 활용해 보고자 마음먹었다.&lt;/p&gt;
&lt;p&gt;이전에는 요인별 복잡한 알고리즘 연산을 수행하려 할 때는&lt;br /&gt;
tidyr package 의 &lt;code&gt;nest()&lt;/code&gt; 함수&lt;a href=&quot;#fn2&quot; class=&quot;footnoteRef&quot; id=&quot;fnref2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;를 통해 요인 별 데이터들을 묶은 후 list object 로 만든 다음 &lt;code&gt;lapply()&lt;/code&gt; 함수단에서 복잡한 연산을 넘기는 방식의 그룹별 연산을 애용했었다.&lt;/p&gt;
&lt;p&gt;예를 들면 이렇다. 아래 예제는 &lt;code&gt;caret::train()&lt;/code&gt; 함수를 이용해 요인별로 &lt;code&gt;mpg&lt;/code&gt; 필드값을 설명하는 Random Forest 알고리즘의 머신러닝 모델 학습을 독립적으로 수행 후 요인별 각기 다른 모델객체를 반환한 예제 코드이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;models1 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;mtcars %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;group_by&lt;/span&gt;(am) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;tidyr::&lt;span class=&quot;kw&quot;&gt;nest&lt;/span&gt;() %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;pull&lt;/span&gt;(data) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;# 사실 여기까지가 group_split(mtcars, am) 과 동일함&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;lapply&lt;/span&gt;(function(x) caret::&lt;span class=&quot;kw&quot;&gt;train&lt;/span&gt;(mpg ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;., &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; x, &lt;span class=&quot;dt&quot;&gt;method =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;rf&amp;quot;&lt;/span&gt;))

models1&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [[1]]
## Random Forest 
## 
## 13 samples
##  9 predictor
## 
## No pre-processing
## Resampling: Bootstrapped (25 reps) 
## Summary of sample sizes: 13, 13, 13, 13, 13, 13, ... 
## Resampling results across tuning parameters:
## 
##   mtry  RMSE      Rsquared   MAE     
##   2     3.560203  0.7957677  3.121680
##   5     3.363679  0.8190277  2.869850
##   9     3.352473  0.8122625  2.830969
## 
## RMSE was used to select the optimal model using the smallest value.
## The final value used for the model was mtry = 9.
## 
## [[2]]
## Random Forest 
## 
## 19 samples
##  9 predictor
## 
## No pre-processing
## Resampling: Bootstrapped (25 reps) 
## Summary of sample sizes: 19, 19, 19, 19, 19, 19, ... 
## Resampling results across tuning parameters:
## 
##   mtry  RMSE      Rsquared   MAE     
##   2     2.105099  0.7708150  1.901827
##   5     2.159168  0.7585883  1.935482
##   9     2.218085  0.7358981  1.987309
## 
## RMSE was used to select the optimal model using the smallest value.
## The final value used for the model was mtry = 2.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;lapply 를 쓴 만큼 결과 반환물도 list 형태인데&lt;br /&gt;
요인 &lt;code&gt;am&lt;/code&gt; 이 2개 종류로써 2개 요인별 모델이 네이밍 되지 않은채로 나오는 단점이 있고&lt;br /&gt;
코드가 약간 번잡한 면이 있는 방법이다.(for 문도 생각해 보았지만 더 복잡해 질 것 같다)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;group_map()&lt;/code&gt; 을 사용하면 이 과정을 조금 더 직관적이고 간단한 코딩으로 수행할 수 있었다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;models2 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;mtcars %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;group_by&lt;/span&gt;(am) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;group_map&lt;/span&gt;( ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;tibble&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;train_object =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;list&lt;/span&gt;(caret::&lt;span class=&quot;kw&quot;&gt;train&lt;/span&gt;(mpg ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;., &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; .x, &lt;span class=&quot;dt&quot;&gt;method =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;rf&amp;quot;&lt;/span&gt;))))

models2&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 2 x 2
## # Groups:   am [2]
##      am train_object
##   &amp;lt;dbl&amp;gt; &amp;lt;list&amp;gt;      
## 1     0 &amp;lt;S3: train&amp;gt; 
## 2     1 &amp;lt;S3: train&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;group_map()&lt;/code&gt; 함수 는 요인별로 바인딩을 위해서 dataframe 형태로 결과가 반환되어야 하는 전제조건이 있다.&lt;br /&gt;
이를 위해 list 결과를 &lt;code&gt;tibble()&lt;/code&gt; 로 감싸주었다.&lt;br /&gt;
그리하여 2개의 모델을 요인별로 깔끔하게 보관된 모습을 보이고 있다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;am&lt;/code&gt; 요인이 &lt;code&gt;1&lt;/code&gt; 일때의 학습모델을 사용하고자 할 경우 아래처럼 뽑아서 쓰면 되겠다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;models2 %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;filter&lt;/span&gt;(am ==&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;pull&lt;/span&gt;(train_object)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [[1]]
## Random Forest 
## 
## 13 samples
##  9 predictor
## 
## No pre-processing
## Resampling: Bootstrapped (25 reps) 
## Summary of sample sizes: 13, 13, 13, 13, 13, 13, ... 
## Resampling results across tuning parameters:
## 
##   mtry  RMSE      Rsquared   MAE     
##   2     3.870267  0.8004452  3.335863
##   5     3.680017  0.8163241  3.111651
##   9     3.663791  0.8082755  3.094120
## 
## RMSE was used to select the optimal model using the smallest value.
## The final value used for the model was mtry = 9.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.tidyverse.org/articles/2019/02/dplyr-0-8-0/&quot;&gt;dplyr 0.8.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.tidyverse.org/articles/2018/12/dplyr-0-8-0-release-candidate/&quot;&gt;dplyr 0.8.0 release candidate&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;&lt;code&gt;group_walk()&lt;/code&gt; 도 비슷한 쓰임이다&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn2&quot;&gt;&lt;p&gt;지금의 dplyr 0.8.0 에선 &lt;code&gt;group_nest()&lt;/code&gt; 가 이 역할을 대신한다&lt;a href=&quot;#fnref2&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Sun, 24 Feb 2019 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2019/02/24/dplyr080.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2019/02/24/dplyr080.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>로컬상에서 Database를 간접경험해 보기 위한 sqlite DB를 R에서 만들어 보기</title>
        <description>&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;학창시절부터 실질적인 데이터를 접근하기 위해 SQL을 익히는 것은 중요하다는 이야기를 실무를 하시는 분들에게 공통적으로 들어왔었다.&lt;br /&gt;
데이터를 분석하기 위해서는 분석가가 분석범위로 설정한 데이터를 손에 쥐고 있어야 가능하고, 내 입맛에 맞게 손에 집기 위한 스킬이라는 것이기에 이 말을 매우매우 공감하였었다.&lt;br /&gt;
하지만 그 당시에 통계적인 학문 자체에 대해 집중적으로 공부하던 &#39;전공&#39;이라는 틀 안에서 노력을 했던 터라 데이터를 굳이 Database 에서 가저와야 할 정도의 필요성을 느낄만한 동기를 가질 수 없었던게 아니었나 회고해 본다.&lt;br /&gt;
DBMS(DataBases Management System) 안에 있는 데이터를 만나볼 기회는 큰 규모의 프로젝트나, 데이터를 소유하고 있는 회사에서 일을 해 보지 않는 이상 접하기 조차 어려웠던것 아닐까 싶다. (Excel과 같은 스프레드시트로 관리하는게 가장 대중적이고 효율적일테니까)&lt;br /&gt;
실제로 필자도 위의 생각을 가지고 노력을 했다고 생각했지만, 지금 돌이켜 보면 그 노력은 맹목적이었고&lt;br /&gt;
저 첫기회를 찾아 접하고 경험하기 까지 걸린 시간이 대학생 막학기 시절 때 이었으니 말이다.&lt;/p&gt;
&lt;p&gt;모순적이게도 직장을 얻고 관련분야 일을 하면서 SQL을 이용해야하는 참된 이유를 알게 되었고,&lt;br /&gt;
그 전까지 익히던 SQL이 목적없이 진도빼기 식으로 공부한 것 아닌가 느껴졌다.&lt;/p&gt;
&lt;p&gt;지금이라도 뒤늦었다 생각하고 목적성 있게 주체적으로 공부해 보기 위해 이런저런 시도들을 해 보고 있다.&lt;br /&gt;
그 시도중 학창시절당시 DB 를 경험해 보지 못했던 나의 사각지대 환경에 대해서 조금 더 생각들이 많아졌고&lt;br /&gt;
서버같은 것 없이 로컬상에서도 손쉽게 DB 환경을 구축하여 SQL 을 직접 이용해 볼 수 있는 가벼운 환경을 만들 수 있다면 좋지 않을까 했고, 이 생각을 후배 등에게 전파하기도 용이하겠다는 생각을 덤으로 하면서&lt;br /&gt;
위의 제목을 주제로한 글을 작성하게 되었다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;sqlite&quot;&gt;&lt;a href=&quot;https://www.sqlite.org/about.html&quot;&gt;SQLite&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;다양한 종류의 데이터베이스들이 있는데&lt;br /&gt;
관리하여야 할 데이터의 스케일과 특성에 따라 특화되고 강점들이 각기 다른 DB 들이 생기며 현존하는 것 같다.&lt;br /&gt;
그 중 본 글의 특성(시작하기 쉽고 가벼운)에 맞는 SQLite 이란 DB를 소개하고자 한다.&lt;/p&gt;
&lt;p&gt;사람들이 컴퓨터를 사용할 때 가장 많이 보고 접하는 것 중 하나가 파일(File)인데&lt;br /&gt;
이 파일은 컴퓨터에서 정보를 담는 그릇의 가장 대중적인 단위라고 생각한다.&lt;br /&gt;
때문에 가장 직관적이고 이해하기 쉬운 단위라고 본다.&lt;br /&gt;
SQLite 라는 DB 는 눈에 보이는 &lt;strong&gt;파일형태&lt;/strong&gt;로 관리가 되기 때문에 거부감이 덜할 것이다.&lt;br /&gt;
필자는 약 1년전 &lt;a href=&quot;https://lovetoken.gitbooks.io/r-dev-team-open-seminar/content/&quot;&gt;rdevteam&lt;/a&gt; 활동을 하면서 SQLite 를 공유받게 되었고 그때 처음 알게되었다.&lt;/p&gt;
&lt;p&gt;그리하여&lt;br /&gt;
본 글에서는 SQLite 라는 파일DB 를 &lt;code&gt;RSQLite&lt;/code&gt; 패키지를 이용해 만들어 보는 것을 주제로 한다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;rsqlite-package-install&quot;&gt;&lt;code&gt;RSQLite&lt;/code&gt; package install&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;RSQLite&lt;/code&gt; 패키지는 R 에서 SQLite 인터페이스를 제공해주는 패키지이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;install.packages&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;RSQLite&amp;quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(RSQLite)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위의 코드를 통해 패키지를 설치하고 로드한다.&lt;br /&gt;
또한 R에서 DB 와의 인터페이스 함수를 제공하는 DBI 패키지도 로드한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(DBI)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;sqlite-가지고-놀아보기&quot;&gt;SQLite 가지고 놀아보기&lt;/h2&gt;
&lt;p&gt;DB 를 만들기위한 놀이터를 만들것이다. 현 워킹디렉토리에 &lt;code&gt;data&lt;/code&gt; 디렉토리를 만든다.&lt;br /&gt;
R에서 폴더를 만들수도 있는데 아래 코드를 실행하면 워킹디렉토리를 기준으로 &lt;code&gt;data&lt;/code&gt; 폴더를 생성시킨다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;dir.create&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;data&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;그다음 아래 코드를 실행하게 되면 방금만든 &lt;code&gt;data&lt;/code&gt; 폴더 안에 &lt;code&gt;SQLiteDB.sqlite&lt;/code&gt; 라는 파일이 생성될 것이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;con &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;dbConnect&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;SQLite&lt;/span&gt;(), &lt;span class=&quot;st&quot;&gt;&amp;quot;data/SQLiteDB.sqlite&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이 파일이 파일 DB 이고 이 파일에 연결정보는 &lt;code&gt;con&lt;/code&gt; 으로 관리된다.&lt;br /&gt;
&lt;code&gt;con&lt;/code&gt; 을 명시하여 데이터테이블을 생성시키고, 삭제하는 실습을 곧 하게 될 것인데&lt;br /&gt;
그렇게 되면 모두 커넥션이 맺어진 &lt;code&gt;data/SQLiteDB.sqlite&lt;/code&gt; 파일에 적용된다는점을 미리 말해 둔다.&lt;/p&gt;
&lt;h3 id=&quot;테이블-생성하기&quot;&gt;테이블 생성하기&lt;/h3&gt;
&lt;p&gt;가지고 놀아볼 데이터를 R에서 생성시켜보자 정말 별거 아닌 데이터지만 쓸데없이 크게 (&lt;code&gt;n = 100000&lt;/code&gt;) 만들어보는 코드이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(stringi)
n =&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;100000&lt;/span&gt;
data &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;data.frame&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;id =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;stri_rand_strings&lt;/span&gt;(n, &lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt;), &lt;span class=&quot;dt&quot;&gt;col1 =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;rnorm&lt;/span&gt;(n), &lt;span class=&quot;dt&quot;&gt;col2 =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;runif&lt;/span&gt;(n)) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;tbl_df
data&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 100,000 x 3
##    id             col1  col2
##    &amp;lt;chr&amp;gt;         &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
##  1 rIE8F9sSaYTg -0.584 0.794
##  2 VdURMrRBzJnK  1.76  0.444
##  3 XPalm4OzhTqg  0.680 0.543
##  4 rDfHVMnc2UxG -0.262 0.804
##  5 xuRKywMF02vA  0.323 0.938
##  6 GDsDVNFjHApd -0.818 0.508
##  7 1zuKONsUMLTw -0.737 0.480
##  8 VlCzuSv2zIwv  0.320 0.157
##  9 X4H0KoPkb3Ou  0.821 0.199
## 10 GbDJhiPZpHJC -0.337 0.456
## # ... with 99,990 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위의 데이터는 지금 R session 에 있는 장난감 데이터이다.&lt;br /&gt;
이 장난감이 R 이라는 놀이터 공간에만 있을 뿐이다.&lt;br /&gt;
우리는 이 장난감을 그대로 SQLite 데이터베이스 라는 놀이터에도 복사해 장난감을 납두고 싶다고 하자.&lt;br /&gt;
데이터베이스 라는 놀이터는 보통 Database 혹은 Schema 를 상위 단위로 하고, 그 하위 개념을 Table 로 둔다.&lt;br /&gt;
우리가 R 에서 만든 장난감은 data.frame 형식인데 이것이 Table 과 매우 유사한 형태로 호환이 가능하므로 결국 데이터베이스 하위개념인 Table 안에 얼마든지 복사가 가능하다.&lt;br /&gt;
SQLite DB안에 테이블 단위로 이 데이터를 저장하고 싶은 경우&lt;br /&gt;
DBI 패키지에서 제공하는 &lt;code&gt;dbWriteTable()&lt;/code&gt; 함수를 이용해 연결정보가 담긴 &lt;code&gt;con&lt;/code&gt; 을 안에 명시해주고&lt;br /&gt;
저장하고 싶은 대상과 명칭을 입력하면 된다.&lt;/p&gt;
&lt;p&gt;즉 아래 코드를 실행하면 된다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;dbWriteTable&lt;/span&gt;(con, &lt;span class=&quot;st&quot;&gt;&amp;quot;data&amp;quot;&lt;/span&gt;, data)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이것이 실행되면 현 상황은 SQLite DB 안에 &lt;code&gt;data&lt;/code&gt; 라는 테이블이 생성된 상태이다.&lt;/p&gt;
&lt;p&gt;Database 에는 다수의 테이블을 입력할 수 있다.&lt;br /&gt;
R의 빌트인 데이터 &lt;code&gt;cars&lt;/code&gt; 와 &lt;code&gt;iris&lt;/code&gt; 를 더 저장해보자.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;dbWriteTable&lt;/span&gt;(con, &lt;span class=&quot;st&quot;&gt;&amp;quot;cars&amp;quot;&lt;/span&gt;, cars)
&lt;span class=&quot;kw&quot;&gt;dbWriteTable&lt;/span&gt;(con, &lt;span class=&quot;st&quot;&gt;&amp;quot;iris&amp;quot;&lt;/span&gt;, iris)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;저장이 정말 잘 되었는지 확인해 보고싶은데&lt;br /&gt;
그전에 테이블 하나 삭제만 더 해보고 그다음에 확인해 보겠다.&lt;/p&gt;
&lt;h3 id=&quot;테이블-삭제하기&quot;&gt;테이블 삭제하기&lt;/h3&gt;
&lt;p&gt;마지막에 실행하여 추가한 &lt;code&gt;iris&lt;/code&gt; 데이터를 삭제해보자&lt;br /&gt;
&lt;code&gt;dbRemoveTable()&lt;/code&gt; 함수가 테이블 삭제를 해 준다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;dbRemoveTable&lt;/span&gt;(con, &lt;span class=&quot;st&quot;&gt;&amp;quot;iris&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;sql-구문-실행하여-데이터-읽어들이기&quot;&gt;SQL 구문 실행하여 데이터 읽어들이기&lt;/h3&gt;
&lt;p&gt;위의 실습으로 &lt;code&gt;data&lt;/code&gt;, &lt;code&gt;cars&lt;/code&gt;, &lt;code&gt;iris&lt;/code&gt; 3개의 테이블이 저장되었다가 &lt;code&gt;iris&lt;/code&gt; 테이블은 삭제되었을 것이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;dbListTables&lt;/span&gt;(con)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;cars&amp;quot; &amp;quot;data&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그렇다 이처럼 두개테이블만이 확인된다.&lt;/p&gt;
&lt;p&gt;각 테이블의 헤더 샘플을 각각 SQL 구문을 통해 읽어들여 보겠다.&lt;br /&gt;
SQL 의 &lt;code&gt;LIMIT&lt;/code&gt; 을 통해 10개만 확인해 보았다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;dbGetQuery&lt;/span&gt;(con, &lt;span class=&quot;st&quot;&gt;&amp;quot;SELECT * FROM data LIMIT 10;&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##              id        col1      col2
## 1  1jnj6MuXod5e  0.66293612 0.7739772
## 2  Vlm62uuOkaSw -0.59463920 0.4615983
## 3  aYnQ6gTp3PiU  0.02231377 0.5409450
## 4  Waf4r9O3ZFwT -1.27770275 0.6610312
## 5  vpHSpkLLGhaZ -0.05661095 0.6884008
## 6  RX0hmr2dsIu5 -0.02835238 0.9461622
## 7  vS6zAovPydaw -0.38382133 0.3351209
## 8  ltAX54IAsIq9  1.69635626 0.9901561
## 9  3N1AUeZb4JNa  0.37225877 0.9484985
## 10 RBnWtY5PKoHG  0.40751041 0.8362601&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;dbGetQuery&lt;/span&gt;(con, &lt;span class=&quot;st&quot;&gt;&amp;quot;SELECT * FROM cars LIMIT 10;&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##    speed dist
## 1      4    2
## 2      4   10
## 3      7    4
## 4      7   22
## 5      8   16
## 6      9   10
## 7     10   18
## 8     10   26
## 9     10   34
## 10    11   17&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;iris 테이블을 확인해 볼 경우&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;dbGetQuery&lt;/span&gt;(con, &lt;span class=&quot;st&quot;&gt;&amp;quot;SELECT * FROM iris LIMIT 10;&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Error in result_create(conn@ptr, statement) : no such table: iris&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;삭제가 되었기 때문에 테이블을 찾을 수 없다는 에러가 확인된다.&lt;/p&gt;
&lt;p&gt;실감을 위해 지금까지 실습한 R 환경에서 잠깐 벗어나&lt;br /&gt;
데이터베이스 관리도구등으로 &lt;code&gt;data/SQLiteDB.sqlite&lt;/code&gt; 에 연결하여 확인하면 이런모습이다. (&lt;a href=&quot;https://dbeaver.io/&quot;&gt;DBeaver&lt;/a&gt; 이라는 SQL 클라이언트를 예제로 한 사진이다)&lt;/p&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/RSQLite1.png&quot;&gt;
&lt;/center&gt;
&lt;p&gt;이처럼 R상에서 SQL 구문을 실행해 볼 수 도 있고&lt;br /&gt;
위 사진처럼 SQL 클라이언트에서도 (당연히)얼마든지 SQL &#39;질의&#39;를 통해 원하는 데이터를 &#39;답변&#39; 받을 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;덧붙여&quot;&gt;덧붙여&lt;/h2&gt;
&lt;p&gt;DBI package 는 R상에서 DB 간 연결을 돕는 표준화된 함수를 제공한다.&lt;br /&gt;
그리고 이 틀 안에서 DB의 종류별로 connection 방법이 각기 조금씩 다른부분만 커스터마이징 하는 방식이다.&lt;br /&gt;
본 글의 예제 DB 는 SQLite 이었다.&lt;br /&gt;
SQLite 간 연결은 &amp;quot;RSQLite&amp;quot; package 의 도움을 받고 연결 후 연결객체&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;를 사용한 DB 간 통신은 모두 DBI 표준함수를 이용하는 방식이다.&lt;br /&gt;
위의 실습에서 사용했던 &lt;code&gt;dbWriteTable()&lt;/code&gt;, &lt;code&gt;dbRemoveTable()&lt;/code&gt;, &lt;code&gt;dbListTables()&lt;/code&gt;, &lt;code&gt;dbGetQuery()&lt;/code&gt; 함수들 모두 DBI 패키지 함수들이다.&lt;/p&gt;
&lt;p&gt;만약 SQLite 가 아닌 다른 DB 이면 그 DB 에 맞는 패키지가 보통 존재한다.&lt;br /&gt;
예를 들면&lt;br /&gt;
Impala 로 연결해야할 땐 &amp;quot;RImpala&amp;quot; 라는 패키지를,&lt;br /&gt;
Presto DB 에 연결해야 할 땐 &amp;quot;RPresto&amp;quot; 패키지를,&lt;br /&gt;
MySQL 과 연결해야할 땐 &amp;quot;RMySQL&amp;quot; 패키지를 이용했었다.&lt;br /&gt;
odbc 혹은 jdbc 규격으로 연결해야할 경우 각각 &amp;quot;RODBC&amp;quot;, &amp;quot;RJDBC&amp;quot; 의 패키지를 이용해 각기 다른 방식으로 커넥션을 맺고, 그 커넥션 정보가 담긴 연결객체를 DBI 패키지와 조합하여 사용하는 방식 또한 마찬가지이다.&lt;/p&gt;
&lt;p&gt;이를 볼 때 DBI package 는 여러가지 데이터베이스 메니지먼트 시스템(DBMS)들에 대해서 표준화 되고 동일기능을 가진 함수로 실행되기 위한 방향성이 아주 오래전 부터 있던 패키지인 것 같다.&lt;/p&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;지금 실습의 경우 &lt;code&gt;con&lt;/code&gt; 을 일컫는다&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Thu, 03 Jan 2019 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2019/01/03/RSQLite.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2019/01/03/RSQLite.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>dplyr 문법을 통한 전처리를 SQL 로의 스위칭</title>
        <description>&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;최근 회사를 이직하게 되었는데 이전과는 새로운 분석환경과 거대한 스케일에 놀라면서 개인적으로 다양한 문제들을 맞닥드리고 있다.&lt;br /&gt;
특히 가장 다른점은 데이터의 양(Volume)과 이를 관리하기 위해 조성된 조직, 인프라, 시스템 등이다.&lt;/p&gt;
&lt;p&gt;이전에는 데이터 인프라가 준비되있지 않은 상태에서&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; 작은 분석솔루션 PoC(Proof of Concept) 를 하거나, 의미있는 솔루션을 만들 수 있는 관점으로 분석을 기획된 틀에 맞추거나 근접하면서 진행하였다면,&lt;br /&gt;
지금은 기 확보된 해상도 높은 데이터를 &lt;strong&gt;적시성&lt;/strong&gt;있게 집계, 분석하는데 초점이 있다.&lt;br /&gt;
여기서 &lt;strong&gt;적시성&lt;/strong&gt;이란 표현을 하였는데 이전 환경과 가장 다르게 체감되는 다른점을 대표한 단어이다. 비교적 최근의 일어나는 현상들에 대해 관심이 많고, 과거에 비해 최근 적용한 이벤트의 효과가 어떠한 방식으로 나타나는지 모니터링 해야하는 도메인의 고유한 특성이 있기에&lt;br /&gt;
&#39;Due Date&#39; 라는 골든타임 안에 인사이트를 공급하는 일이 이전보다 매우 중요하게 느껴지고 있다.&lt;br /&gt;
즉 이렇게 따끈따끈한 데이터(방금 적재된 데이터)를 접근할 수 있는 권한과 환경은 처음이고, 이를 스피드 있게 파악하고 분석하는 것 또한 경험해 보지 못한 일이다.&lt;/p&gt;
&lt;p&gt;Database 단 안에서 따끈따끈한 데이터를 집약하여 인사이트를 확인하고 전달하는 가장 빠른 프로세스를 이용하기 위해&lt;br /&gt;
SQL(Structured Query Language)만을 이용해 1step 만으로 일을 처리하는 점 또한 내게 있어 많이 다른점이다.&lt;br /&gt;
이전에는 파일시스템을 데이터의 소스로 주로 이용했었기 때문에 R을 이용하는것이 비교적 유리했으며&lt;br /&gt;
DB 안의 데이터를 다루어야 하는 상황이 있을때도 &lt;a href=&quot;https://cran.r-project.org/web/packages/dbplyr/vignettes/dbplyr.html&quot;&gt;dbplyr package&lt;/a&gt; 와 비교적 손쉽게 호환이 되는 MySQL 환경이 대부분 이었기 때문에 dplyr 문법을 이용해 집약 및 전처리를 했던 편이었다.&lt;/p&gt;
&lt;p&gt;서론이 길었다.&lt;br /&gt;
이러저러한 이유로 기존에 즐겨쓰던 dplyr 문법을 SQL 상에선 어떻게 구현해야 하는지 고민이 많아졌는데, 이를 위해 정리한 글이기도 하다.&lt;br /&gt;
앞으로 아래의 글은&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;특정주제&lt;/li&gt;
&lt;li&gt;dplyr 문법&lt;/li&gt;
&lt;li&gt;위 dplyr 문법과 동일한 논리의 SQL 문&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;으로 구성하여 정리한다. 또한 본글을 읽기 전에 아래와 같은 사항을 미리 언급한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dplyr 문법을 MSSQL 을 기준으로 스위칭 한 것에 한하여 정리하였다&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;dplyr 의 pipeline 문법이나, 기본적인 집계 매커니즘을 설명하지 않았다. 즉 dplyr 문법에서의 기초사항에 대해 어느정도 알고 있다는 전제하에 글을 정리했다&lt;/li&gt;
&lt;li&gt;SQL convention 은 최대한 &lt;a href=&quot;https://www.sqlstyle.guide/&quot;&gt;여기&lt;/a&gt;를 따르려 노력했다&lt;/li&gt;
&lt;li&gt;대표예제로 R의 빌트인 예제인 &lt;code&gt;mtcars&lt;/code&gt; 데이터셋을 이용했다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MSSQL 에서는 &lt;code&gt;mtcars&lt;/code&gt; 데이터셋 테이블이 없기 때문에 미리 만들어 놓아야 했다. 아래처럼 준비 하였다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;co&quot;&gt;# R session 에서 빌트인 예제 mtcars 를 csv 파일로 외부로 빼낸다&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;write.csv&lt;/span&gt;(mtcars, &lt;span class=&quot;st&quot;&gt;&amp;quot;~/mtcars.csv&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode sql&quot;&gt;&lt;code class=&quot;sourceCode sql&quot;&gt;&lt;span class=&quot;co&quot;&gt;/* SQL session 에서 외부로 빼낸 mtcars.csv 파일을 insert 한다 */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;BULK&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;INSERT&lt;/span&gt;     [database_name].[table_name]
&lt;span class=&quot;kw&quot;&gt;FROM&lt;/span&gt;            &lt;span class=&quot;st&quot;&gt;&amp;#39;~/mtcars.csv&amp;#39;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;WITH&lt;/span&gt;            (
    FIRSTROW = &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,
    FIELDTERMINATOR = &lt;span class=&quot;st&quot;&gt;&amp;#39;,&amp;#39;&lt;/span&gt;,
    ROWTERMINATOR = &lt;span class=&quot;st&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&amp;#39;&lt;/span&gt;,
    ERRORFILE = &lt;span class=&quot;st&quot;&gt;&amp;#39;~/mtcars_error_rows.csv&amp;#39;&lt;/span&gt;,
    TABLOCK
)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;단 &lt;code&gt;BULK INSERT&lt;/code&gt; 의 위 명령어를 실행시키기 위한 권한이 필요할 수 있다.&lt;br /&gt;
&lt;code&gt;BULK INSERT&lt;/code&gt; 는 MSSQL 에서만 된다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;다중컬럼에-대해-유일한-값-확인하기&quot;&gt;다중컬럼에 대해 유일한 값 확인하기&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;mtcars&lt;/code&gt; 데이터 셋에서 &lt;code&gt;gear&lt;/code&gt; 컬럼의 범주가 몇가지가 있는지를 확인하고 싶다면&lt;br /&gt;
&lt;code&gt;length(unique())&lt;/code&gt;, &lt;code&gt;dplyr::n_distinct()&lt;/code&gt; 등을 이용하여 아래처럼 확인이 가능하다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;length&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;unique&lt;/span&gt;(mtcars$gear))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] 3&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;n_distinct&lt;/span&gt;(mtcars$gear)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] 3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그런데 &lt;code&gt;gear&lt;/code&gt; 와 함께 &lt;code&gt;carb&lt;/code&gt; 컬럼도 같이 함께하여 유일한 범주가 몇개가 있는지를 확인하고 싶다면 어떻게 하여야 할까?&lt;br /&gt;
이때는 &lt;code&gt;length(unique())&lt;/code&gt;, &lt;code&gt;dplyr::n_distinct()&lt;/code&gt; 의 방법으론 어렵다.&lt;br /&gt;
굳이 쓰고자 한다면 &lt;code&gt;gear&lt;/code&gt; 와 &lt;code&gt;carb&lt;/code&gt; 를 결합하는 별도의 과정이 필요한데, 굳이 예를 들면 아래와 같다고나 할까.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;paste&lt;/span&gt;(mtcars$gear, mtcars$carb) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;n_distinct &lt;span class=&quot;co&quot;&gt;# 혹은 이 자리에 `length(unique(.))` 로 대치&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] 11&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;dplyr&quot;&gt;dplyr&lt;/h3&gt;
&lt;p&gt;이때 dplyr 에선 &lt;code&gt;group_by()&lt;/code&gt;, &lt;code&gt;distinct()&lt;/code&gt; 함수들이 유용한데&lt;br /&gt;
&lt;code&gt;group_by()&lt;/code&gt; 로 그룹핑을 하게되면 애초에 그룹핑 요소의 개수가 표시된다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;mtcars %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;group_by&lt;/span&gt;(gear, carb)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 32 x 11
## # Groups:   gear, carb [11]
##      mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
##  * &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
##  1  21       6  160    110  3.9   2.62  16.5     0     1     4     4
##  2  21       6  160    110  3.9   2.88  17.0     0     1     4     4
##  3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1
##  4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1
##  5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2
##  6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1
##  7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4
##  8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2
##  9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2
## 10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4
## # ... with 22 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;출력물의 두번째 라인을 보면 &lt;code&gt;# Groups:   gear, carb [11]&lt;/code&gt; 에서 대괄호 안의 수가 바로 그것이다.&lt;br /&gt;
이 카운트 수 11개에 대한 요인 조합들을 직접 반환 하고싶다면 &lt;code&gt;distinct()&lt;/code&gt; 쓰면 된다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;mtcars %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;distinct&lt;/span&gt;(gear, carb)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##    gear carb
## 1     4    4
## 2     4    1
## 3     3    1
## 4     3    2
## 5     3    4
## 6     4    2
## 7     3    3
## 8     5    2
## 9     5    4
## 10    5    6
## 11    5    8&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;sql&quot;&gt;SQL&lt;/h3&gt;
&lt;p&gt;SQL 에서&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;mtcars %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;distinct&lt;/span&gt;(gear, carb)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##    gear carb
## 1     4    4
## 2     4    1
## 3     3    1
## 4     3    2
## 5     3    4
## 6     4    2
## 7     3    3
## 8     5    2
## 9     5    4
## 10    5    6
## 11    5    8&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;와 같은 결과를 반환하는 Query 는 아래등이 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode sql&quot;&gt;&lt;code class=&quot;sourceCode sql&quot;&gt;&lt;span class=&quot;kw&quot;&gt;SELECT&lt;/span&gt;      &lt;span class=&quot;kw&quot;&gt;DISTINCT&lt;/span&gt; gear, carb
&lt;span class=&quot;kw&quot;&gt;FROM&lt;/span&gt;        mtcars;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode sql&quot;&gt;&lt;code class=&quot;sourceCode sql&quot;&gt;&lt;span class=&quot;kw&quot;&gt;SELECT&lt;/span&gt;      gear, carb
&lt;span class=&quot;kw&quot;&gt;FROM&lt;/span&gt;        mtcars
&lt;span class=&quot;kw&quot;&gt;GROUP&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;BY&lt;/span&gt;    gear, carb;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;샘플링&quot;&gt;샘플링&lt;/h2&gt;
&lt;p&gt;일부 샘플만 확인 혹은 추출하기 위해선 &lt;code&gt;sample_n()&lt;/code&gt;, &lt;code&gt;sample_frac()&lt;/code&gt; 등을 사용할 수 있다.&lt;br /&gt;
SQL 에선 어떻게 할 수 있을지 궁금했다.&lt;/p&gt;
&lt;h3 id=&quot;dplyr-1&quot;&gt;dplyr&lt;/h3&gt;
&lt;p&gt;dplyr 를 이용할 때 mtcars 에서 단 3건의 샘플만을 추출하고 싶을 경우&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;mtcars %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;sample_n&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##              mpg cyl  disp hp drat    wt  qsec vs am gear carb
## Fiat X1-9   27.3   4  79.0 66 4.08 1.935 18.90  1  1    4    1
## Honda Civic 30.4   4  75.7 52 4.93 1.615 18.52  1  1    4    2
## Merc 240D   24.4   4 146.7 62 3.69 3.190 20.00  1  0    4    2&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;sql-1&quot;&gt;SQL&lt;/h3&gt;
&lt;p&gt;SQL 에선 랜덤인덱스를 통한 정렬 및 3개의 행을 뽑는 과정을 모두 Query 를 통해 명시한다고 생각하면 된다.&lt;br /&gt;
이 과정들을 직접 명시해야하므로 다양한 케이스의 방법들이 존재할 수 있다고 생각했는데, &lt;code&gt;NEWID()&lt;/code&gt; 로 랜덤인덱스를 부여하여 샘플링 하는 아래의 방법을 선호하게 되었다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode sql&quot;&gt;&lt;code class=&quot;sourceCode sql&quot;&gt;&lt;span class=&quot;kw&quot;&gt;SELECT&lt;/span&gt;      TOP &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; *
&lt;span class=&quot;kw&quot;&gt;FROM&lt;/span&gt;        mtcars
&lt;span class=&quot;kw&quot;&gt;ORDER&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;BY&lt;/span&gt;    NEWID();&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;요인별-샘플-개수-확인&quot;&gt;요인별 샘플 개수 확인&lt;/h2&gt;
&lt;h3 id=&quot;dplyr-2&quot;&gt;dplyr&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;mtcars %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;group_by&lt;/span&gt;(cyl) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;count %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;arrange&lt;/span&gt;(n)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 3 x 2
## # Groups:   cyl [3]
##     cyl     n
##   &amp;lt;dbl&amp;gt; &amp;lt;int&amp;gt;
## 1     6     7
## 2     4    11
## 3     8    14&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;sql-2&quot;&gt;SQL&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode sql&quot;&gt;&lt;code class=&quot;sourceCode sql&quot;&gt;&lt;span class=&quot;kw&quot;&gt;SELECT&lt;/span&gt;      cyl, &lt;span class=&quot;fu&quot;&gt;COUNT&lt;/span&gt;(*) &lt;span class=&quot;kw&quot;&gt;AS&lt;/span&gt; n
&lt;span class=&quot;kw&quot;&gt;FROM&lt;/span&gt;        mtcars
&lt;span class=&quot;kw&quot;&gt;GROUP&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;BY&lt;/span&gt;    cyl
&lt;span class=&quot;kw&quot;&gt;ORDER&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;BY&lt;/span&gt;    n;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;요인별-특정값의-최상위-샘플-필터링&quot;&gt;요인별 특정값의 최상위 샘플 필터링&lt;/h2&gt;
&lt;h3 id=&quot;dplyr-3&quot;&gt;dplyr&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;mtcars %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;group_by&lt;/span&gt;(cyl) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;filter&lt;/span&gt;(mpg ==&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;max&lt;/span&gt;(mpg)) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;arrange&lt;/span&gt;(cyl)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 3 x 11
## # Groups:   cyl [3]
##     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
##   &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
## 1  33.9     4  71.1    65  4.22  1.84  19.9     1     1     4     1
## 2  21.4     6 258     110  3.08  3.22  19.4     1     0     3     1
## 3  19.2     8 400     175  3.08  3.84  17.0     0     0     3     2&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;sql-3&quot;&gt;SQL&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode sql&quot;&gt;&lt;code class=&quot;sourceCode sql&quot;&gt;&lt;span class=&quot;kw&quot;&gt;SELECT&lt;/span&gt;      t1.*
&lt;span class=&quot;kw&quot;&gt;FROM&lt;/span&gt;        ( 
    &lt;span class=&quot;kw&quot;&gt;SELECT&lt;/span&gt;  *, &lt;span class=&quot;fu&quot;&gt;ROW_NUMBER&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;OVER&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;PARTITION&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;BY&lt;/span&gt; cyl &lt;span class=&quot;kw&quot;&gt;ORDER&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;BY&lt;/span&gt; mpg &lt;span class=&quot;kw&quot;&gt;DESC&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;AS&lt;/span&gt; rnk
    &lt;span class=&quot;kw&quot;&gt;FROM&lt;/span&gt;    mtcars
) t1
&lt;span class=&quot;kw&quot;&gt;WHERE&lt;/span&gt;       rnk = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;ORDER&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;BY&lt;/span&gt;    cyl&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;ROW_NUMBER()&lt;/code&gt; 대신 &lt;code&gt;RANK()&lt;/code&gt; 를 사용해도 같은 결과를 반환한다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;두-필드의-문자열-붙인-파생필드-만들기&quot;&gt;두 필드의 문자열 붙인 파생필드 만들기&lt;/h2&gt;
&lt;h3 id=&quot;dplyr-4&quot;&gt;dplyr&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;mtcars %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt;(vs, am) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;mutate&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;new =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;paste0&lt;/span&gt;(vs, &lt;span class=&quot;st&quot;&gt;&amp;quot;+&amp;quot;&lt;/span&gt;, am))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##    vs am new
## 1   0  1 0+1
## 2   0  1 0+1
## 3   1  1 1+1
## 4   1  0 1+0
## 5   0  0 0+0
## 6   1  0 1+0
## 7   0  0 0+0
## 8   1  0 1+0
## 9   1  0 1+0
## 10  1  0 1+0
## 11  1  0 1+0
## 12  0  0 0+0
## 13  0  0 0+0
## 14  0  0 0+0
## 15  0  0 0+0
## 16  0  0 0+0
## 17  0  0 0+0
## 18  1  1 1+1
## 19  1  1 1+1
## 20  1  1 1+1
## 21  1  0 1+0
## 22  0  0 0+0
## 23  0  0 0+0
## 24  0  0 0+0
## 25  0  0 0+0
## 26  1  1 1+1
## 27  0  1 0+1
## 28  1  1 1+1
## 29  0  1 0+1
## 30  0  1 0+1
## 31  0  1 0+1
## 32  1  1 1+1&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;sql-4&quot;&gt;SQL&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode sql&quot;&gt;&lt;code class=&quot;sourceCode sql&quot;&gt;&lt;span class=&quot;kw&quot;&gt;SELECT&lt;/span&gt;      vs, am, vs || &lt;span class=&quot;st&quot;&gt;&amp;#39;+&amp;#39;&lt;/span&gt; || am &lt;span class=&quot;kw&quot;&gt;AS&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;FROM&lt;/span&gt;        mtcars&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;본 글은 계속해서 내용이 추가되고 보강될 예정이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;정확히 말하면 인프라가 우리의 것이 아닌 상황에서&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Sat, 24 Nov 2018 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2018/11/24/dplyrquery.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2018/11/24/dplyrquery.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>POSCO AI Chanllenge 과제 참여 연구노트</title>
        <description>&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;직원 동료의 이야기를 듣고 함께 참가하게 된 &lt;a href=&quot;https://posco-aichallenge.kr/&quot;&gt;POSCO AI Chanllenge&lt;/a&gt; 에 좋은 성적으로 입상을 하게 되어 본선에서 발표를 준비해야 하는 상황까지 오게 되었다.&lt;br /&gt;
참여하게 된 과제는 주어진 데이터를 기반으로 과거의 너울성 파도를 예측하는 과제로써, 3차 최종 결과 제출본 기준으로 2등을 하게 되었으며 상위 3팀이 본선을 진출하고 발표는 내일이다. 발표를 준비하는 겸, 지금까지 수행한 과제를 정리도 할겸 글을 정리해 보고자 한다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;과제의-목표&quot;&gt;과제의 목표&lt;/h2&gt;
&lt;p&gt;필자는 대회 설명회 때 참석하지 못하여 생생함이 덜 하지만&lt;br /&gt;
설명회의 이야기로는 너울성 파도를 사전에 예측하여 선박의 출항 여부에 대해 의사결정에 도움을 받고&lt;br /&gt;
이어서 경제적, 인명적 손실을 최소화하기 위함이라고 전해 들었다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/posco1.png&quot;&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;POSCO 사의 입장으로써 이전부터 고민이 많은 이슈라 생각이 들었고, 그로 인한 계기로 본 과제를 기획한 것으로 생각된다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;데이터-현황과-전처리-수행과정&quot;&gt;데이터 현황과 전처리 수행과정&lt;/h2&gt;
&lt;p&gt;공급받은 데이터는 포스코 본사에 있는 포항 항구 근처에서 수집한 파고, 및 해수온도, 풍향등의 데이터이며 수집 지점은 월포, 구룡포 두 지점에 대한 약 3년치 자료이다.&lt;br /&gt;
그리고 과거 3년에 너울이 발생했는지의 여부를 시간 단위로 판단할 수 있는 정답지 데이터 (Training dataset), 그리고 과제의 미션으로 예측을 해내야 하는 시점이 언제인지를 알려주는 시험지 데이터(Predict dataset)로 구성되어 있다고 볼 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 2,247 x 11
##      loc date       mean_temp max_temp min_temp mean_signi_wh mean_wh
##    &amp;lt;int&amp;gt; &amp;lt;date&amp;gt;         &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;         &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt;
##  1 22453 2014-01-01      13.7     13.8     13.6           0.6     0.4
##  2 22453 2014-01-02      14       14.3     13.6           0.7     0.5
##  3 22453 2014-01-03      14.4     14.9     14.1           0.6     0.4
##  4 22453 2014-01-04      14.5     14.8     13.9           1.3     0.8
##  5 22453 2014-01-05      14.4     14.6     14.3           1.5     0.9
##  6 22453 2014-01-06      14.1     14.3     14             1.1     0.7
##  7 22453 2014-01-07      13.9     14.3     13.7           0.7     0.4
##  8 22453 2014-01-08      13.8     14.1     13.4           0.4     0.3
##  9 22453 2014-01-09      13.8     14.3     13.2           1.4     0.8
## 10 22453 2014-01-10      13.5     13.9     13.1           1       0.6
## # ... with 2,237 more rows, and 4 more variables: max_signi_wh &amp;lt;dbl&amp;gt;,
## #   max_wh &amp;lt;dbl&amp;gt;, mean_cycle &amp;lt;dbl&amp;gt;, max_cycle &amp;lt;dbl&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;제공받은 항구별 수집 정보들의 rawdata 의 샘플&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1,231 x 5
##    date       swell start_time end_time testset
##    &amp;lt;date&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;time&amp;gt;     &amp;lt;time&amp;gt;     &amp;lt;int&amp;gt;
##  1 2014-01-04  NA   15:00      19:00          0
##  2 2014-01-04  NA   19:00      07:00          0
##  3 2014-01-05  NA   07:00      10:00          0
##  4 2014-01-05   3   10:00      13:00          0
##  5 2014-01-08  NA   10:00      19:00          0
##  6 2014-01-09   4.5 14:30      19:00          0
##  7 2014-01-09  12   19:00      07:00          0
##  8 2014-01-10   3   07:00      10:00          0
##  9 2014-01-10   2   10:00      13:00          0
## 10 2014-01-21   1.5 00:30      02:00          0
## # ... with 1,221 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;제공받은 정답지 데이터와 시험지 데이터의 rawdata 샘플&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;제공받은 데이터 외의 다른 데이터를 이용해도 된다는 주최측의 안내를 받고 자체적으로 추가 수집한 데이터도 있었으며&lt;br /&gt;
그 데이터는 포항 앞바다의 부이&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;로 부터 수집된 데이터이다.&lt;a href=&quot;#fn2&quot; class=&quot;footnoteRef&quot; id=&quot;fnref2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 8,541 x 14
##    location date  wind_speed wind_direction  GUST local_air_press~ humidity
##       &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt;      &amp;lt;dbl&amp;gt;          &amp;lt;int&amp;gt; &amp;lt;dbl&amp;gt;            &amp;lt;dbl&amp;gt;    &amp;lt;int&amp;gt;
##  1    22106 2014~        8.2            259  11.1            1008.       44
##  2    22106 2014~       10.6            287  15.1            1009.       43
##  3    22106 2014~       11.7            287  14.9            1009.       42
##  4    22106 2014~       11.5            302  16.2            1010.       46
##  5    22106 2014~       11.8            284  16.4            1010.       50
##  6    22106 2014~        9.1            294  12.4            1010.       48
##  7    22106 2014~        7.3            293  11.7            1012.       43
##  8    22106 2014~        6.4            298   8.5            1012.       37
##  9    22106 2014~        5              296   8.1            1013.       35
## 10    22106 2014~        6.3            270   9.5            1014.       35
## # ... with 8,531 more rows, and 7 more variables: temperature &amp;lt;dbl&amp;gt;,
## #   water_temperature &amp;lt;dbl&amp;gt;, max_wave_height &amp;lt;dbl&amp;gt;,
## #   mean_wave_height &amp;lt;dbl&amp;gt;, avg_wave_height &amp;lt;dbl&amp;gt;, wave_accurance &amp;lt;dbl&amp;gt;,
## #   wave_direction &amp;lt;int&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;추가로 수집한 부이데이터의 rawdata 샘플&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이러한 데이터들을 충분히 EDA 한 후 머신러닝이나 딥러닝의 프레임워크 툴들이 학습하기 용이하도록 학습데이터 마트로 만들기 위한 단계를 거쳤다.&lt;br /&gt;
너울성 파도의 여부를 &lt;code&gt;swell&lt;/code&gt; 이란 필드명으로 각 시간별 상황데이터(파고, 풍향, 풍속, 수온 등등의 설명변수집합)에 맵핑하는 전처리를 수행하였다.&lt;br /&gt;
그 결과는 아래와 같다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6,909 x 15
##    date   time swell wind_speed wind_direction  GUST air_pressure humidity
##    &amp;lt;chr&amp;gt; &amp;lt;int&amp;gt; &amp;lt;int&amp;gt;      &amp;lt;dbl&amp;gt;          &amp;lt;int&amp;gt; &amp;lt;dbl&amp;gt;        &amp;lt;dbl&amp;gt;    &amp;lt;int&amp;gt;
##  1 2014~     0     1       11              302  14          1026.       47
##  2 2014~     1     1       11.1            315  16.1        1027.       45
##  3 2014~    10     1        9.9            320  14.1        1030.       54
##  4 2014~    11     1        9.8            306  13          1030.       54
##  5 2014~    12     1        8.7            324  13.6        1030        49
##  6 2014~     2     1       11.7            314  15.4        1027.       46
##  7 2014~     3     1       12.4            324  16.8        1027.       49
##  8 2014~     4     1       12.5            320  17.8        1028.       45
##  9 2014~     5     1       13.7            311  17.5        1029.       49
## 10 2014~     6     1       14.2            320  17.5        1029.       50
## # ... with 6,899 more rows, and 7 more variables: temperature &amp;lt;dbl&amp;gt;,
## #   water_temperature &amp;lt;dbl&amp;gt;, max_wave_height &amp;lt;dbl&amp;gt;,
## #   mean_wave_height &amp;lt;dbl&amp;gt;, avg_wave_height &amp;lt;dbl&amp;gt;, wave_accurance &amp;lt;dbl&amp;gt;,
## #   wave_direction &amp;lt;int&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;정답지가 존재하는 시점을 &lt;code&gt;date&lt;/code&gt;, &lt;code&gt;time&lt;/code&gt; 두 필드로 시점의 정보를 부여하고&lt;br /&gt;
그 시점의 너울성 파도 여부를 구분하는 &lt;code&gt;swell&lt;/code&gt; 을 맵핑하였으며 (너울성 파도가 일어난 경우 1, 그렇지 않은경우 0)&lt;br /&gt;
EDA 를 통해 선별한 12개의 설명변수&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;wind_speed&lt;/code&gt; : 풍속&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wind_direction&lt;/code&gt; : 풍향&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GUST&lt;/code&gt; : 돌풍의 정도&lt;/li&gt;
&lt;li&gt;&lt;code&gt;air_pressure&lt;/code&gt; : 기압&lt;/li&gt;
&lt;li&gt;&lt;code&gt;humidity&lt;/code&gt; : 주변습도&lt;/li&gt;
&lt;li&gt;&lt;code&gt;temperature&lt;/code&gt; : 주변온도&lt;/li&gt;
&lt;li&gt;&lt;code&gt;water_temperature&lt;/code&gt; : 수온&lt;/li&gt;
&lt;li&gt;&lt;code&gt;max_wave_height&lt;/code&gt; : 파고최대높이&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mean_wave_height&lt;/code&gt; : 파고평균높이&lt;/li&gt;
&lt;li&gt;&lt;code&gt;avg_wave_height&lt;/code&gt; : 파고유의높이&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wave_accurance&lt;/code&gt; : 파고주기&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wave_direction&lt;/code&gt; : 파도방향&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;를 같이 맵핑하였다.&lt;/p&gt;
&lt;p&gt;참고로 결측값에 대한 이슈도 있었는데&lt;br /&gt;
맵핑과정에서 그 시간시점에 해당 하는 데이터가 존재하지 않아 결측이 일어나는 경우가 바로 그것이었다.&lt;br /&gt;
결측행을 제외하는 것은 데이터의 손실이 너무 크다고 판단하였고 따라서 결측을 대치하는 방법을 고려했다.&lt;br /&gt;
대부분 LOCF(Last Observation Carried Forward) 방법으로 가장 최근값을 상속시키는 결측대치법을 이용하였고, LOCF 결측대치가 타당하지 않다고 판단되는 풍속(&lt;code&gt;wind_direction&lt;/code&gt;)의 경우 중앙값 대치를 고려하여 적용했다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/LOCF.png&quot; width=&quot;70%&quot;&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;LOCF(Last Observation Carried Forward) 를 통해 결측이 대치되는 방법에 대한 그림&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;너울성-파도-예측-모형-구현&quot;&gt;너울성 파도 예측 모형 구현&lt;/h2&gt;
&lt;p&gt;본 과제의 명칭에 걸맞게 AI 기술을 이용하여 너울성 파도를 예측하고자 예측 모형을 구현하고 Validation set 을 통해 모형을 평가하였다.&lt;br /&gt;
머신러닝 기법과 그중에서도 딥러닝 기법들을 다양하게 테스트 해보고 예측성능이 높게 평가된 것을 선별하여 1,2,3차에 걸쳐 제출하게 되었다.&lt;/p&gt;
&lt;p&gt;1,2,3차 때는 각 차수별로 대략 2주간의 시간이 주어졌다고 볼 수 있는데&lt;br /&gt;
각 차수별 아래와 같은 목표로 진행하였다.&lt;/p&gt;
&lt;p&gt;1차때는 딥러닝 모델을 구현하기 전 손쉽게 적용해 볼 수 있는 전통적인 머신러닝 알고리즘들을 이용하여 Warming up 을 해보는 단계로 계획하여 테스트 해 보았다.&lt;/p&gt;
&lt;p&gt;2차때는 1차때 선별된 머신러닝 알고리즘의 모형보다 예측성능이 더 높은 딥러닝 기반의 모형을 구현하는 것을 목표로 잡고 딥러닝 모형을 구현하였다.&lt;/p&gt;
&lt;p&gt;3차때는 역시 2차때 선별된 딥러닝 알고리즘보다 더 높은 예측성능을 보이는 모델을 찾기 위해 더 다른 관점의 고민들을 해보는 기간으로 잡았다.&lt;/p&gt;
&lt;p&gt;그 결과&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1차 : Weighted Subspace Random Forest 알고리즘 모형&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;2차 : Artificial Neural Network(ANN) 모형&lt;/li&gt;
&lt;li&gt;3차 : Flexible Discriminant Analysis(FDA) 모형&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3개의 모형을 구현하였고, 이를 통한 예측값을 제출하게 되었다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;모형-평가&quot;&gt;모형 평가&lt;/h2&gt;
&lt;p&gt;모형의 예측성능을 평가하기 전&lt;br /&gt;
무엇을 객관적인 목표로 잡고 각 3개의 모형이 선별되었는지 선발 기준에 대한 설명을 사전에 할 필요가 있을 것 같다.&lt;/p&gt;
&lt;p&gt;본 과제는 Binary Classification 문제이고, 특히 너울성 파도가 일어난 이벤트의 당시상황이 중요하므로 &amp;quot;너울성파도가 일어난&amp;quot; 시점에 대해서, 모형이 &amp;quot;너울성 파도가 일어남&amp;quot; 이라고 예측하는 것이 더 중요했다.&lt;br /&gt;
더 중요한 이유는 너울성 파도는 드물게 일어나며, 평시 상황은 너울성파도가 일어나지 않는 상황이어서 &amp;quot;너울성 파도가 일어나지 않은&amp;quot; 시점에 대해서, 모형이 &amp;quot;너울성 파도를 일어나지 않음&amp;quot;으로 예측하는 것은 조금 덜 중요하다고 볼 수 있다.&lt;br /&gt;
이런 특성 때문에 과제 평가 정책을 상황별로 다르게 스코어링 하였었고, 그 공식은 아래와 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;너울성파도가 일어난 시점에 대해서 모형이 너울성 파도가 일어났다고 예측 : 2점 증가&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;너울성파도가 일어난 시점에 대해서 모형이 너울성 파도가 일어나지 않았다고 예측 : 2점 차감&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;너울성 파도가 일어나지 않은 시점에 대해서 모형이 너울성 파도를 일어나지 않았다고 예측 : 1점 증가&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;너울성 파도가 일어나지 않은 시점에 대해서 모형이 너울성 파도가 일어났다고 예측 : 1점 차감&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 공식에 의해서 우리가 정한 Validation set 상에서의 최대치 점수는 1943점이었고 각 차수별 모형은 아래의 예측성능 점수를 매길 수 있었다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1차 Weighted Subspace Random Forest 알고리즘 모형 : 1471점&lt;/li&gt;
&lt;li&gt;2차 Artificial Neural Network(ANN) 모형 : 1507점&lt;/li&gt;
&lt;li&gt;3차 Flexible Discriminant Analysis(FDA) 모형 : 1545점&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;각-차수별-연구노트-정리&quot;&gt;각 차수별 연구노트 정리&lt;/h2&gt;
&lt;p&gt;각 차수 별로 각각 아래의 연구를 통해 모형을 구현하고 예측셋 시험지를 풀었다.&lt;/p&gt;
&lt;h3 id=&quot;차&quot;&gt;1차&lt;/h3&gt;
&lt;p&gt;머신러닝 알고리즘을 이용한 워밍업 단계라고 설명했는데&lt;br /&gt;
실제론 1차때 테스트해 본 케이스들이 정말로 많았다.&lt;br /&gt;
실험 알고리즘 케이스는 R의 caret 패키지의 머신러닝 프레임워크의 도움을 얻어 대표적으로 아래의 테스트를 해보았다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Partial Least Squares&lt;/li&gt;
&lt;li&gt;Generalized Linear Model&lt;/li&gt;
&lt;li&gt;Linear Discriminant Analysis&lt;/li&gt;
&lt;li&gt;ROC-Based Classifier&lt;/li&gt;
&lt;li&gt;k-Nearest Neighbors # Test 제외&lt;/li&gt;
&lt;li&gt;CART 5.0(Classification and Regression Tree)&lt;/li&gt;
&lt;li&gt;Weighted Subspace Random Forest&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;제시된 7개 머신러닝 알고리즘은 분류문제에 특화된 알고리즘으로써 본 데이터에 대해 성능을 기대하였던 알고리즘이다.&lt;br /&gt;
80%의 과거데이터를 Training set 으로 이용하기 위하여 파티션을 취했고, 이를 재료로 학습을 통해 모형을 구축하였다.&lt;br /&gt;
k Fold 교차검증으로[^상황에 따라 K를 8, 10 등으로 바꾸어서 하기도 해서 그냥 K라 표기한다] 각 알고리즘별 튜닝파라미터를 선정하였고, 파티션에 남은 20% 최근 데이터를 통해 예측성능을 확인해 보았다.&lt;/p&gt;
&lt;p&gt;7개 알고리즘 모형 중 Weighted Subspace Random Forest 알고리즘을 이용한 모형이 1471점으로 예측성능이 가장 높아 선정하게 되었다.&lt;/p&gt;
&lt;h3 id=&quot;차-1&quot;&gt;2차&lt;/h3&gt;
&lt;p&gt;1차때 선정된 Weighted Subspace Random Forest 알고리즘 모형보다 더 높은 예측성능을 내는 딥러닝 구현을 목표로 인공신경망(ANN)에 해당 하는 기법들을 테스트했다.&lt;br /&gt;
순환신경망(RNN), 심층신경망(DNN) 등을 테스트 하였고, 하이퍼 파라미터들에 대한 실험케이스들을 여러 개로 나누어 1차때의 예측성능 보다 높은 모형을 만들기 위해 노력했다.&lt;br /&gt;
그 결과 1507점을 내는 모형을 찾게 되었다.&lt;/p&gt;
&lt;h3 id=&quot;차-2&quot;&gt;3차&lt;/h3&gt;
&lt;p&gt;3차때는 전반적인 데이터의 현황에 대한 검토를 면밀하게 하고 넘어가고자 했다.&lt;br /&gt;
과제 전부터 한가지 집혔던 것이&lt;br /&gt;
전처리가 완료된 학습데이터 마트에 대한 EDA 후 확인되었던 이슈지만&lt;br /&gt;
너울성 파도의 발생 이벤트가 매우 소수이어서, 이 소수인 클래스의 학습력이 상대적으로 부족할 것이라고 우려했었다. 즉 Class imbalance problem 의 문제를 먼저 풀고 모델링에 들어가면 더 유리할 것이라고 생각했었다.&lt;br /&gt;
이 부분을 해결하기 위해 너울성 파도가 일어난 데이터(&lt;code&gt;swell&lt;/code&gt; = 1)를 늘리면서 너울성 파도가 일어나지 않은 데이터(&lt;code&gt;swell&lt;/code&gt; = 0)와 균형이 맞도록 Random Over Smapling 을 통해 학습셋을 기존 6,000여건에서 20,000여건으로 늘려 재구성 해 보았다.[^구현 방법은 R의 ROSE package를 이용했다]&lt;/p&gt;
&lt;p&gt;이후 재구성된 학습셋을 기준으로 이전에 시도했던 알고리즘들을 다시 돌려보고, 추가로&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Radial Basis Function Network&lt;/li&gt;
&lt;li&gt;Flexible Discriminant Analysis&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;두개의 머신러닝 알고리즘을 더 고려하여 테스트 해보니, 이전보다 더 높은 예측성능을 내는 모형이 나타났고 그 결과 Flexible Discriminant Analysis 모형이 1545점 으로 지금까지 수행한 모형의 예측성능 중 가장 높게 나온 모델을 만들었다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;모델링-이전-신경-썼던-부분&quot;&gt;모델링 이전 신경 썼던 부분&lt;/h2&gt;
&lt;p&gt;인공지능 모형이 오버피팅이 되는 것을 사전에 막고, 제한된 학습셋을 통해 우리가 알지 못하는 실제 Test set 에 대해 잘 예측해내는 모형을 만들기 위해선 데이터에 대한 다각도의 이해와 인공지능을 구현하기 위한 머신러닝 &amp;amp; 딥러닝 알고리즘에 대한 어느 정도 이론적인 이해도가 필요했다.&lt;br /&gt;
특히 차원의 저주로 인하여 타겟을(너울성파도) 예측하는데 더 많은 데이터를 필요로 하는 것을 막기 위하여 다중 공산성을 고려해 상관도가 높은 설명변수의 조합을 줄여보는 시도도 했고,&lt;br /&gt;
시계열적인 파생변수가 타겟과 유의미한 연관 관계가 있는지도 데이터 시각화를 통해 살펴보는 등&lt;br /&gt;
EDA 를 꽤 정성들여 해 본것이 인상깊었다. (사실 EDA 는 하면 할수록 욕심이 생겨 끝도 없이 해 볼 수 있는 과정이라 생각하는데.. 제한시간이 있었기에 어느 단계에서 멈출수 있었다는 건 함정..)&lt;br /&gt;
이는 Feature engineering 측면에서 다양한 실험케이스를 만들어 분석을 풍부하게 해 볼 수 있는 요인으로 작용했지만&lt;br /&gt;
본 과제의 결론은 Full model(가용 가능한 설명변수를 모두 이용하는 모델)이 채택이 되었었다.&lt;/p&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;해상의 기상 상황을 관측하는 장비를 의미한다&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn2&quot;&gt;&lt;p&gt;출처는 &lt;a href=&quot;http://sts.kma.go.kr/&quot;&gt;기상청 국가 기후 데이터 센터&lt;/a&gt;이다&lt;a href=&quot;#fnref2&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Wed, 19 Sep 2018 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/machinelearning/2018/09/19/posco_ai.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/machinelearning/2018/09/19/posco_ai.html</guid>
        
        
        <category>MachineLearning</category>
        
      </item>
    
      <item>
        <title>R에서 plot3d()함수를 이용한 3차원 산점도 만들기</title>
        <description>&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;다변량 데이터에 대해서 변수와 변수간 관계를 확인하고 설명하고 싶은 분들을 위해&lt;br /&gt;
그 관계성을 간편하고 직관적으로 도울 수 있는 도구들이 필요해 지고 있다.&lt;br /&gt;
특히 변수와 변수간 관계는 주관심 대상의 변수가 많아지면 많아질수록 확인해 보고 규명해야할 케이스도 많아지는데&lt;br /&gt;
이를 시각화 할때 2차원 산점도 에서는 그 많은 케이스를 확인하는데는 쉽게 피로해 질 수 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;너무많아...&lt;/p&gt;
&lt;/blockquote&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/plot3d_1.png&quot;&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;2차원 산점도 보다 한차원 높은 3차원 산점도는 주관심 대상 변수간 관계를 확인하기 위한 선택폭이 하나가 많고&lt;br /&gt;
조금 더 집중도있게 확인할 수 있는 장점이 있는 것 같다.&lt;br /&gt;
R에서는 rgl 패키지를 통해 3차원 산점도를 어려움 없이 구현할 수 있다.&lt;br /&gt;
rgl package 의 &lt;code&gt;plot3d()&lt;/code&gt; 함수를 소개해 본다.&lt;/p&gt;
&lt;p&gt;2차원 산점도를 그릴 때 R에선 간편히 &lt;code&gt;plot()&lt;/code&gt; 함수에서 &lt;code&gt;plot(x, y)&lt;/code&gt; 의 형태로 확인이 가능하다.&lt;br /&gt;
&lt;code&gt;plot3d()&lt;/code&gt; 함수에선 &lt;code&gt;plot3d(x, y, z)&lt;/code&gt; 의 형태로 주관심대상 변수 하나를 더 추가해 사용하면 되므로 이런 측면에선 사용법이 비슷하다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;plot3d()&lt;/code&gt; 의 예시코드를 실행해 보기 위해 rgl 패키지를 로드한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(rgl)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;아래 코드는 &lt;code&gt;plot3d()&lt;/code&gt; 의 대표 예제 코드이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;x &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;sort&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;rnorm&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1000&lt;/span&gt;))
y &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;rnorm&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1000&lt;/span&gt;)
z &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;rnorm&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1000&lt;/span&gt;) +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;atan2&lt;/span&gt;(x,y)
&lt;span class=&quot;kw&quot;&gt;plot3d&lt;/span&gt;(x, y, z, &lt;span class=&quot;dt&quot;&gt;col=&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;rainbow&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1000&lt;/span&gt;))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3차원 산점도를 출력시키는 &lt;code&gt;plot3d()&lt;/code&gt; 함수는 특수한 엔진을 사용하기 때문에&lt;br /&gt;
시각화 결과물이 (가령 Rstudio 의 경우 Plots창에 뜨지 않고) 새로운 창에 별도로 출력된다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;iframe width=&quot;95%&quot; height=&quot;420&quot; src=&quot;https://www.youtube.com/embed/oPszzgu00Uw&quot; frameborder=&quot;0&quot; allow=&quot;autoplay; encrypted-media&quot; allowfullscreen&gt;
&lt;/iframe&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;직접실행해 보면 새로운 팝업창이 뜨고(사용환경에 따라 다르다)&lt;br /&gt;
이 안에서 3D산점도가 출력되며, 사용자가 직접 움직여 볼 수 있다.&lt;br /&gt;
또한 휠을 움직이면 줌인과 줌아웃도 된다.&lt;/p&gt;
</description>
        <pubDate>Thu, 02 Aug 2018 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/data_visualization/2018/08/02/plot3d.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/data_visualization/2018/08/02/plot3d.html</guid>
        
        
        <category>R</category>
        
        <category>Data_Visualization</category>
        
      </item>
    
      <item>
        <title>R에서 Keras 튜토리얼 돌려보기</title>
        <description>&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;필자는 TensorFlow 를 활용한 딥러닝 구현은 아직까지도 직접 해본적이 없었는데&lt;br /&gt;
Keras 가 나오고서야 딥러닝을 처음으로 직접 시도해보게 되었다.&lt;br /&gt;
Keras 를 이용해 보고싶어 &lt;a href=&quot;https://tensorflow.rstudio.com/keras/&quot;&gt;튜토리얼&lt;/a&gt;을 빠르게 훝어본적이 있었는데&lt;br /&gt;
그 과정을 정리한 글이다.&lt;/p&gt;
&lt;p&gt;본글은 R에서 Keras 튜토리얼 예제를 따라해 본 것을 빠르게 정리한 글이며&lt;br /&gt;
딥러닝의 Hello world 격인 MNIST 의 숫자를 예측하는 모델을 만드는 것을 목적으로 한다.&lt;br /&gt;
딥러닝에 대한 이론적인 설명, 기술은 자세히 하지 않는다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;keras-를-r에서-설치하기&quot;&gt;Keras 를 R에서 설치하기&lt;/h2&gt;
&lt;p&gt;R session 에서 다음 코드를 통해 설치가 가능하다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;devtools::&lt;span class=&quot;kw&quot;&gt;install_github&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;rstudio/keras&amp;quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(keras)
&lt;span class=&quot;kw&quot;&gt;install_keras&lt;/span&gt;()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Keras 를 설치하기 위해서 rstudio 배포판 keras package 를 설치한다.&lt;br /&gt;
이후 keras package 를 로드하고 &lt;code&gt;install_keras()&lt;/code&gt; 함수를 통해 실제로 Keras 라이브러리를 설치할 수 있다.&lt;/p&gt;
&lt;p&gt;라이브러리를 추가로 설치하라는 요구사항이 뜨면서 설치가 중단될 경우 (본인의 경우 &lt;code&gt;python-virtualenv&lt;/code&gt; 가 없어서 중단됨)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Error: Prerequisites for installing TensorFlow not available.

Execute the following at a terminal to install the prerequisites:

$ sudo apt-get install python-virtualenv&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;안내 받는&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get install python-virtualenv&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;등을 실행시켜 요구사항을 충족시킨 후 &lt;code&gt;install_keras()&lt;/code&gt; 를 실행해 설치를 진행하면 되겠다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;mnist-튜토리얼-예제-수행&quot;&gt;MNIST 튜토리얼 예제 수행&lt;/h2&gt;
&lt;br&gt;&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/MNIST.png&quot;&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;지도학습의 대표적인 MNIST 예제를 수행해봄으로써 Keras 의 설치가 정상적으로 되었는지, 동작은 제대로 하는지 확인해보면 좋겠다.&lt;/p&gt;
&lt;p&gt;Keras 를 쓰기전에 코딩과정은 보통 아래의 레파토리를 거치며 진행된다.&lt;/p&gt;
&lt;br&gt;&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/keras_tuto.png&quot;&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;진행할 튜토리얼도&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;모델 정의&lt;/li&gt;
&lt;li&gt;모델 형태 사전설정&lt;/li&gt;
&lt;li&gt;모델 적합&lt;/li&gt;
&lt;li&gt;모델 평가&lt;/li&gt;
&lt;li&gt;모델을 통한 예측&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이 과정이 모두 담겨있다고 볼 수 있다.&lt;/p&gt;
&lt;p&gt;튜토리얼을 시작해보자.&lt;br /&gt;
우선 MNIST 데이터셋을 준비한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;mnist &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;dataset_mnist&lt;/span&gt;()
x_train &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;mnist$train$x
y_train &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;mnist$train$y
x_test &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;mnist$test$x
y_test &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;mnist$test$y

&lt;span class=&quot;co&quot;&gt;# reshape&lt;/span&gt;
x_train &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;array_reshape&lt;/span&gt;(x_train, &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;nrow&lt;/span&gt;(x_train), &lt;span class=&quot;dv&quot;&gt;784&lt;/span&gt;))
x_test &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;array_reshape&lt;/span&gt;(x_test, &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;nrow&lt;/span&gt;(x_test), &lt;span class=&quot;dv&quot;&gt;784&lt;/span&gt;))
&lt;span class=&quot;co&quot;&gt;# rescale&lt;/span&gt;
x_train &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;x_train /&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;255&lt;/span&gt;
x_test &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;x_test /&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;255&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위의 코드는 MNIST 의 숫자 사진들을 학습셋과 테스트셋으로 나누고 각각 라벨링을 정리한 것으로 보면 되겠다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;y_train &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;to_categorical&lt;/span&gt;(y_train, &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;)
y_test &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;to_categorical&lt;/span&gt;(y_test, &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;타겟라벨링 y 경우 맨 처음에는 각각의 그림이 무슨 숫자인지를 벡터형으로 관리했는데 더미화(One-hot encode) 하여야 한다.&lt;br /&gt;
&lt;code&gt;to_categorical()&lt;/code&gt; 함수를 통해 10개의 카테고리로써 One-hot encoding 을 간편히 수행할 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;model &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;keras_model_sequential&lt;/span&gt;() 
model %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;layer_dense&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;units =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;256&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;activation =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;#39;relu&amp;#39;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;input_shape =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;784&lt;/span&gt;)) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;layer_dropout&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;rate =&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;0.4&lt;/span&gt;) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;layer_dense&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;units =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;128&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;activation =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;#39;relu&amp;#39;&lt;/span&gt;) %&amp;gt;%
&lt;span class=&quot;st&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;layer_dropout&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;rate =&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;0.3&lt;/span&gt;) %&amp;gt;%
&lt;span class=&quot;st&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;layer_dense&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;units =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;activation =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;#39;softmax&amp;#39;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;모델링을 수행하기 전 모델링 방법과 레이어 구성 등의 Rule 을 적용하는 단계이다.&lt;br /&gt;
&lt;code&gt;keras_model_sequential()&lt;/code&gt; 로 모델의 레이어를 구성하기 위한 초기 뼈대를 만들어 놓고 그 객체를 &lt;code&gt;model&lt;/code&gt; 이 가져갔다면 &lt;code&gt;layer_dense()&lt;/code&gt; 함수와 &lt;code&gt;layer_dropout()&lt;/code&gt; 등의 함수들로 레이어의 순서와 구성을 기획할 수 있다.&lt;br /&gt;
단 &lt;code&gt;layer_dense()&lt;/code&gt;, &lt;code&gt;layer_dropout()&lt;/code&gt;, &lt;code&gt;layer_activation()&lt;/code&gt;, &lt;code&gt;layer_masking()&lt;/code&gt; 등의 함수들을 거친 keras.models.Sequential 클래스 객체는 따로 할당연산자 없이도 레이어 구성이 바로 적용되는것이 (나에게 있어선) 독특했다.&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;레이어 구성이 어떻게 되었는지 확인해 보고 싶다면 &lt;code&gt;summary(model)&lt;/code&gt; 을 실행해 보자.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;summary&lt;/span&gt;(model)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## ___________________________________________________________________________
## Layer (type)                     Output Shape                  Param #     
## ===========================================================================
## dense_7 (Dense)                  (None, 256)                   200960      
## ___________________________________________________________________________
## dropout_5 (Dropout)              (None, 256)                   0           
## ___________________________________________________________________________
## dense_8 (Dense)                  (None, 128)                   32896       
## ___________________________________________________________________________
## dropout_6 (Dropout)              (None, 128)                   0           
## ___________________________________________________________________________
## dense_9 (Dense)                  (None, 10)                    1290        
## ===========================================================================
## Total params: 235,146
## Trainable params: 235,146
## Non-trainable params: 0
## ___________________________________________________________________________&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;다음으로 &lt;code&gt;compile()&lt;/code&gt; 함수를 통해 비용함수와 최적화 방법, 최적화 평가기준을 설정할 수 있다.&lt;br /&gt;
튜토리얼 코드상에선 아래의 방법으로 설정했는데 그외 다양한 방법이 있는지 살펴보기 위해서 &lt;code&gt;compile()&lt;/code&gt; 함수의 도움말을 살펴보았지만 큰 도움이 안되어서 당황스러웠다.&lt;br /&gt;
이때 부터는 Keras document 를 직접 훝어보아야 할듯 하다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;model %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;compile&lt;/span&gt;(
  &lt;span class=&quot;dt&quot;&gt;loss =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;categorical_crossentropy&amp;quot;&lt;/span&gt;,
  &lt;span class=&quot;dt&quot;&gt;optimizer =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;optimizer_rmsprop&lt;/span&gt;(),
  &lt;span class=&quot;dt&quot;&gt;metrics =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;accuracy&amp;quot;&lt;/span&gt;)
)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;본격적으로 학습 및 평가를 해보자.&lt;/p&gt;
&lt;p&gt;학습은 &lt;code&gt;fit()&lt;/code&gt; 함수를 통해 가능하며 8 epochs 과 128 의 batch 사이즈로 학습을 수행하는 코드이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;history &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;model %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;fit&lt;/span&gt;(
  x_train, y_train, 
  &lt;span class=&quot;dt&quot;&gt;epochs =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;batch_size =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;128&lt;/span&gt;, 
  &lt;span class=&quot;dt&quot;&gt;validation_split =&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;0.2&lt;/span&gt;
)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;loss 가 계속 줄어드면서 학습 및 최적화를 하는 과정이 8 epochs 만큼 진행 되는 로그가 출력될 것이다.&lt;br /&gt;
약 1분이 지나면 코드수행이 끝나게 되고 &lt;code&gt;history&lt;/code&gt; 객체를 통해 학습수행과정에 대한 정보를 확인할 수 있다.&lt;br /&gt;
plotting 을 하면 학습과정중 training set 과 validation set 기준으로 정확도와 loss 가 epoch 별로 어떻게 변화했는지를 볼 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(history)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/keras_tuto1.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Keras 를 이용한 학습 모델이 테스트셋을 기준으로 얼마만큼 예측성능률을 가지고 잇는지 평가해 보자.&lt;br /&gt;
평가는 &lt;code&gt;evaluate()&lt;/code&gt; 함수를 이용한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;model %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;evaluate&lt;/span&gt;(x_test, y_test)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## $loss
## [1] 0.08196825
## 
## $acc
## [1] 0.9788&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;테스트셋에 대한 예측정확도가 97.88% 가 나온것을 볼 수 있다.&lt;br /&gt;
실제로 Testset 을 모델에 입력하여 어떤 숫자를 예측하는지 보고 싶다면&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;model %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;predict_classes&lt;/span&gt;(x_test[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;, ])&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##  [1] 7 2 1 0 4 1 4 9 5 9&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;를 통해 뽑을 수 있겠다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://keras.rstudio.com/&quot;&gt;R interface to Keras&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://tensorflow.rstudio.com/keras/&quot;&gt;R interface to Keras (TensorFlow)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;물론 다른 이름의 객체로 할당시키는것도 가능했다&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Sat, 02 Jun 2018 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/machinelearning/keras/2018/06/02/keras_tutorial.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/machinelearning/keras/2018/06/02/keras_tutorial.html</guid>
        
        
        <category>R</category>
        
        <category>MachineLearning</category>
        
        <category>Keras</category>
        
      </item>
    
      <item>
        <title>R에서 Newton Raphson Method 에 대한 시뮬레이션 과제 (+ ggplot2, gganimate package)</title>
        <description>&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;통계학과 대학원 수업 때 미분가능한 연속 함수에 대해서 해를 찾는 방법들을 공부한 적이 있다.&lt;br /&gt;
해를 찾아가는 과정들이 알고리즘 방법별로 특색이 있었는데, 원리를 알아가면 알아갈 수록 재미있기도 한 부분이었다.&lt;br /&gt;
특히 통계학 수업에선 1학년 학부때 부터 MLE(Maximum Likelihood Estimator) 라는 추정량의 특성을 중요하게 살펴본다.&lt;br /&gt;
극대값을 알아내기 위하여 1차 도함수에 해를 찾아내기 위한 훈련을 하면서도 나는 과연 이를 실전에 어떻게 적용할 것인가의 고민을 병행했고, 결과론적으로 프로그래밍을 어떻게 해야하는지 추가적인 고민을 더했던 때가 기억이 난다.&lt;/p&gt;
&lt;p&gt;학생을 벗어나 지금은 빅데이터 프로젝트에서 언제한번 이런 해를 찾는 과제를 수행해 볼지 살짝 의문이 들기는 한다.&lt;br /&gt;
하지만 빅데이터 프로젝트의 최종 목적지 앞 팔부능선 쯤에는 최적화 문제를 직면하는 분들도 보였고,&lt;br /&gt;
서비스가 안정화 되는 시점에서 모델과 추가 실데이터에 대한 2차 타당성 검증이 필요 할 때 역시 최적화가 잘 되었는지의 확인하는 문제로 수렴한다는 생각이 문득 든다.&lt;br /&gt;
이런 근사해를 찾는 이론을 바탕으로 근간한 아이디어를 최적화 관점에서 언제 어디선가 써먹을 일이 있지 않을까 싶다.&lt;br /&gt;
그런 의미로 대학원 때 배운 Newton Raphson Method 의 시뮬레이션을 회고해 본다.&lt;/p&gt;
&lt;p&gt;그냥 회고해 보면 약간 심심하니 R의 ggplot2 와 gganimate 패키지를 학습할 겸 곁들여 시뮬레이션을 생동감있게 해보고자 한다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;newton-raphson-method&quot;&gt;Newton Raphson method&lt;/h2&gt;
&lt;p&gt;Newton Raphson method 는 평균값 정리(mean value theorem) 혹은 테일러 근사(taylor approximation)를 근간으로 근사치를 반복하여 업데이트 하는 개념을 이용한다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/netwon_raphson_0.png&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;여기서 &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;&lt;em&gt;n&lt;/em&gt;&lt;/sub&gt;&lt;/span&gt; 의 n을 계속 증가시켜 가다 보면 수렴하게 되는데 &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;∞&lt;/sub&gt;&lt;/span&gt; 을 &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;f&lt;/em&gt;(&lt;em&gt;x&lt;/em&gt;)=0&lt;/span&gt; 의 해로 판단한다.&lt;br /&gt;
단 무한대로 반복할 순 없기 때문에 정지조건을 부여한다.&lt;/p&gt;
&lt;p&gt;이 Newton Raphson method 를 구현한 R code 는 아래와 같다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.academia.edu/7031789/Newton-Raphson_Method_in_R&quot;&gt;Newton Raphson Method in R&lt;/a&gt; 글을 참조함&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;newton &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;function(fun, &lt;span class=&quot;dt&quot;&gt;tol =&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;1e-7&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;x0 =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;N =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;300&lt;/span&gt;){
  h &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;fl&quot;&gt;1e-7&lt;/span&gt;
  i &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
  x1 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;x0
  p &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;numeric&lt;/span&gt;(N)
  while(i &amp;lt;=&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;N){
    df.dx &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;fun&lt;/span&gt;(x0 +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;h) -&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;fun&lt;/span&gt;(x0)) /&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;h
    x1 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;(x0 -&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;fun&lt;/span&gt;(x0) /&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;df.dx))
    p[i] &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;x1
    i =&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;i&lt;span class=&quot;dv&quot;&gt;+1&lt;/span&gt;
    if(&lt;span class=&quot;kw&quot;&gt;abs&lt;/span&gt;(x1 -&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;x0) &amp;lt;&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;tol) break
    x0 =&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;x1
  }
  &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;(p[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:(i -&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)])
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;정의된 &lt;code&gt;newton()&lt;/code&gt; 함수를 이용해 &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;f&lt;/em&gt;(&lt;em&gt;x&lt;/em&gt;)=&lt;em&gt;x&lt;/em&gt;&lt;sup&gt;3&lt;/sup&gt; + 2&lt;/span&gt; 함수의 &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;f&lt;/em&gt;(&lt;em&gt;x&lt;/em&gt;)=0&lt;/span&gt; 의 해를 초기값 2 에서 찾기 시작하면&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;fun &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;function(x) x^&lt;span class=&quot;dv&quot;&gt;3+2&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;newton&lt;/span&gt;(fun, &lt;span class=&quot;dt&quot;&gt;x0 =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##  [1]  1.166667  0.287982 -7.846566 -5.241872 -3.518844 -2.399736 -1.715590
##  [8] -1.370234 -1.268564 -1.259980 -1.259921 -1.259921&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이렇게 된다.&lt;br /&gt;
&lt;code&gt;tol&lt;/code&gt; 값 보다 현시차와 이전시차값의 절대값 차이가 적을 때 정지조건에 의해서 멈추는데&lt;br /&gt;
멈추고 나서의 마지막 값이 &lt;code&gt;-1.259921&lt;/code&gt; 이며 Newton Raphson method 는 이 값을 &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;x&lt;/em&gt;&lt;sup&gt;3&lt;/sup&gt; + 2 = 0&lt;/span&gt; 의 해로 계산한다.&lt;/p&gt;
&lt;p&gt;ggplot2 로 &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;y&lt;/em&gt; = &lt;em&gt;x&lt;/em&gt;&lt;sup&gt;3&lt;/sup&gt; + 2&lt;/span&gt; 함수의 그래프를 그린 후 이터레이션 별로 어디에 수렴해 가는지 시각화 해보면 아래와 같다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;p &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;ggplot&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;data.frame&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;x =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(-&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)), &lt;span class=&quot;kw&quot;&gt;aes&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;x =&lt;/span&gt; x)) +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;stat_function&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;fun =&lt;/span&gt; fun, &lt;span class=&quot;dt&quot;&gt;color =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;blue&amp;quot;&lt;/span&gt;) +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;geom_hline&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;yintercept =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;geom_vline&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;xintercept =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)

d &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;data.frame&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;label =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;kw&quot;&gt;length&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;newton&lt;/span&gt;(fun, &lt;span class=&quot;dt&quot;&gt;x0 =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)), 
                &lt;span class=&quot;dt&quot;&gt;x =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;newton&lt;/span&gt;(fun, &lt;span class=&quot;dt&quot;&gt;x0 =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;), 
                &lt;span class=&quot;dt&quot;&gt;y =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;fun&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;newton&lt;/span&gt;(fun, &lt;span class=&quot;dt&quot;&gt;x0 =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)))

p2 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;p +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;geom_point&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; d, &lt;span class=&quot;kw&quot;&gt;aes&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;x =&lt;/span&gt; x, &lt;span class=&quot;dt&quot;&gt;y =&lt;/span&gt; y, &lt;span class=&quot;dt&quot;&gt;frame =&lt;/span&gt; label)) +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;geom_text&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; d, &lt;span class=&quot;kw&quot;&gt;aes&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;x =&lt;/span&gt; x, &lt;span class=&quot;dt&quot;&gt;y =&lt;/span&gt; y +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;label =&lt;/span&gt; label, &lt;span class=&quot;dt&quot;&gt;frame =&lt;/span&gt; label), &lt;span class=&quot;dt&quot;&gt;size =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;)

p2&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/netwon_raphson_1.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;총 12번의 반복을 통해 &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;x&lt;/em&gt; = −1.259921&lt;/span&gt; 에 가까워 지는것을 볼 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;ggplot2-에-gganimate-패키지-조합하여-시뮬레이션-시각화-하기&quot;&gt;ggplot2 에 gganimate 패키지 조합하여 시뮬레이션 시각화 하기&lt;/h2&gt;
&lt;p&gt;(개발단계로써 CRAN 에 등록되지 않은) &lt;a href=&quot;https://github.com/dgrtwo/gganimate&quot;&gt;gganimate package&lt;/a&gt;는&lt;br /&gt;
ggplot2 결과물을 프레임별로 만들어 에니메이션 그림파일을 만들어주는 재미있는 R package 이다.&lt;br /&gt;
ggplot2 문법규칙을 그대로 이용하는데 에스테틱에 &lt;code&gt;frame&lt;/code&gt; 인자를 지정하기만 하면 된다.&lt;/p&gt;
&lt;p&gt;gganimate package 설치는 &lt;code&gt;install_github()&lt;/code&gt; 를 이용한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;devtools::&lt;span class=&quot;kw&quot;&gt;install_github&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;dgrtwo/gganimate&amp;quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(gganimate)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;그리고 위에서 시각화한 &lt;code&gt;p2&lt;/code&gt; 를 재활용 한다.&lt;br /&gt;
&lt;code&gt;gganimate()&lt;/code&gt; 함수에 우선 입력해 보면&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;gganimate&lt;/span&gt;(p2)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/netwon_raphson_gif.gif&quot;&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;애니메이션 gif 가 잘 출력되는데 &lt;code&gt;p2&lt;/code&gt; 에 실은 frame 에스테틱을 미리 선언했기 때문이다.&lt;br /&gt;
입력될 ggplot 객체에 frame 에스테틱이 없을 경우 &lt;code&gt;gganimate(p2)&lt;/code&gt; 은 에러를 내며 수행되지 않는다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Error in gganimate(p2) : 
  No frame aesthetic found; cannot create animation&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;?gganimate()&lt;/code&gt; 를 실행해 다양한 옵션과 예제코드를 살펴보면 좋을 것이다.&lt;br /&gt;
gganimate package 에는 &lt;code&gt;saveVideo()&lt;/code&gt;, &lt;code&gt;saveGIF()&lt;/code&gt; 함수가 &lt;code&gt;gganimate()&lt;/code&gt; 함수에 연루되어 있으며,&lt;br /&gt;
비디오 파일을 만들거나 에니메이션 gif 파일을 만들 때 &lt;a href=&quot;http://ffmpeg.org/documentation.html&quot;&gt;ffmpeg&lt;/a&gt; 를 이용한 다양한 옵션들을 부여할 수 있음을 확인할 수 있을것이다.&lt;/p&gt;
</description>
        <pubDate>Tue, 24 Apr 2018 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/data_visualization/2018/04/24/netwon_raphson_method.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/data_visualization/2018/04/24/netwon_raphson_method.html</guid>
        
        
        <category>R</category>
        
        <category>Data_Visualization</category>
        
      </item>
    
      <item>
        <title>Docker 를 통해 Cloudera Manager 띄워보기</title>
        <description>&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://kr.cloudera.com/products/product-components/cloudera-manager.html&quot;&gt;Cloudera Manager&lt;/a&gt;(이하 CM) 실습환경을 구성하기 위해 &lt;a href=&quot;https://www.virtualbox.org/&quot;&gt;Virtual Box&lt;/a&gt; 로 CentOS 설치 및 환경설정 구성을 수차례 반복하여 힘겹게 성공 후&lt;br /&gt;
이 성공을 쉽게 재활용하기 위해 스냅샷을 저장했던 어느 날 내 맥북의 물리적 용량이 바닥이 나버렸다..&lt;br /&gt;
물리적 용량도 용량이지만 가상머신 3대를 켜 놓고 소프트웨어를 배포하는 과정 중에서 내 맥북은 한계에 도달했는지 자주 멈추어 버렸다.&lt;br /&gt;
결국은 Docker를 이용하겠어! 라는 결심과 동시에 행동으로 옮겼다.&lt;br /&gt;
약 30분&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;만에 Docker 를 통해 Cloudera Manager 을 실행시키는 데 성공했다.&lt;br /&gt;
Virtual Box 로 교재에 똑같이 따라 해서 띄우는 데는 순수하게 10시간 정도의 시행착오를 겪은 것 에 비하면 정말 순식간이었다. (물론 이런 삽질이 있었기에 Docker 에서 30분밖에 안 걸린 것일 수 있다 &lt;i class=&quot;fa fa-meh-o&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;;)&lt;/p&gt;
&lt;p&gt;필자와 같이 실습을 진행하는 분께도 온전히 30 분만에 CM 환경구성을 할 수 있도록 본 글을 통해 정리하고자 한다.&lt;br /&gt;
또한 내용들의 대부분은 &amp;quot;cloudera manager on docker&amp;quot; 라는 검색어로 구글에 검색된 글들에 기반함을 밝힌다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;(단 Datanode 를 늘리는 확장성을 고려한 실습은 이 글에서는 논외이다. 오직 CM 를 띄우고 이를 통해 할 수 있는 것들이 무엇이 있는지, 인터페이스는 어떠한지 입문자용으로써 공부를 위한 환경구성이 목적이기에 Datanode 의 선형확장까지를 고려한 실습이라면 내생각엔 Cloudera QuickStart 컨테이너를 이용한 본 글보단 VM 을 통해 실제로 Datanode 로 할당할 서버를 만들어 실습하는 것이 손에 더 잘 잡히고 직관적이며, 선형확장을 하기위한 원리와 과정 자체를 익힐 필요가 있다고 생각한다)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;필요-요건&quot;&gt;필요 요건&lt;/h2&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;Docker 설치가 되어있어야 한다.&lt;/li&gt;
&lt;li&gt;online 상태이어야 한다. (인터넷이 되어야 한다)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;분의-과정&quot;&gt;30분의 과정&lt;/h2&gt;
&lt;p&gt;Cloudera 에서는 docker container 를 통해 CM 을 띄우기 위한 &lt;a href=&quot;https://www.cloudera.com/documentation/enterprise/5-6-x/topics/quickstart_docker_container.html&quot;&gt;Cloudera QuickStart 문서&lt;/a&gt;를 제공해 주고 있다.&lt;br /&gt;
그대로 따라해 본 걸 한글화 시킨 것으로 이글을 봐도 무방하겠다.&lt;/p&gt;
&lt;h3 id=&quot;첫-번째로-터미널을-킨-후&quot;&gt;첫 번째로 터미널을 킨 후&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;docker pull cloudera/quickstart:latest&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;를 통해 Cloudera QuickStart 도커이미지 최신버전을 다운로드 한다.&lt;br /&gt;
필자의 환경에선 수십분의 시간이 걸렸으니 차분히 기다린다.&lt;br /&gt;
완료가 되었다면&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker images&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;를 실행해 Cloudera QuickStart docker image 가 준비되었는지 한번 확인해 본다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;script src=&quot;https://asciinema.org/a/177648.js&quot; id=&quot;asciicast-177648&quot; async&gt;&lt;/script&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;cloudera/quickstart 이미지의 ID 는 4239cd2958c6, 이미지 용량은 6.34Gb 임을 확인할 수 있다.&lt;/p&gt;
&lt;h3 id=&quot;두-번째로-컨테이너를-실행한다&quot;&gt;두 번째로 컨테이너를 실행한다&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;docker run --hostname=quickstart.cloudera --privileged=true -t -i [OPTIONS] [IMAGE] /usr/bin/docker-quickstart&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;에서 &lt;code&gt;[OPTIONS]&lt;/code&gt; 부분은 &lt;code&gt;-p 80:80 -p 7180:7180 -p 8888:8888&lt;/code&gt; 로 입력해 호스트간의 포트번호 80, 7180, 8888 을 열어 놓는다.&lt;br /&gt;
&lt;code&gt;[IMAGE]&lt;/code&gt; 부분은 이미지 ID 인 &lt;code&gt;4239cd2958c6&lt;/code&gt; 를 입력한다. 즉&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run --hostname=quickstart.cloudera --privileged=true -t -i -p 80:80 -p 7180:7180 -p 8888:8888 4239cd2958c6 /usr/bin/docker-quickstart&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;를 터미널에서 실행한다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;script src=&quot;https://asciinema.org/a/177651.js&quot; id=&quot;asciicast-177651&quot; async&gt;&lt;/script&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;이후 localhost 의 80번 포트로 접속&lt;a href=&quot;#fn2&quot; class=&quot;footnoteRef&quot; id=&quot;fnref2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;을 웹브라우저에서 해보면 &amp;quot;Welcome to Your Cloudera QuickStart VM!&amp;quot; page 가 반기게 되며, 8888번 포트로는 Hue가 뜨는것을 볼 수 있다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/docker_cm05.png&quot;&gt;
&lt;/center&gt;
&lt;br&gt; &lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/docker_cm06.png&quot;&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;그런데 그것보단 내 관심사는 7180번 포트인데 CM 이 디폴트로 사용하는 포트번호이다.&lt;br /&gt;
하지만 접속을 해보면 이렇게 뜬다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/docker_cm01.png&quot;&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;clouder quickstart 컨테이너는 기본적으로 CM 을 같이 실행하지 않는다고 한다. 따라서&lt;/p&gt;
&lt;h2 id=&quot;세-번째로-clouder-quickstart-컨테이너상에서-homeclouderacloudera-manager---express-명령을-입력하여-cm-을-실행시킨다&quot;&gt;세 번째로 clouder quickstart 컨테이너상에서 &lt;code&gt;/home/cloudera/cloudera-manager --express&lt;/code&gt; 명령을 입력하여 CM 을 실행시킨다&lt;/h2&gt;
&lt;p&gt;Cloudera QuickStart 컨테이너의 bash 에서 아직 빠져나오지 않았다면 &lt;code&gt;/home/cloudera/cloudera-manager --express&lt;/code&gt; 를 그대로 실행시키면 되고&lt;/p&gt;
&lt;p&gt;컨테이너 밖으로 빠져나온 호스트 상의 상태라면 &lt;code&gt;docker ps&lt;/code&gt; 를 통해 실행되고 있는 clouder quickstart 컨테이너 ID 를 알아낸 후 docker 의 exec 명령을 이처럼 이용해도 된다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker exec [CONTAINER_ID] /home/cloudera/cloudera-manager --express&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;[CONTAINER_ID]&lt;/code&gt; 이 부분을 clouder quickstart 컨테이너 ID 를 입력하면 된다.&lt;br /&gt;
여하튼 그 결과는 아래와 같이 진행된다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;script src=&quot;https://asciinema.org/a/177654.js&quot; id=&quot;asciicast-177654&quot; async&gt;&lt;/script&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;약간의 시간이 걸린다.&lt;br /&gt;
접속 계정과 비밀번호는 cloudera 이다라는 문구가 뜨면 로컬호스트의 7180 포트로 접속시 CM 로그인 화면을 볼 수 있게 된다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/docker_cm02.png&quot;&gt;
&lt;/center&gt;
&lt;br&gt; &lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/docker_cm03.png&quot;&gt;
&lt;/center&gt;
&lt;br&gt; &lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/docker_cm04.png&quot;&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://youtu.be/elXTmZbNNmE&quot;&gt;Cloudera QuickStart - Installation Using Docker Container on Ubuntu - Part 1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://youtu.be/mqFizIPJl1c&quot;&gt;Cloudera QuickStart - Starting Cloudera Manager on already running Docker Container - Part 2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;이 30분 중에서도 docker image 를 pull(다운로드) 하는 데에 20분 정도가 걸렸으므로 10분의 고민만 필요했다고 볼 수 있다&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn2&quot;&gt;&lt;p&gt;&lt;code&gt;http://127.0.0.1:80/&lt;/code&gt; 주소로 접속&lt;a href=&quot;#fnref2&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Sun, 22 Apr 2018 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/docker/mac/opensource_tool/2018/04/22/docker_CM.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/docker/mac/opensource_tool/2018/04/22/docker_CM.html</guid>
        
        
        <category>Docker</category>
        
        <category>Mac</category>
        
        <category>OpenSource_Tool</category>
        
      </item>
    
      <item>
        <title>Mac OS X 에서 hosts 를 추가하려면?</title>
        <description>&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;최근 &lt;a href=&quot;http://kr.cloudera.com/products/product-components/cloudera-manager.html&quot;&gt;Cloudera Manager&lt;/a&gt;를 사용해 보기 위하여 &lt;a href=&quot;https://www.virtualbox.org/&quot;&gt;Virtual Box&lt;/a&gt;를 통해 가상머신들을 준비 후 CDH(Cloudera Distribution Hadoop)를 이용해 Hadoop 및 빅데이터 소프트웨어를 배포 ・ 설치를 진행중이다.&lt;br /&gt;
그 과정중 호스트에서 가상머신에 돌아가고 있는 클라우데라 웹 클라이언트 접속을 시도하면 되는데&lt;br /&gt;
그 전에 로컬상 가상머신의 접속이 IP address 뿐만 아니라 도메인 주소로도 원활하도록 호스트를 등록해야 하는 과정이 필요했다.&lt;/p&gt;
&lt;p&gt;참고하는 교재&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;에선 윈도우를 기준으로 설명하고 있어서 Mac OS X 에서는 어떻게 하는지 궁금했는데&lt;br /&gt;
찾아보니 방법은 아래와 같았다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;script src=&quot;https://asciinema.org/a/176946.js&quot; id=&quot;asciicast-176946&quot; async&gt;&lt;/script&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;이처럼 Mac OS X 에서 hosts 정보를 가지고 있는 파일은 &lt;code&gt;/private/etc/hosts&lt;/code&gt; 이다.&lt;br /&gt;
이쪽에 등록, 수정하고 싶은 host 에 대한 정보를 편집한 후 재부팅(&lt;code&gt;reboot&lt;/code&gt;) 하면 된다.&lt;/p&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;&lt;a href=&quot;http://book.naver.com/bookdb/book_detail.nhn?bid=12545645&quot;&gt;실무로 배우는 빅데이터 기술 - 김강원 저&lt;/a&gt;&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Wed, 18 Apr 2018 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/mac/2018/04/18/mac_hosts.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/mac/2018/04/18/mac_hosts.html</guid>
        
        
        <category>Mac</category>
        
      </item>
    
  </channel>
</rss>
