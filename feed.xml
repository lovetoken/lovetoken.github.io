<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description></description>
    <link>https://lovetoken.github.io/</link>
    <atom:link href="https://lovetoken.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 03 Jun 2018 22:42:59 +0900</pubDate>
    <lastBuildDate>Sun, 03 Jun 2018 22:42:59 +0900</lastBuildDate>
    <generator>Jekyll v3.1.6</generator>
    
      <item>
        <title>R에서 Keras 튜토리얼 돌려보기</title>
        <description>&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;필자는 TensorFlow 를 활용한 딥러닝 구현은 아직까지도 직접 해본적이 없었는데&lt;br /&gt;
Keras 가 나오고서야 딥러닝을 처음으로 직접 시도해보게 되었다.&lt;br /&gt;
Keras 를 이용해 보고싶어 &lt;a href=&quot;https://tensorflow.rstudio.com/keras/&quot;&gt;튜토리얼&lt;/a&gt;을 빠르게 훝어본적이 있었는데&lt;br /&gt;
그 과정을 정리한 글이다.&lt;/p&gt;
&lt;p&gt;본글은 R에서 Keras 튜토리얼 예제를 따라해 본 것을 빠르게 정리한 글이며&lt;br /&gt;
딥러닝의 Hello world 격인 MNIST 의 숫자를 예측하는 모델을 만드는 것을 목적으로 한다.&lt;br /&gt;
딥러닝에 대한 이론적인 설명, 기술은 자세히 하지 않는다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;keras-를-r에서-설치하기&quot;&gt;Keras 를 R에서 설치하기&lt;/h2&gt;
&lt;p&gt;R session 에서 다음 코드를 통해 설치가 가능하다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;devtools::&lt;span class=&quot;kw&quot;&gt;install_github&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;rstudio/keras&amp;quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(keras)
&lt;span class=&quot;kw&quot;&gt;install_keras&lt;/span&gt;()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Keras 를 설치하기 위해서 rstudio 배포판 keras package 를 설치한다.&lt;br /&gt;
이후 keras package 를 로드하고 &lt;code&gt;install_keras()&lt;/code&gt; 함수를 통해 실제로 Keras 라이브러리를 설치할 수 있다.&lt;/p&gt;
&lt;p&gt;라이브러리를 추가로 설치하라는 요구사항이 뜨면서 설치가 중단될 경우 (본인의 경우 &lt;code&gt;python-virtualenv&lt;/code&gt; 가 없어서 중단됨)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Error: Prerequisites for installing TensorFlow not available.

Execute the following at a terminal to install the prerequisites:

$ sudo apt-get install python-virtualenv&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;안내 받는&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get install python-virtualenv&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;등을 실행시켜 요구사항을 충족시킨 후 &lt;code&gt;install_keras()&lt;/code&gt; 를 실행해 설치를 진행하면 되겠다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;mnist-튜토리얼-예제-수행&quot;&gt;MNIST 튜토리얼 예제 수행&lt;/h2&gt;
&lt;br&gt;&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/MNIST.png&quot;&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;지도학습의 대표적인 MNIST 예제를 수행해봄으로써 Keras 의 설치가 정상적으로 되었는지, 동작은 제대로 하는지 확인해보면 좋겠다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;mnist &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;dataset_mnist&lt;/span&gt;()
x_train &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;mnist$train$x
y_train &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;mnist$train$y
x_test &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;mnist$test$x
y_test &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;mnist$test$y

&lt;span class=&quot;co&quot;&gt;# reshape&lt;/span&gt;
x_train &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;array_reshape&lt;/span&gt;(x_train, &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;nrow&lt;/span&gt;(x_train), &lt;span class=&quot;dv&quot;&gt;784&lt;/span&gt;))
x_test &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;array_reshape&lt;/span&gt;(x_test, &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;nrow&lt;/span&gt;(x_test), &lt;span class=&quot;dv&quot;&gt;784&lt;/span&gt;))
&lt;span class=&quot;co&quot;&gt;# rescale&lt;/span&gt;
x_train &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;x_train /&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;255&lt;/span&gt;
x_test &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;x_test /&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;255&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위의 코드는 MNIST 의 숫자 사진들을 학습셋과 테스트셋으로 나누고 각각 라벨링을 정리한 것으로 보면 되겠다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;y_train &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;to_categorical&lt;/span&gt;(y_train, &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;)
y_test &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;to_categorical&lt;/span&gt;(y_test, &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;타겟라벨링 y 경우 맨 처음에는 각각의 그림이 무슨 숫자인지를 벡터형으로 관리했는데 더미화(One-hot encode) 하여야 한다.&lt;br /&gt;
&lt;code&gt;to_categorical()&lt;/code&gt; 함수를 통해 10개의 카테고리로써 One-hot encoding 을 간편히 수행할 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;model &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;keras_model_sequential&lt;/span&gt;() 
model %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;layer_dense&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;units =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;256&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;activation =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;#39;relu&amp;#39;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;input_shape =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;784&lt;/span&gt;)) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;layer_dropout&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;rate =&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;0.4&lt;/span&gt;) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;layer_dense&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;units =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;128&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;activation =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;#39;relu&amp;#39;&lt;/span&gt;) %&amp;gt;%
&lt;span class=&quot;st&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;layer_dropout&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;rate =&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;0.3&lt;/span&gt;) %&amp;gt;%
&lt;span class=&quot;st&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;layer_dense&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;units =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;activation =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;#39;softmax&amp;#39;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;모델링을 수행하기 전 모델링 방법과 레이어 구성 등의 Rule 을 적용하는 단계이다.&lt;br /&gt;
&lt;code&gt;keras_model_sequential()&lt;/code&gt; 로 모델의 레이어를 구성하기 위한 초기 뼈대를 만들어 놓고 그 객체를 &lt;code&gt;model&lt;/code&gt; 이 가져갔다면 &lt;code&gt;layer_dense()&lt;/code&gt; 함수와 &lt;code&gt;layer_dropout()&lt;/code&gt; 등의 함수들로 레이어의 순서와 구성을 기획할 수 있다.&lt;br /&gt;
단 &lt;code&gt;layer_dense()&lt;/code&gt;, &lt;code&gt;layer_dropout()&lt;/code&gt;, &lt;code&gt;layer_activation()&lt;/code&gt;, &lt;code&gt;layer_masking()&lt;/code&gt; 등의 함수들을 거친 keras.models.Sequential 클래스 객체는 따로 할당연산자 없이도 레이어 구성이 바로 적용되는것이 (나에게 있어선) 독특했다.&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;레이어 구성이 어떻게 되었는지 확인해 보고 싶다면 &lt;code&gt;summary(model)&lt;/code&gt; 을 실행해 보자.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;summary&lt;/span&gt;(model)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## ___________________________________________________________________________
## Layer (type)                     Output Shape                  Param #     
## ===========================================================================
## dense_7 (Dense)                  (None, 256)                   200960      
## ___________________________________________________________________________
## dropout_5 (Dropout)              (None, 256)                   0           
## ___________________________________________________________________________
## dense_8 (Dense)                  (None, 128)                   32896       
## ___________________________________________________________________________
## dropout_6 (Dropout)              (None, 128)                   0           
## ___________________________________________________________________________
## dense_9 (Dense)                  (None, 10)                    1290        
## ===========================================================================
## Total params: 235,146
## Trainable params: 235,146
## Non-trainable params: 0
## ___________________________________________________________________________&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;다음으로 &lt;code&gt;compile()&lt;/code&gt; 함수를 통해 비용함수와 최적화 방법, 최적화 평가기준을 설정할 수 있다.&lt;br /&gt;
튜토리얼 코드상에선 아래의 방법으로 설정했는데 그외 다양한 방법이 있는지 살펴보기 위해서 &lt;code&gt;compile()&lt;/code&gt; 함수의 도움말을 살펴보았지만 큰 도움이 안되어서 당황스러웠다.&lt;br /&gt;
이때 부터는 Keras document 를 직접 훝어보아야 할듯 하다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;model %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;compile&lt;/span&gt;(
  &lt;span class=&quot;dt&quot;&gt;loss =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;categorical_crossentropy&amp;quot;&lt;/span&gt;,
  &lt;span class=&quot;dt&quot;&gt;optimizer =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;optimizer_rmsprop&lt;/span&gt;(),
  &lt;span class=&quot;dt&quot;&gt;metrics =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;accuracy&amp;quot;&lt;/span&gt;)
)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;본격적으로 학습 및 평가를 해보자.&lt;/p&gt;
&lt;p&gt;학습은 &lt;code&gt;fit()&lt;/code&gt; 함수를 통해 가능하며 8 epochs 과 128 의 batch 사이즈로 학습을 수행하는 코드이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;history &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;model %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;fit&lt;/span&gt;(
  x_train, y_train, 
  &lt;span class=&quot;dt&quot;&gt;epochs =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;batch_size =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;128&lt;/span&gt;, 
  &lt;span class=&quot;dt&quot;&gt;validation_split =&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;0.2&lt;/span&gt;
)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;loss 가 계속 줄어드면서 학습 및 최적화를 하는 과정이 8 epochs 만큼 진행 되는 로그가 출력될 것이다.&lt;br /&gt;
약 1분이 지나면 코드수행이 끝나게 되고 &lt;code&gt;history&lt;/code&gt; 객체를 통해 학습수행과정에 대한 정보를 확인할 수 있다.&lt;br /&gt;
plotting 을 하면 학습과정중 training set 과 validation set 기준으로 정확도와 loss 가 epoch 별로 어떻게 변화했는지를 볼 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(history)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/keras_tuto1.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Keras 를 이용한 학습 모델이 테스트셋을 기준으로 얼마만큼 예측성능률을 가지고 잇는지 평가해 보자.&lt;br /&gt;
평가는 &lt;code&gt;evaluate()&lt;/code&gt; 함수를 이용한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;model %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;evaluate&lt;/span&gt;(x_test, y_test)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## $loss
## [1] 0.08196825
## 
## $acc
## [1] 0.9788&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;테스트셋에 대한 예측정확도가 97.88% 가 나온것을 볼 수 있다.&lt;br /&gt;
실제로 Testset 을 모델에 입력하여 어떤 숫자를 예측하는지 보고 싶다면&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;model %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;predict_classes&lt;/span&gt;(x_test[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;, ])&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##  [1] 7 2 1 0 4 1 4 9 5 9&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;를 통해 뽑을 수 있겠다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://keras.rstudio.com/&quot;&gt;R interface to Keras&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://tensorflow.rstudio.com/keras/&quot;&gt;R interface to Keras (TensorFlow)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;물론 다른 이름의 객체로 할당시키는것도 가능했다&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Sat, 02 Jun 2018 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/machinelearning/keras/2018/06/02/keras_tutorial.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/machinelearning/keras/2018/06/02/keras_tutorial.html</guid>
        
        
        <category>R</category>
        
        <category>MachineLearning</category>
        
        <category>Keras</category>
        
      </item>
    
      <item>
        <title>R에서 Newton Raphson Method 에 대한 시뮬레이션 과제 (+ ggplot2, gganimate package)</title>
        <description>&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;통계학과 대학원 수업 때 미분가능한 연속 함수에 대해서 해를 찾는 방법들을 공부한 적이 있다.&lt;br /&gt;
해를 찾아가는 과정들이 알고리즘 방법별로 특색이 있었는데, 원리를 알아가면 알아갈 수록 재미있기도 한 부분이었다.&lt;br /&gt;
특히 통계학 수업에선 1학년 학부때 부터 MLE(Maximum Likelihood Estimator) 라는 추정량의 특성을 중요하게 살펴본다.&lt;br /&gt;
극대값을 알아내기 위하여 1차 도함수에 해를 찾아내기 위한 훈련을 하면서도 나는 과연 이를 실전에 어떻게 적용할 것인가의 고민을 병행했고, 결과론적으로 프로그래밍을 어떻게 해야하는지 추가적인 고민을 더했던 때가 기억이 난다.&lt;/p&gt;
&lt;p&gt;학생을 벗어나 지금은 빅데이터 프로젝트에서 언제한번 이런 해를 찾는 과제를 수행해 볼지 살짝 의문이 들기는 한다.&lt;br /&gt;
하지만 빅데이터 프로젝트의 최종 목적지 앞 팔부능선 쯤에는 최적화 문제를 직면하는 분들도 보였고,&lt;br /&gt;
서비스가 안정화 되는 시점에서 모델과 추가 실데이터에 대한 2차 타당성 검증이 필요 할 때 역시 최적화가 잘 되었는지의 확인하는 문제로 수렴한다는 생각이 문득 든다.&lt;br /&gt;
이런 근사해를 찾는 이론을 바탕으로 근간한 아이디어를 최적화 관점에서 언제 어디선가 써먹을 일이 있지 않을까 싶다.&lt;br /&gt;
그런 의미로 대학원 때 배운 Newton Raphson Method 의 시뮬레이션을 회고해 본다.&lt;/p&gt;
&lt;p&gt;그냥 회고해 보면 약간 심심하니 R의 ggplot2 와 gganimate 패키지를 학습할 겸 곁들여 시뮬레이션을 생동감있게 해보고자 한다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;newton-raphson-method&quot;&gt;Newton Raphson method&lt;/h2&gt;
&lt;p&gt;Newton Raphson method 는 평균값 정리(mean value theorem) 혹은 테일러 근사(taylor approximation)를 근간으로 근사치를 반복하여 업데이트 하는 개념을 이용한다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/netwon_raphson_0.png&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;여기서 &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;&lt;em&gt;n&lt;/em&gt;&lt;/sub&gt;&lt;/span&gt; 의 n을 계속 증가시켜 가다 보면 수렴하게 되는데 &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;∞&lt;/sub&gt;&lt;/span&gt; 을 &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;f&lt;/em&gt;(&lt;em&gt;x&lt;/em&gt;)=0&lt;/span&gt; 의 해로 판단한다.&lt;br /&gt;
단 무한대로 반복할 순 없기 때문에 정지조건을 부여한다.&lt;/p&gt;
&lt;p&gt;이 Newton Raphson method 를 구현한 R code 는 아래와 같다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.academia.edu/7031789/Newton-Raphson_Method_in_R&quot;&gt;Newton Raphson Method in R&lt;/a&gt; 글을 참조함&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;newton &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;function(fun, &lt;span class=&quot;dt&quot;&gt;tol =&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;1e-7&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;x0 =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;N =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;300&lt;/span&gt;){
  h &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;fl&quot;&gt;1e-7&lt;/span&gt;
  i &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
  x1 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;x0
  p &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;numeric&lt;/span&gt;(N)
  while(i &amp;lt;=&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;N){
    df.dx &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;fun&lt;/span&gt;(x0 +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;h) -&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;fun&lt;/span&gt;(x0)) /&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;h
    x1 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;(x0 -&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;fun&lt;/span&gt;(x0) /&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;df.dx))
    p[i] &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;x1
    i =&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;i&lt;span class=&quot;dv&quot;&gt;+1&lt;/span&gt;
    if(&lt;span class=&quot;kw&quot;&gt;abs&lt;/span&gt;(x1 -&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;x0) &amp;lt;&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;tol) break
    x0 =&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;x1
  }
  &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;(p[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:(i -&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)])
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;정의된 &lt;code&gt;newton()&lt;/code&gt; 함수를 이용해 &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;f&lt;/em&gt;(&lt;em&gt;x&lt;/em&gt;)=&lt;em&gt;x&lt;/em&gt;&lt;sup&gt;3&lt;/sup&gt; + 2&lt;/span&gt; 함수의 &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;f&lt;/em&gt;(&lt;em&gt;x&lt;/em&gt;)=0&lt;/span&gt; 의 해를 초기값 2 에서 찾기 시작하면&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;fun &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;function(x) x^&lt;span class=&quot;dv&quot;&gt;3+2&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;newton&lt;/span&gt;(fun, &lt;span class=&quot;dt&quot;&gt;x0 =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##  [1]  1.166667  0.287982 -7.846566 -5.241872 -3.518844 -2.399736 -1.715590
##  [8] -1.370234 -1.268564 -1.259980 -1.259921 -1.259921&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이렇게 된다.&lt;br /&gt;
&lt;code&gt;tol&lt;/code&gt; 값 보다 현시차와 이전시차값의 절대값 차이가 적을 때 정지조건에 의해서 멈추는데&lt;br /&gt;
멈추고 나서의 마지막 값이 &lt;code&gt;-1.259921&lt;/code&gt; 이며 Newton Raphson method 는 이 값을 &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;x&lt;/em&gt;&lt;sup&gt;3&lt;/sup&gt; + 2 = 0&lt;/span&gt; 의 해로 계산한다.&lt;/p&gt;
&lt;p&gt;ggplot2 로 &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;y&lt;/em&gt; = &lt;em&gt;x&lt;/em&gt;&lt;sup&gt;3&lt;/sup&gt; + 2&lt;/span&gt; 함수의 그래프를 그린 후 이터레이션 별로 어디에 수렴해 가는지 시각화 해보면 아래와 같다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;p &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;ggplot&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;data.frame&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;x =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(-&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)), &lt;span class=&quot;kw&quot;&gt;aes&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;x =&lt;/span&gt; x)) +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;stat_function&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;fun =&lt;/span&gt; fun, &lt;span class=&quot;dt&quot;&gt;color =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;blue&amp;quot;&lt;/span&gt;) +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;geom_hline&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;yintercept =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;geom_vline&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;xintercept =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)

d &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;data.frame&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;label =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;kw&quot;&gt;length&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;newton&lt;/span&gt;(fun, &lt;span class=&quot;dt&quot;&gt;x0 =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)), 
                &lt;span class=&quot;dt&quot;&gt;x =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;newton&lt;/span&gt;(fun, &lt;span class=&quot;dt&quot;&gt;x0 =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;), 
                &lt;span class=&quot;dt&quot;&gt;y =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;fun&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;newton&lt;/span&gt;(fun, &lt;span class=&quot;dt&quot;&gt;x0 =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)))

p2 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;p +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;geom_point&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; d, &lt;span class=&quot;kw&quot;&gt;aes&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;x =&lt;/span&gt; x, &lt;span class=&quot;dt&quot;&gt;y =&lt;/span&gt; y, &lt;span class=&quot;dt&quot;&gt;frame =&lt;/span&gt; label)) +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;geom_text&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; d, &lt;span class=&quot;kw&quot;&gt;aes&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;x =&lt;/span&gt; x, &lt;span class=&quot;dt&quot;&gt;y =&lt;/span&gt; y +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;label =&lt;/span&gt; label, &lt;span class=&quot;dt&quot;&gt;frame =&lt;/span&gt; label), &lt;span class=&quot;dt&quot;&gt;size =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;)

p2&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/netwon_raphson_1.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;총 12번의 반복을 통해 &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;x&lt;/em&gt; = −1.259921&lt;/span&gt; 에 가까워 지는것을 볼 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;ggplot2-에-gganimate-패키지-조합하여-시뮬레이션-시각화-하기&quot;&gt;ggplot2 에 gganimate 패키지 조합하여 시뮬레이션 시각화 하기&lt;/h2&gt;
&lt;p&gt;(개발단계로써 CRAN 에 등록되지 않은) &lt;a href=&quot;https://github.com/dgrtwo/gganimate&quot;&gt;gganimate package&lt;/a&gt;는&lt;br /&gt;
ggplot2 결과물을 프레임별로 만들어 에니메이션 그림파일을 만들어주는 재미있는 R package 이다.&lt;br /&gt;
ggplot2 문법규칙을 그대로 이용하는데 에스테틱에 &lt;code&gt;frame&lt;/code&gt; 인자를 지정하기만 하면 된다.&lt;/p&gt;
&lt;p&gt;gganimate package 설치는 &lt;code&gt;install_github()&lt;/code&gt; 를 이용한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;devtools::&lt;span class=&quot;kw&quot;&gt;install_github&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;dgrtwo/gganimate&amp;quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(gganimate)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;그리고 위에서 시각화한 &lt;code&gt;p2&lt;/code&gt; 를 재활용 한다.&lt;br /&gt;
&lt;code&gt;gganimate()&lt;/code&gt; 함수에 우선 입력해 보면&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;gganimate&lt;/span&gt;(p2)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/netwon_raphson_gif.gif&quot;&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;애니메이션 gif 가 잘 출력되는데 &lt;code&gt;p2&lt;/code&gt; 에 실은 frame 에스테틱을 미리 선언했기 때문이다.&lt;br /&gt;
입력될 ggplot 객체에 frame 에스테틱이 없을 경우 &lt;code&gt;gganimate(p2)&lt;/code&gt; 은 에러를 내며 수행되지 않는다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Error in gganimate(p2) : 
  No frame aesthetic found; cannot create animation&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;?gganimate()&lt;/code&gt; 를 실행해 다양한 옵션과 예제코드를 살펴보면 좋을 것이다.&lt;br /&gt;
gganimate package 에는 &lt;code&gt;saveVideo()&lt;/code&gt;, &lt;code&gt;saveGIF()&lt;/code&gt; 함수가 &lt;code&gt;gganimate()&lt;/code&gt; 함수에 연루되어 있으며,&lt;br /&gt;
비디오 파일을 만들거나 에니메이션 gif 파일을 만들 때 &lt;a href=&quot;http://ffmpeg.org/documentation.html&quot;&gt;ffmpeg&lt;/a&gt; 를 이용한 다양한 옵션들을 부여할 수 있음을 확인할 수 있을것이다.&lt;/p&gt;
</description>
        <pubDate>Tue, 24 Apr 2018 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/data_visualization/2018/04/24/netwon_raphson_method.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/data_visualization/2018/04/24/netwon_raphson_method.html</guid>
        
        
        <category>R</category>
        
        <category>Data_Visualization</category>
        
      </item>
    
      <item>
        <title>Docker 를 통해 Cloudera Manager 띄워보기</title>
        <description>&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://kr.cloudera.com/products/product-components/cloudera-manager.html&quot;&gt;Cloudera Manager&lt;/a&gt;(이하 CM) 실습환경을 구성하기 위해 &lt;a href=&quot;https://www.virtualbox.org/&quot;&gt;Virtual Box&lt;/a&gt; 로 CentOS 설치 및 환경설정 구성을 수차례 반복하여 힘겹게 성공 후&lt;br /&gt;
이 성공을 쉽게 재활용하기 위해 스냅샷을 저장했던 어느 날 내 맥북의 물리적 용량이 바닥이 나버렸다..&lt;br /&gt;
물리적 용량도 용량이지만 가상머신 3대를 켜 놓고 소프트웨어를 배포하는 과정 중에서 내 맥북은 한계에 도달했는지 자주 멈추어 버렸다.&lt;br /&gt;
결국은 Docker를 이용하겠어! 라는 결심과 동시에 행동으로 옮겼다.&lt;br /&gt;
약 30분&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;만에 Docker 를 통해 Cloudera Manager 을 실행시키는 데 성공했다.&lt;br /&gt;
Virtual Box 로 교재에 똑같이 따라 해서 띄우는 데는 순수하게 10시간 정도의 시행착오를 겪은 것 에 비하면 정말 순식간이었다. (물론 이런 삽질이 있었기에 Docker 에서 30분밖에 안 걸린 것일 수 있다 &lt;i class=&quot;fa fa-meh-o&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;;)&lt;/p&gt;
&lt;p&gt;필자와 같이 실습을 진행하는 분께도 온전히 30 분만에 CM 환경구성을 할 수 있도록 본 글을 통해 정리하고자 한다.&lt;br /&gt;
또한 내용들의 대부분은 &amp;quot;cloudera manager on docker&amp;quot; 라는 검색어로 구글에 검색된 글들에 기반함을 밝힌다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;(단 Datanode 를 늘리는 확장성을 고려한 실습은 이 글에서는 논외이다. 오직 CM 를 띄우고 이를 통해 할 수 있는 것들이 무엇이 있는지, 인터페이스는 어떠한지 입문자용으로써 공부를 위한 환경구성이 목적이기에 Datanode 의 선형확장까지를 고려한 실습이라면 내생각엔 Cloudera QuickStart 컨테이너를 이용한 본 글보단 VM 을 통해 실제로 Datanode 로 할당할 서버를 만들어 실습하는 것이 손에 더 잘 잡히고 직관적이며, 선형확장을 하기위한 원리와 과정 자체를 익힐 필요가 있다고 생각한다)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;필요-요건&quot;&gt;필요 요건&lt;/h2&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;Docker 설치가 되어있어야 한다.&lt;/li&gt;
&lt;li&gt;online 상태이어야 한다. (인터넷이 되어야 한다)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;분의-과정&quot;&gt;30분의 과정&lt;/h2&gt;
&lt;p&gt;Cloudera 에서는 docker container 를 통해 CM 을 띄우기 위한 &lt;a href=&quot;https://www.cloudera.com/documentation/enterprise/5-6-x/topics/quickstart_docker_container.html&quot;&gt;Cloudera QuickStart 문서&lt;/a&gt;를 제공해 주고 있다.&lt;br /&gt;
그대로 따라해 본 걸 한글화 시킨 것으로 이글을 봐도 무방하겠다.&lt;/p&gt;
&lt;h3 id=&quot;첫-번째로-터미널을-킨-후&quot;&gt;첫 번째로 터미널을 킨 후&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;docker pull cloudera/quickstart:latest&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;를 통해 Cloudera QuickStart 도커이미지 최신버전을 다운로드 한다.&lt;br /&gt;
필자의 환경에선 수십분의 시간이 걸렸으니 차분히 기다린다.&lt;br /&gt;
완료가 되었다면&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker images&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;를 실행해 Cloudera QuickStart docker image 가 준비되었는지 한번 확인해 본다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;script src=&quot;https://asciinema.org/a/177648.js&quot; id=&quot;asciicast-177648&quot; async&gt;&lt;/script&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;cloudera/quickstart 이미지의 ID 는 4239cd2958c6, 이미지 용량은 6.34Gb 임을 확인할 수 있다.&lt;/p&gt;
&lt;h3 id=&quot;두-번째로-컨테이너를-실행한다&quot;&gt;두 번째로 컨테이너를 실행한다&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;docker run --hostname=quickstart.cloudera --privileged=true -t -i [OPTIONS] [IMAGE] /usr/bin/docker-quickstart&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;에서 &lt;code&gt;[OPTIONS]&lt;/code&gt; 부분은 &lt;code&gt;-p 80:80 -p 7180:7180 -p 8888:8888&lt;/code&gt; 로 입력해 호스트간의 포트번호 80, 7180, 8888 을 열어 놓는다.&lt;br /&gt;
&lt;code&gt;[IMAGE]&lt;/code&gt; 부분은 이미지 ID 인 &lt;code&gt;4239cd2958c6&lt;/code&gt; 를 입력한다. 즉&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run --hostname=quickstart.cloudera --privileged=true -t -i -p 80:80 -p 7180:7180 -p 8888:8888 4239cd2958c6 /usr/bin/docker-quickstart&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;를 터미널에서 실행한다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;script src=&quot;https://asciinema.org/a/177651.js&quot; id=&quot;asciicast-177651&quot; async&gt;&lt;/script&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;이후 localhost 의 80번 포트로 접속&lt;a href=&quot;#fn2&quot; class=&quot;footnoteRef&quot; id=&quot;fnref2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;을 웹브라우저에서 해보면 &amp;quot;Welcome to Your Cloudera QuickStart VM!&amp;quot; page 가 반기게 되며, 8888번 포트로는 Hue가 뜨는것을 볼 수 있다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/docker_cm05.png&quot;&gt;
&lt;/center&gt;
&lt;br&gt; &lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/docker_cm06.png&quot;&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;그런데 그것보단 내 관심사는 7180번 포트인데 CM 이 디폴트로 사용하는 포트번호이다.&lt;br /&gt;
하지만 접속을 해보면 이렇게 뜬다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/docker_cm01.png&quot;&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;clouder quickstart 컨테이너는 기본적으로 CM 을 같이 실행하지 않는다고 한다. 따라서&lt;/p&gt;
&lt;h2 id=&quot;세-번째로-clouder-quickstart-컨테이너상에서-homeclouderacloudera-manager---express-명령을-입력하여-cm-을-실행시킨다&quot;&gt;세 번째로 clouder quickstart 컨테이너상에서 &lt;code&gt;/home/cloudera/cloudera-manager --express&lt;/code&gt; 명령을 입력하여 CM 을 실행시킨다&lt;/h2&gt;
&lt;p&gt;Cloudera QuickStart 컨테이너의 bash 에서 아직 빠져나오지 않았다면 &lt;code&gt;/home/cloudera/cloudera-manager --express&lt;/code&gt; 를 그대로 실행시키면 되고&lt;/p&gt;
&lt;p&gt;컨테이너 밖으로 빠져나온 호스트 상의 상태라면 &lt;code&gt;docker ps&lt;/code&gt; 를 통해 실행되고 있는 clouder quickstart 컨테이너 ID 를 알아낸 후 docker 의 exec 명령을 이처럼 이용해도 된다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker exec [CONTAINER_ID] /home/cloudera/cloudera-manager --express&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;[CONTAINER_ID]&lt;/code&gt; 이 부분을 clouder quickstart 컨테이너 ID 를 입력하면 된다.&lt;br /&gt;
여하튼 그 결과는 아래와 같이 진행된다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;script src=&quot;https://asciinema.org/a/177654.js&quot; id=&quot;asciicast-177654&quot; async&gt;&lt;/script&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;약간의 시간이 걸린다.&lt;br /&gt;
접속 계정과 비밀번호는 cloudera 이다라는 문구가 뜨면 로컬호스트의 7180 포트로 접속시 CM 로그인 화면을 볼 수 있게 된다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/docker_cm02.png&quot;&gt;
&lt;/center&gt;
&lt;br&gt; &lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/docker_cm03.png&quot;&gt;
&lt;/center&gt;
&lt;br&gt; &lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/docker_cm04.png&quot;&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://youtu.be/elXTmZbNNmE&quot;&gt;Cloudera QuickStart - Installation Using Docker Container on Ubuntu - Part 1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://youtu.be/mqFizIPJl1c&quot;&gt;Cloudera QuickStart - Starting Cloudera Manager on already running Docker Container - Part 2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;이 30분 중에서도 docker image 를 pull(다운로드) 하는 데에 20분 정도가 걸렸으므로 10분의 고민만 필요했다고 볼 수 있다&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn2&quot;&gt;&lt;p&gt;&lt;code&gt;http://127.0.0.1:80/&lt;/code&gt; 주소로 접속&lt;a href=&quot;#fnref2&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Sun, 22 Apr 2018 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/docker/mac/opensource_tool/2018/04/22/docker_CM.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/docker/mac/opensource_tool/2018/04/22/docker_CM.html</guid>
        
        
        <category>Docker</category>
        
        <category>Mac</category>
        
        <category>OpenSource_Tool</category>
        
      </item>
    
      <item>
        <title>Mac OS X 에서 hosts 를 추가하려면?</title>
        <description>&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;최근 &lt;a href=&quot;http://kr.cloudera.com/products/product-components/cloudera-manager.html&quot;&gt;Cloudera Manager&lt;/a&gt;를 사용해 보기 위하여 &lt;a href=&quot;https://www.virtualbox.org/&quot;&gt;Virtual Box&lt;/a&gt;를 통해 가상머신들을 준비 후 CDH(Cloudera Distribution Hadoop)를 이용해 Hadoop 및 빅데이터 소프트웨어를 배포 ・ 설치를 진행중이다.&lt;br /&gt;
그 과정중 호스트에서 가상머신에 돌아가고 있는 클라우데라 웹 클라이언트 접속을 시도하면 되는데&lt;br /&gt;
그 전에 로컬상 가상머신의 접속이 IP address 뿐만 아니라 도메인 주소로도 원활하도록 호스트를 등록해야 하는 과정이 필요했다.&lt;/p&gt;
&lt;p&gt;참고하는 교재&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;에선 윈도우를 기준으로 설명하고 있어서 Mac OS X 에서는 어떻게 하는지 궁금했는데&lt;br /&gt;
찾아보니 방법은 아래와 같았다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;script src=&quot;https://asciinema.org/a/176946.js&quot; id=&quot;asciicast-176946&quot; async&gt;&lt;/script&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;이처럼 Mac OS X 에서 hosts 정보를 가지고 있는 파일은 &lt;code&gt;/private/etc/hosts&lt;/code&gt; 이다.&lt;br /&gt;
이쪽에 등록, 수정하고 싶은 host 에 대한 정보를 편집한 후 재부팅(&lt;code&gt;reboot&lt;/code&gt;) 하면 된다.&lt;/p&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;&lt;a href=&quot;http://book.naver.com/bookdb/book_detail.nhn?bid=12545645&quot;&gt;실무로 배우는 빅데이터 기술 - 김강원 저&lt;/a&gt;&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Wed, 18 Apr 2018 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/mac/2018/04/18/mac_hosts.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/mac/2018/04/18/mac_hosts.html</guid>
        
        
        <category>Mac</category>
        
      </item>
    
      <item>
        <title>R에서 sp package 의 proj4string(), spTransform() 함수를 이용한 좌표계 변환 예제</title>
        <description>&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;GIS 기반의 프로젝트를 수행중에 있는 어느 날&lt;br /&gt;
어떤 특정한 위경도 좌표가 입력될 때 대한민국의 시군구 중 어디인지를 알려주는 함수를 필요로 하게 되었다.&lt;br /&gt;
API 기반의 서비스를 이용하지 않고 순수 로직에 의해 만드는것을 목표로 하고 있어 다양한 요소에 개발을 필요로 하고 있는데&lt;br /&gt;
큼지막한 요소로는 2가지 미션들이 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;좌표계의 통일을 위한 변환방법&lt;/li&gt;
&lt;li&gt;특정 (x, y) 좌표가 시군구 경계에 해당하는 컨백스홀 안에있는지 밖에있는지를 판단하는 논리 - &lt;em&gt;추후 포스팅 예정&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 중 첫번째 &lt;strong&gt;좌표계의 통일을 위한 변환방법&lt;/strong&gt;을 R의 sp 패키지를 기반으로 알아보고자 한다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/proj4string1.jpg&quot;&gt;
&lt;/center&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.biz-gis.com/index.php?mid=pds&amp;amp;document_srl=67326&quot;&gt;우리나라에서 사용하는 좌표계의 종류&lt;/a&gt; - 출처 : biz-gis.com&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;del&gt;
복잡복잡..
&lt;/del&gt;
&lt;p&gt;GIS에 대해서 1도 몰랐던 시절 좌표계의 종류가 이렇게 많은지 모르고 있었다.&lt;br /&gt;
더군다나 실제 GIS 데이터들은 이런 좌표단위들을 다양하게 사용하고 있어서 혼란이 많았다.&lt;/p&gt;
&lt;p&gt;예를 들면 이렇다.&lt;br /&gt;
서울의 광화문 중앙의 좌표를 &lt;code&gt;(위도,경도)&lt;/code&gt;&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; 라고 할 때&lt;br /&gt;
A 테이블에선 &lt;code&gt;(37.5760336, 126.9769142)&lt;/code&gt; 로 사용중이고&lt;br /&gt;
B 테이블에선 &lt;code&gt;(37.5749854, 126.9746067)&lt;/code&gt; 로 관리가 되고 있다.&lt;br /&gt;
미세한 차이로 보이지만 실제로 이 위경도값을 그대로 구글지도에 입력하여 찾아보면 멀리 떨어진 지점이다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/proj4string3.png&quot;&gt;
&lt;/center&gt;
&lt;blockquote&gt;
&lt;p&gt;Google Map 에서 A 테이블의 &lt;code&gt;(37.5760336, 126.9769142)&lt;/code&gt; 를 찍어 보았을 때&lt;/p&gt;
&lt;/blockquote&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/proj4string4.png&quot;&gt;
&lt;/center&gt;
&lt;blockquote&gt;
&lt;p&gt;Google Map 에서 B 테이블의 &lt;code&gt;(37.5749854, 126.9746067)&lt;/code&gt; 를 찍어 보았을 때&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이런 예제처럼 A테이블 정보와 B테이블의 정보를 매쉬업 하기 위해선 단위를 통일하여야 매쉬업 할 때 왜곡되어지지 않는다.&lt;br /&gt;
자연스럽게 A, B중 하나는 좌표계를 변환할 필요가 생기는데 이 시점에서&lt;br /&gt;
R에서 sp package 를 이용한 좌표계 변환 성공예제를 정리하고 공유하고자 한다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;행정경계-자료-획득---시군구-별-경계&quot;&gt;행정경계 자료 획득 - 시군구 별 경계&lt;/h2&gt;
&lt;p&gt;시군구를 구분짓는 경계에 대한 데이터 베이스가 필요했는데&lt;br /&gt;
이 데이터는 구했지만 여기서 부터 문제가 있었다.&lt;br /&gt;
필자에게 익숙한 경위도 지리좌표계가 아닌 다른 단위의 좌표계로 관리가 되고 있다는 점이었다.&lt;br /&gt;
문제의 시군구별 행정경계 데이터는 http://www.biz-gis.com/GISDB/ 에서 제공하고 있다.&lt;br /&gt;
다운로드 하는 방법은 http://www.biz-gis.com/GISDB/ 로 들어간 후 &amp;quot;행정경계-시군구&amp;quot; 항목을 클릭하여 다운로드 버튼을 누르면 된다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/proj4string2.png&quot;&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&amp;quot;vADM2_TM.zip&amp;quot; 이라는 압축파일이 다운로드가 되고, 압축을 풀면 아래와 같은 파일들이 떨어진다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;v시군구_TM.dbf&amp;quot; &amp;quot;v시군구_TM.sbn&amp;quot; &amp;quot;v시군구_TM.sbx&amp;quot; &amp;quot;v시군구_TM.shp&amp;quot;
## [5] &amp;quot;v시군구_TM.shx&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;행정경계정보가 담긴 이 5개 파일을 R에서 불러와 분석을 하기 위해 &lt;code&gt;rgdal::readOGR()&lt;/code&gt; 함수를 이용한다. &lt;a href=&quot;#fn2&quot; class=&quot;footnoteRef&quot; id=&quot;fnref2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(rgdal)
d &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;readOGR&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;data&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## OGR data source with driver: ESRI Shapefile 
## Source: &amp;quot;/Users/lovetoken/Dropbox/02_Study/01_Statistic/31_R/03_Posting/02_Package/sp/proj4string/data&amp;quot;, layer: &amp;quot;v시군구_TM&amp;quot;
## with 232 features
## It has 4 fields&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;readOGR()&lt;/code&gt; 함수의 사용법은 .shp 포맷을 포함한 기하정보들을 모두 가진 디렉토리를 첫번째 인자에 입력하면 된다.&lt;br /&gt;
만약 입력한 디렉토리 안에 &amp;quot;vADM2_TM.zip&amp;quot; 파일을 압축해제한 5개 파일 외에 다른 레이어 파일들이 있을때는 무엇을 기준으로 읽어들일지 알 수 없으므로 두번째 &lt;code&gt;layer&lt;/code&gt; 인자에 명시하여 알려 줄 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;d &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;readOGR&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;data&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;v시군구_TM&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;readOGR()&lt;/code&gt; 함수를 통해 불러온 객체 &lt;code&gt;d&lt;/code&gt; 를 &lt;code&gt;axes = T&lt;/code&gt; 를 통해 축을 표현시켜 무작정 플롯팅을 시켜보면 아래와 같이 뜬다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(d, &lt;span class=&quot;dt&quot;&gt;axes =&lt;/span&gt; T)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/proj4string5.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;시군구 경계가 구분되어 있는 대한민국 지도가 그려지는 것을 확인할 수 있다.&lt;br /&gt;
&lt;code&gt;plot()&lt;/code&gt; 함수를 실행할 때 x, y 점들을 포인팅 하는 원리로써 이런 지도가 그려지는것은&lt;br /&gt;
&lt;code&gt;d&lt;/code&gt; 객체 안에 경계선에 대해서 수많은 경계점들의 좌표정보를 가지고 있기 때문이란 것을 추측할 수 있고&lt;br /&gt;
직접 까보면 그 실체를 알 수 있게 된다. &lt;code&gt;str(d)&lt;/code&gt; 출력의 일부(tail)를 확인해 보면&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;str&lt;/span&gt;(d)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;  .. .. .. .. ..$ :Formal class &amp;#39;Polygon&amp;#39; [package &amp;quot;sp&amp;quot;] with 5 slots
  .. .. .. .. .. .. ..@ labpt  : num [1:2] 179310 418281
  .. .. .. .. .. .. ..@ area   : num 4775
  .. .. .. .. .. .. ..@ hole   : logi FALSE
  .. .. .. .. .. .. ..@ ringDir: int 1
  .. .. .. .. .. .. ..@ coords : num [1:26, 1:2] 179312 179320 179328 179337 179341 ...
  .. .. .. .. ..$ :Formal class &amp;#39;Polygon&amp;#39; [package &amp;quot;sp&amp;quot;] with 5 slots
  .. .. .. .. .. .. ..@ labpt  : num [1:2] 179400 418308
  .. .. .. .. .. .. ..@ area   : num 1161
  .. .. .. .. .. .. ..@ hole   : logi FALSE
  .. .. .. .. .. .. ..@ ringDir: int 1
  .. .. .. .. .. .. ..@ coords : num [1:24, 1:2] 179420 179419 179420 179414 179410 ...
  .. .. .. .. ..$ :Formal class &amp;#39;Polygon&amp;#39; [package &amp;quot;sp&amp;quot;] with 5 slots
  .. .. .. .. .. .. ..@ labpt  : num [1:2] 179184 418418
  .. .. .. .. .. .. ..@ area   : num 3849
  .. .. .. .. .. .. ..@ hole   : logi FALSE
  .. .. .. .. .. .. ..@ ringDir: int 1
  .. .. .. .. .. .. ..@ coords : num [1:25, 1:2] 179181 179168 179160 179159 179152 ...
  .. .. .. .. ..$ :Formal class &amp;#39;Polygon&amp;#39; [package &amp;quot;sp&amp;quot;] with 5 slots
  .. .. .. .. .. .. ..@ labpt  : num [1:2] 176061 418565
  .. .. .. .. .. .. ..@ area   : num 9792
  .. .. .. .. .. .. ..@ hole   : logi FALSE
  .. .. .. .. .. .. ..@ ringDir: int 1
  .. .. .. .. .. .. ..@ coords : num [1:39, 1:2] 176124 176126 176117 176108 176099 ...
  .. .. .. .. ..$ :Formal class &amp;#39;Polygon&amp;#39; [package &amp;quot;sp&amp;quot;] with 5 slots
  .. .. .. .. .. .. ..@ labpt  : num [1:2] 178754 418658
  .. .. .. .. .. .. ..@ area   : num 9316
  .. .. .. .. .. .. ..@ hole   : logi FALSE
  .. .. .. .. .. .. ..@ ringDir: int 1
  .. .. .. .. .. .. ..@ coords : num [1:37, 1:2] 178730 178736 178751 178760 178761 ...
  .. .. .. .. ..$ :Formal class &amp;#39;Polygon&amp;#39; [package &amp;quot;sp&amp;quot;] with 5 slots
  .. .. .. .. .. .. ..@ labpt  : num [1:2] 171224 419615
  .. .. .. .. .. .. ..@ area   : num 1090438
  .. .. .. .. .. .. ..@ hole   : logi FALSE
  .. .. .. .. .. .. ..@ ringDir: int 1
  .. .. .. .. .. .. ..@ coords : num [1:31, 1:2] 170917 170743 170551 170426 170368 ...
  .. .. .. .. ..$ :Formal class &amp;#39;Polygon&amp;#39; [package &amp;quot;sp&amp;quot;] with 5 slots
  .. .. .. .. .. .. ..@ labpt  : num [1:2] 176879 420421
  .. .. .. .. .. .. ..@ area   : num 558583
  .. .. .. .. .. .. ..@ hole   : logi FALSE
  .. .. .. .. .. .. ..@ ringDir: int 1
  .. .. .. .. .. .. ..@ coords : num [1:47, 1:2] 177012 177056 177119 177237 177352 ...
  .. .. .. .. ..$ :Formal class &amp;#39;Polygon&amp;#39; [package &amp;quot;sp&amp;quot;] with 5 slots
  .. .. .. .. .. .. ..@ labpt  : num [1:2] 188820 407056
  .. .. .. .. .. .. ..@ area   : num 692251527
  .. .. .. .. .. .. ..@ hole   : logi FALSE
  .. .. .. .. .. .. ..@ ringDir: int 1
  .. .. .. .. .. .. ..@ coords : num [1:5345, 1:2] 191196 191278 191338 191358 191399 ...
  .. .. .. ..@ plotOrder: int [1:29] 29 14 1 27 28 17 20 7 16 2 ...
  .. .. .. ..@ labpt    : num [1:2] 188820 407056
  .. .. .. ..@ ID       : chr &amp;quot;97&amp;quot;
  .. .. .. ..@ area     : num 697667674
  .. ..$ :Formal class &amp;#39;Polygons&amp;#39; [package &amp;quot;sp&amp;quot;] with 5 slots
  .. .. .. ..@ Polygons :List of 1
  .. .. .. .. ..$ :Formal class &amp;#39;Polygon&amp;#39; [package &amp;quot;sp&amp;quot;] with 5 slots
  .. .. .. .. .. .. ..@ labpt  : num [1:2] 226596 433472
  .. .. .. .. .. .. ..@ area   : num 428700798
  .. .. .. .. .. .. ..@ hole   : logi FALSE
  .. .. .. .. .. .. ..@ ringDir: int 1
  .. .. .. .. .. .. ..@ coords : num [1:5130, 1:2] 233437 233541 233595 233829 233846 ...
  .. .. .. ..@ plotOrder: int 1
  .. .. .. ..@ labpt    : num [1:2] 226596 433472
  .. .. .. ..@ ID       : chr &amp;quot;98&amp;quot;
  .. .. .. ..@ area     : num 428700798
  .. .. [list output truncated]
  ..@ plotOrder  : int [1:232] 113 121 191 116 189 195 117 208 112 199 ...
  ..@ bbox       : num [1:2, 1:2] -11603 -42102 548505 569052
  .. ..- attr(*, &amp;quot;dimnames&amp;quot;)=List of 2
  .. .. ..$ : chr [1:2] &amp;quot;x&amp;quot; &amp;quot;y&amp;quot;
  .. .. ..$ : chr [1:2] &amp;quot;min&amp;quot; &amp;quot;max&amp;quot;
  ..@ proj4string:Formal class &amp;#39;CRS&amp;#39; [package &amp;quot;sp&amp;quot;] with 1 slot
  .. .. ..@ projargs: chr NA&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;quot;sp&amp;quot; 라는 클래스로 관리되는 &lt;code&gt;d&lt;/code&gt; 객체 안에는 coords 라는 속성에 뭔지 모를 수많은 값들이 모여져서 다각형(Polygon)을 구성하게 되는 식이라 추측할 수 있다.&lt;br /&gt;
그런데 플롯팅 된 지도의 x, y 축 단위를 우리에게 낯익은 경위도 지리 좌표계(Geographic Coordinate)로 바꾸려면 어떻게 해야할까?&lt;br /&gt;
지금의 x, y축의 수치를 보면 십만단위 범위값까지 나오는데 이는 구 형의 지구를 평면으로 펼친 후 포인팅하기위한 평면직각좌표계(Projected Coordinate)를 기준으로 측정할 때 나올 수 있는 단위라고 한다.&lt;br /&gt;
필자가 개발하려는 것은 경위도 값(ex. 37.5760336, 126.9769142)이 들어올 때 어떤 시군구에 속하는지를 맵핑하는 함수를 개발하려다 보니 지금 보는 &lt;code&gt;d&lt;/code&gt; 객체의 평면좌표계 값을 경위도 지리좌표계로 변형할 필요가 생긴 것이다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;coordinate-reference-system&quot;&gt;Coordinate Reference System&lt;/h2&gt;
&lt;p&gt;좌표변형을 위해선 두가지를 사전에 알아야 한다.&lt;br /&gt;
from Coordinate Reference System(fromCRS) 과 to Coordinate Reference System(toCRS) 이다.&lt;br /&gt;
좌표계 시스템(CRS)에 대해선 전문적인 지식들이 필요로 하지만 이에 대한 언급을 자세히 하지 않겠다.&lt;a href=&quot;#fn3&quot; class=&quot;footnoteRef&quot; id=&quot;fnref3&quot;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;&lt;br /&gt;
재량을 통해&lt;a href=&quot;#fn4&quot; class=&quot;footnoteRef&quot; id=&quot;fnref4&quot;&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt; fromCRS 를 알아낸 후 그에 맞게 약속된 문법에 맞추어 준비한다.&lt;br /&gt;
본 예제에서는 중부원점 기준 좌표로 명시되어 있어 그에 맞는 CRS 를 준비했다. 참고로 &lt;code&gt;CRS()&lt;/code&gt; 함수를 이용하여 CRS 임을 명시한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;from_crs =&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;CRS&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;+proj=tmerc +lat_0=38 +lon_0=127 +k=1 +x_0=200000 +y_0=500000 +ellps=bessel +units=m&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;문법에 대해서 간단히 아는선에서 이야기하면&lt;br /&gt;
&amp;quot;+proj&amp;quot; 은 투영방법을 명시하는 부분이고&lt;br /&gt;
&amp;quot;+lat_0&amp;quot;, &amp;quot;+lon_0&amp;quot; 은 어떤 포인트를 중심으로 투영했는지&lt;br /&gt;
&amp;quot;+k&amp;quot; 는 구의 이심률&lt;br /&gt;
&amp;quot;ellps&amp;quot; 는 타원체의 규격을 정의하는 파라미터들이라고 한다.&lt;a href=&quot;#fn5&quot; class=&quot;footnoteRef&quot; id=&quot;fnref5&quot;&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;fromCRS 를 명시했으니 toCRS 도 필요하다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;to_crs =&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;CRS&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;경위도 좌표로 바꾸기 위한 toCRS 를 알아낸 후 위처럼 명시했다. fromCRS 과 toCRS 가 준비되었으니 이제 변형만 하면된다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;좌표변형&quot;&gt;좌표변형&lt;/h2&gt;
&lt;p&gt;R의 sp package 에서 &lt;code&gt;proj4string()&lt;/code&gt;, &lt;code&gt;spTransform()&lt;/code&gt; 를 통해 좌표변형을 성공할 수 있었다.&lt;br /&gt;
우선 아까 준비한 fromCRS 정보 &lt;code&gt;from_crs&lt;/code&gt; 를 아래처럼 &lt;code&gt;d&lt;/code&gt; 객체에 반영할 것이다.&lt;br /&gt;
&lt;code&gt;d&lt;/code&gt; 는 sp class 로 coordinate reference 값을 속성으로 따로 관리하는데 &amp;quot;coord. ref.&amp;quot; 부분을 보면 이전에는 &lt;code&gt;NA&lt;/code&gt; 로 알 수 없는 상태이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;d&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## class       : SpatialPolygonsDataFrame 
## features    : 232 
## extent      : -11603.22, 548504.6, -42102, 569052  (xmin, xmax, ymin, ymax)
## coord. ref. : NA 
## variables   : 4
## names       : 광역시코드, 광역시명, 시군구코드, 시군구명 
## min values  :         11,   강원도,       1111,   가평군 
## max values  :         50, 충청북도,       5013,   횡성군&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이를 fromCRS 로 변형한다.&lt;br /&gt;
coordinate reference 값만 변형하기 위해선 &lt;code&gt;proj4string()&lt;/code&gt; 함수를 이용하면 된다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;proj4string&lt;/span&gt;(d) &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;from_crs&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;다시 &lt;code&gt;d&lt;/code&gt;를 조회해보면&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;d&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## class       : SpatialPolygonsDataFrame 
## features    : 232 
## extent      : -11603.22, 548504.6, -42102, 569052  (xmin, xmax, ymin, ymax)
## coord. ref. : +proj=tmerc +lat_0=38 +lon_0=127 +k=1 +x_0=200000 +y_0=500000 +ellps=bessel +units=m 
## variables   : 4
## names       : 광역시코드, 광역시명, 시군구코드, 시군구명 
## min values  :         11,   강원도,       1111,   가평군 
## max values  :         50, 충청북도,       5013,   횡성군&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;coordinate reference 값이 &lt;code&gt;from_crs&lt;/code&gt; 에 담겨있는 string 으로 바뀐것을 확인할 수 있다.&lt;br /&gt;
이 상태에서 &lt;code&gt;spTransform()&lt;/code&gt; 함수를 통해 toCRS 형식으로 변경한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;d2 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;spTransform&lt;/span&gt;(d, to_crs)
d2&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## class       : SpatialPolygonsDataFrame 
## features    : 232 

## extent      : 124.5918, 130.9408, 33.11139, 38.61427  (xmin, xmax, ymin, ymax)
## coord. ref. : +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0 
## variables   : 4
## names       : 광역시코드, 광역시명, 시군구코드, 시군구명 
## min values  :         11,   강원도,       1111,   가평군 
## max values  :         50, 충청북도,       5013,   횡성군&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;CRS 를 변경시킨 &lt;code&gt;d2&lt;/code&gt; 객체를 확인해 보면&lt;br /&gt;
coordinate reference 값이 &lt;code&gt;to_crs&lt;/code&gt; string 으로 바뀐것 뿐만 아니라&lt;br /&gt;
extent 에 명시된 xmin, xmax, ymin, ymax 값도 바뀐것을 눈치 챌 수 있을것이다.&lt;br /&gt;
&lt;code&gt;d2&lt;/code&gt;를 이번엔 무작정 플랏팅 해 볼까?&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(d2, &lt;span class=&quot;dt&quot;&gt;axes =&lt;/span&gt; T)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/proj4string6.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;이로써 경위도 지리좌표계로 변형된 것을 확인할 수 있다.&lt;br /&gt;
sp class 로 이루어진 GIS 테이블들을 좌표통일 후 매쉬업 할 수 있겠다는 생각이 든다.&lt;/p&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;위도와 경도 영어로는 각각 latitude, longitude 이다&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn2&quot;&gt;&lt;p&gt;&lt;code&gt;raster::shapefile()&lt;/code&gt; 를 이용하는 방법도 있다&lt;a href=&quot;#fnref2&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn3&quot;&gt;&lt;p&gt;국내는 TM(Transverse Mercator)좌표계를 대표적으로 사용중&lt;a href=&quot;#fnref3&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn4&quot;&gt;&lt;p&gt;기하정보데이터를 얻을 때 출처를 꼼꼼이 읽어보거나, 그것이 어려울 경우 관리자에게 직접 문의하는 등의... 메타정보를 얻는것이 가장 큰 수고를 필요로 하는듯 하다 😅&lt;a href=&quot;#fnref4&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn5&quot;&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Gi-Seop&quot;&gt;GIS 를 알고계신분&lt;/a&gt;의 도움을 통해 알게 되었다 Thank you&lt;a href=&quot;#fnref5&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Sun, 15 Apr 2018 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/data_visualization/2018/04/15/sp_proj4string_spTransform.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/data_visualization/2018/04/15/sp_proj4string_spTransform.html</guid>
        
        
        <category>R</category>
        
        <category>Data_Visualization</category>
        
      </item>
    
      <item>
        <title>R에서 Package란?</title>
        <description>&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;R은 다양한 사용자들의 희망으로 생겨나는 많은 특수한 목적의 로직들과 코드들의 집합을 패키지(Package)라는 형태로 배포한다.&lt;br /&gt;
개발자 및 실무진뿐만 아니라 일반 사용자들도 특정 주제에 대하여 완성도가 높고 설계가 잘된 코드들을 제 3자가 이용하기 쉽도록 패키지란 형태로 배포할 수 있으며, 이 배포가 용이하도록 만든 시스템은 R의 아주 중요한 역할을 하고 있다고 본다.&lt;/p&gt;
&lt;p&gt;패키지 안에는 활용 가능한 함수(function)들과 재현가능연구를 위한 빌트인 예제 데이터셋 객체, 패키지 사용 방법에 대한 개요 및 설명서(Vignette), 함수 도움말(R document) 파일들로 보통 구성되는 편이다.&lt;/p&gt;
&lt;p&gt;패키지의 공유는 &lt;a href=&quot;https://cran.r-project.org/&quot;&gt;CRAN(The Comprehensive R Archive Network)&lt;/a&gt; 을 통해 공유되고 있고,&lt;br /&gt;
현존하는 패키지만 (18년 4월 기준) 12,400개가 있다.&lt;br /&gt;
어떤 패키지들이 CRAN 에 등재되어 있는지 확인하고 싶다면 &lt;code&gt;available.packages()&lt;/code&gt; 함수를 통해 확인이 가능하다.&lt;br /&gt;
이를 통해 확인한 패키지 중 설치를 희망하는 패키지를 발견하였다면, &lt;code&gt;install.packages()&lt;/code&gt; 함수 안에 패키지명을 넣고 실행해 그 패키지를 설치할 수 있다.&lt;br /&gt;
기본적으론 CRAN 서버에서 해당하는 패키지를 찾은 후 다운로드 및 설치를 시작하게 되므로 인터넷 연결이 되어있어야 한다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;패키지-설치방법&quot;&gt;패키지 설치방법&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;install.packages()&lt;/code&gt; 함수를 사용하여 설치하는것이 가장 쉬운 기본 방법이다.&lt;br /&gt;
예를 들어 데이터 시각화에서 대중적으로 이용하는 &lt;a href=&quot;http://ggplot2.tidyverse.org/&quot;&gt;ggplot2&lt;/a&gt; 라는 패키지가 있는데,&lt;br /&gt;
이 패키지를 설치하고 싶다면&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;install.packages&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;ggplot2&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;를 실행하게 되면 아래의 로그와 같이 다운로드 및 설치가 진행된다.&lt;/p&gt;
&lt;center&gt;
&lt;script src=&quot;https://asciinema.org/a/174870.js&quot; id=&quot;asciicast-174870&quot; async&gt;&lt;/script&gt;
&lt;/center&gt;
&lt;p&gt;R studio 에선 설치아이콘을 이용해 설치하는것도 가능하지만&lt;br /&gt;
결국 &lt;code&gt;install.packages(&amp;quot;ggplot2&amp;quot;)&lt;/code&gt; 명령을 실행하는 것과 똑같다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/r_package.png&quot;&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;설치 도입 부분에 CRAN 미러를 선택해 달라는 것은&lt;br /&gt;
&lt;a href=&quot;https://cran.r-project.org/mirrors.html&quot;&gt;수많은 미러 아카이브&lt;/a&gt; 중 어떤 서버를 이용해 다운로드 할 것인지 묻는 것인데, 정확한 버전관리를 필요로 하는 게 아닌 이상&lt;br /&gt;
취향에 맞게 대한민국에 해당되는 미러사이트를 이용하든지 맨 위에 있는 &amp;quot;0-Cloud&amp;quot; 를 선택하고 설치를 진행하자.&lt;/p&gt;
&lt;p&gt;더해서&lt;br /&gt;
설치 과정의 로그 중 에러 및 경고메세지가 출력되면서 설치가 중단될 변수가 있다.&lt;br /&gt;
그때의 로그를 잘 살펴보면 필요로 하는 디펜던시 문제일 경우가 대부분일 것이다.&lt;br /&gt;
이땐 디펜던시에 걸린, 필요로 하는 소프트웨어를 설치 후 패키지 설치를 다시 진행해 보자.&lt;br /&gt;
그래도 문제가 해결이 안될 땐 에러 로그를 그대로 복사해 구글에서 검색되는 Stackoverflow 들의 질문과 답변을 보고 문제를 직접 해결해 보는것이 현명한 방법일 것이다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;설치된-패키지를-사용하기-위한-방법&quot;&gt;설치된 패키지를 사용하기 위한 방법&lt;/h2&gt;
&lt;p&gt;설치가 되어있는 패키지를 실제로 사용하기 위해선 R 세션으로 로드하는 과정이 필요하다.&lt;br /&gt;
마치 패키지란 상자에 담겨있는 내용물을 R에서 사용할 수 있도록 펼쳐놓는 과정으로 필자는 비유하는 편인데&lt;br /&gt;
펼쳐놓는(로드하는) 방법은 대표적으로 &lt;code&gt;library()&lt;/code&gt;, &lt;code&gt;require()&lt;/code&gt; 함수를 이용하는 방법이다.&lt;br /&gt;
관습적으론 &lt;code&gt;library()&lt;/code&gt; 를 R User 는 더 많이 이용하는 편이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(ggplot2)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위의 코드를 실행하게 되면 ggplot2 패키지에 있는 여러 가지 함수들을 사용할 수 있게 된다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;특정-패키지를-공부하고-사용할-때&quot;&gt;특정 패키지를 공부하고 사용할 때&lt;/h2&gt;
&lt;p&gt;패키지는 특정 주제나 도메인에 대해서 특별한 목적으로 만들어진다.&lt;br /&gt;
위에서 예로 들은 ggplot2 패키지의 경우 그래프를 그릴 수 있는 또다른 시스템이며 광범위한 세계이다.&lt;br /&gt;
&amp;quot;ggplot2&amp;quot; 패키지를 로드하는 순간 활성화되는 함수들이 정말 많이 있고(100개 이상) 이를 제대로 활용하기 위해선 이 패키지만의 미니언어를 구사해야 한다.&lt;br /&gt;
즉 패키지라는 상자를 까는 순간 정체를 알 수 없는, 사용법을 모르는 수많은 부품이 펼쳐진 상태로 비유할 수 있다.&lt;br /&gt;
이 도구 모두를 아는 것은 많은 시간이 걸리고, 무엇보다 우리가 현재 필요로 하지 않을 도구일 가능성이 높다.&lt;br /&gt;
따라서 특정 패키지 안에서도 핵심적인 함수와 대표적인 기능들을 추린 후 단계적으로 이해해야 할 필요가 있다.&lt;br /&gt;
이 대표적인 함수를 조금씩 조금씩 이용해 보면서 연계되는 부수적인 함수들의 기능들을 체감하는 방식이 패키지를 처음 만나게 될 때의 좋은 전략이라고 생각하며,&lt;br /&gt;
기능이 많고 부피가 큰 패키지일수록 패키지 개발자는 이러한 점을 고려하여 설계했을 가능성이 높다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://r-pkgs.had.co.nz/intro.html&quot;&gt;R packages by Hadley Wickham&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 07 Apr 2018 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2018/04/07/Rpackage.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2018/04/07/Rpackage.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>R에서 조건화 그래프(Conditioning plot) 를 출력하기 위한 ggplot2::faect_wrap(), coplot() 함수에 대하여</title>
        <description>&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;R에서 기본 그래픽스로 제공하는 도구 중&lt;br /&gt;
요인별로 구분된 산점도를 그릴때 심플하게 이용할 수 있는 &lt;code&gt;coplot()&lt;/code&gt; 함수와 ggplot2 package 에서 &lt;code&gt;coplot()&lt;/code&gt; 함수와 비슷한 성격의 &lt;code&gt;faect_wrap()&lt;/code&gt; 함수에 대해 알아보고자 한다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;coplot()&lt;/code&gt; 도움말을 보면 &amp;quot;Conditioning plots&amp;quot; 즉 &amp;quot;조건화 그래프&amp;quot; 라는 제목으로 사용법이 설명되어 있다.&lt;br /&gt;
조건화 그래프는 언제 필요로 할까?&lt;/p&gt;
&lt;p&gt;요인이 많은 데이터들을 산점도를 이용하여 시각화 할 때 분간이 쉽지 않아 요인별 특색을 찾기가 어려운 경우가 있다.&lt;br /&gt;
예시를 통해 설명을 이어가겠다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;ggplot2-package-에서의-faect_wrap-faect_grid-함수&quot;&gt;ggplot2 package 에서의 &lt;code&gt;faect_wrap()&lt;/code&gt;, &lt;code&gt;faect_grid()&lt;/code&gt; 함수&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;p1 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;ggplot&lt;/span&gt;(diamonds, &lt;span class=&quot;kw&quot;&gt;aes&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;x =&lt;/span&gt; carat, &lt;span class=&quot;dt&quot;&gt;y =&lt;/span&gt; price, &lt;span class=&quot;dt&quot;&gt;color =&lt;/span&gt; cut)) +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;geom_point&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;alpha =&lt;/span&gt; .&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;) +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;labs&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;color =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;&amp;quot;&lt;/span&gt;)

p1&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/coplot1.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;위 산점도를 간단히 설명하면&lt;br /&gt;
세공 상태별 다이아몬드의 가격과, 캐럿(다이아몬드의 무게)의 산점도를 &lt;code&gt;ggplot2::daimonds&lt;/code&gt; 데이터셋을 이용해 출력한 결과이다.&lt;br /&gt;
결과물만을 보았을 때 세공 상태별 가격과, 캐럿의 분포를 뚜렷하게 확인 하기가 쉽지 않다.&lt;br /&gt;
종류가 5가지나 되고 데이터의 수도 많아지면서 난해하진 이 그래프는 캐럿과 가격이 정비례한다는 정보는 인지하기 쉬우나, 세공상태별로 특색의 차이를 인지하기는 매우 어렵다.&lt;/p&gt;
&lt;p&gt;세공상태별로의 특색을 눈으로 확인하고 싶다면 아래처럼 요인별로 산점도를 따로 나누는 것도 좋은 방법일 것이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;p1 +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;facet_wrap&lt;/span&gt;(~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;cut, &lt;span class=&quot;dt&quot;&gt;nrow =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/coplot2.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;첫번째 그래프에서는 알기 쉽지 않던 요인별 분포를 적나라 하게 확인할 수 있게 된다.&lt;br /&gt;
가공상태가 좋지 않은 Fair 군의 다이아몬드 가격분포가 다른 군의 분포와 차이가 조금 있다는것을 첫번째 그래프로는 파악할 수 없었을 것이다.&lt;/p&gt;
&lt;p&gt;요인별로 패널을 나누어 시각화 하는 스킬들은 도구별로 방법은 다르더라도 기본적으로 제공하는 편이며&lt;br /&gt;
위의 예시인 ggplot2 package 에서는 &lt;code&gt;faect_wrap()&lt;/code&gt;, &lt;code&gt;faect_grid()&lt;/code&gt; 함수등을 이용하여 구현이 가능하다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;coplot-함수&quot;&gt;&lt;code&gt;coplot()&lt;/code&gt; 함수&lt;/h2&gt;
&lt;p&gt;ggplot2 package 가 아닌 기본 그래픽스에서 조건화 그래프를 그리려면 아래처럼 &lt;code&gt;coplot()&lt;/code&gt; 함수를 이용하여 간단하게 볼 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;coplot&lt;/span&gt;(price ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;carat |&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;cut, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; diamonds)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/coplot3.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;수학에서 조건(given) 을 &amp;quot;bar&amp;quot;(|) 로 표기하는것을 생각하고 formula 를 작성해 이용하면 되겠다.&lt;/p&gt;
</description>
        <pubDate>Mon, 02 Apr 2018 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/data_visualization/2018/04/02/coplot.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/data_visualization/2018/04/02/coplot.html</guid>
        
        
        <category>R</category>
        
        <category>Data_Visualization</category>
        
      </item>
    
      <item>
        <title>Rmarkdown + Shiny + flexdashboard package 의 조합을 통한 대쉬보드 만들기 (네이버 연관검색어를 예제로)</title>
        <description>&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;최근 &lt;a href=&quot;https://lovetoken.gitbooks.io/r-dev-team-open-seminar/content/&quot;&gt;R dev team&lt;/a&gt; 과 세미나를 통해 자발적인 분석 도전과제를 만들고 코워킹을 하고 있다.&lt;br /&gt;
도전과제 중 첫 번째로 나온 결과물이 &lt;a href=&quot;https://lovetoken.gitbooks.io/r-dev-team-open-seminar/content/b3c4-c804-acfc-c81c/b124-c774-bc84-c5f0-ad00-ac80-c0c9-c5b4-cd94-cd9c-c800-c7a5-d504-b85c-adf8-b7a8-b9cc-b4e4-ae30.html&quot;&gt;네이버 연관검색어 추출 프로그램&lt;/a&gt;이다.&lt;br /&gt;
패키지화 하여 한 개의 함수만으로 연관검색어의 결과를 저장하고 표출하며 시각화하였다.&lt;br /&gt;
이어서 R을 모르는 타인에게도 우리가 쉽게 사용토록 해 보고자 shiny application을 만들어 보기로 하였다.&lt;/p&gt;
&lt;p&gt;필자는 정석적인 Shiny app 개발 방법보단 Rmarkdown 과 &lt;a href=&quot;https://rmarkdown.rstudio.com/flexdashboard/&quot;&gt;flexdashboard package&lt;/a&gt;를 조합하여 사용하면&lt;br /&gt;
대쉬보드를 손쉽게 만들 수 있고&lt;br /&gt;
대쉬보드의 특성상 결과물을 최대한 심플하게 만들려 노력할 것이기 때문에&lt;br /&gt;
자연스럽게 개발량도 줄어들 것으로 생각했다.&lt;/p&gt;
&lt;p&gt;개발량이 줄어들면 협업이 쉬워지고 진입장벽도 낮아지기 때문에 초심자와 제 3자에게 흥미를 유도할 수 있을 거라 기대하며&lt;br /&gt;
아래와 같은 영상을 만들어 보았다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;center&gt;
&lt;iframe width=&quot;90%&quot; height=&quot;400&quot; src=&quot;https://www.youtube.com/embed/UKw1YxQRPes&quot; frameborder=&quot;0&quot; allow=&quot;autoplay; encrypted-media&quot; allowfullscreen&gt;
&lt;/iframe&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt; 참고로 R dev team 은 성과물들을 R code 로 남기려 하고 있고 이를 &lt;a href=&quot;https://github.com/lovetoken/rdevteam&quot;&gt;rdevteam 패키지&lt;/a&gt;로 관리하려 하고 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(devtools)
&lt;span class=&quot;kw&quot;&gt;install_github&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;lovetoken/rdevteam&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;를 통해서 설치가 가능하며&lt;br /&gt;
현재 이를 설치하면 영상에 있는 &lt;code&gt;naverRelation()&lt;/code&gt; 함수를 이용할 수 있고&lt;br /&gt;
그대로 재현할 수 있을 것이다.&lt;/p&gt;
&lt;p&gt;영상에서 시연되는 코드의 원본은 &lt;a href=&quot;https://raw.githubusercontent.com/lovetoken/flexdashboard_example/master/example.rmd&quot;&gt;이 링크&lt;/a&gt;인 Github 저장소를 통해 확인하거나 다운로드 할 수 있다.&lt;/p&gt;
</description>
        <pubDate>Mon, 19 Mar 2018 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2018/03/19/flexdashboard.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2018/03/19/flexdashboard.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>R에서 테이블 형 객체를 파일단위로 저장할 때 특화된 fst package</title>
        <description>&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;데이터 프레임 형을 파일단위로 저장할 때 R에서는 다양한 방법들이 있다.&lt;br /&gt;
크게 유형 분류를 하면&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;csv 와 같은 텍스트형으로 저장하는 방법&lt;/li&gt;
&lt;li&gt;이진 형태, 즉 binary 파일로 저장하는 방법&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;으로 나눌 수 있는데&lt;br /&gt;
호환성을 위해선 1번 방법이 좋지만, 저장 및 로드하는 속도, 파일의 볼륨을 줄이기 위한 압축 부분을 포기해야 하고,&lt;br /&gt;
속도를 위해선 2번 방법이 좋지만 텍스트에디터 등으로 파일을 간편하게 확인하는 것을 포기해야 하는 등&lt;br /&gt;
유형별로 장단점이 있다.&lt;/p&gt;
&lt;p&gt;본 글은 2번 이진 형태의 방법으로 R에서 데이터 프레임의 정보를 파일로 저장하는 방법 중 읽고 쓰는 속도가 상대적으로 빠른 편인 &lt;a href=&quot;http://www.fstpackage.org/&quot;&gt;fst package&lt;/a&gt; 를 이용한 방법을 소개하고자 한다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;benchmark&quot;&gt;Benchmark&lt;/h2&gt;
&lt;p&gt;소개에 앞서 처리속도가 다른 방법에 비교해 얼마나 빠른지 결과를 먼저 확인 해 보고 싶었다.&lt;br /&gt;
아래 코드는 샘플 데이터프레임을 만든 다음&lt;br /&gt;
오늘 주제인 fst 형으로 저장하는 방법과 그 외의 방법들로 저장하는 코드별 코드수행 시간을 측정하여 plotting 해 보는 코드이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(dplyr)
&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(microbenchmark)

nr_of_rows &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;^&lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;

df &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;data.frame&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;Logical =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;sample&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(T, F, &lt;span class=&quot;ot&quot;&gt;NA&lt;/span&gt;), &lt;span class=&quot;dt&quot;&gt;prob =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(.&lt;span class=&quot;dv&quot;&gt;85&lt;/span&gt;, .&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, .&lt;span class=&quot;dv&quot;&gt;05&lt;/span&gt;), nr_of_rows, &lt;span class=&quot;dt&quot;&gt;replace =&lt;/span&gt; T), 
                 &lt;span class=&quot;dt&quot;&gt;Integer =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;sample&lt;/span&gt;(1L:100L, nr_of_rows, &lt;span class=&quot;dt&quot;&gt;replace =&lt;/span&gt; T), 
                 &lt;span class=&quot;dt&quot;&gt;Real =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;sample&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;sample&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;10000&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt;) /&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;, nr_of_rows, &lt;span class=&quot;dt&quot;&gt;replace =&lt;/span&gt; T),
                 &lt;span class=&quot;dt&quot;&gt;Factor =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;as.factor&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;sample&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;labels&lt;/span&gt;(UScitiesD), nr_of_rows, &lt;span class=&quot;dt&quot;&gt;replace =&lt;/span&gt; T))) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;tbl_df

df&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 100,000,000 x 4
##    Logical Integer  Real Factor       
##    &amp;lt;lgl&amp;gt;     &amp;lt;int&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;fct&amp;gt;        
##  1 T            30  97.6 Chicago      
##  2 T            42  61.0 Atlanta      
##  3 NA           21  97.6 Chicago      
##  4 T             3  97.6 Miami        
##  5 T            89  48.2 Washington.DC
##  6 T            52  62.9 SanFrancisco 
##  7 T            41  31.5 NewYork      
##  8 T            38  47.1 Chicago      
##  9 T            21  48.2 Denver       
## 10 T            78  48.2 Denver       
## # ... with 99,999,990 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;저장대상으로 테스트에 쓸 데이터프레임 &lt;code&gt;df&lt;/code&gt; 를 만들어 보았다.&lt;br /&gt;
1억건의 레코드를 가진 데이터프레임이다.&lt;br /&gt;
이 &lt;code&gt;df&lt;/code&gt; 를&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;write.table&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;data.table::fwrite&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;saveRDS&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;feather::write_feather&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fst::write_fst&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;의 5개 방법별로 저장하는 시간을 반복측정하는 것을 microbenchmark package 의 도움을 받아 실행해 본다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;bench &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;microbenchmark&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;write.table =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;write.table&lt;/span&gt;(df, &lt;span class=&quot;dt&quot;&gt;file =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;output/df_writetable.csv&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;quote =&lt;/span&gt; F, &lt;span class=&quot;dt&quot;&gt;row.names =&lt;/span&gt; F, &lt;span class=&quot;dt&quot;&gt;sep =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;,&amp;quot;&lt;/span&gt;),
                        &lt;span class=&quot;dt&quot;&gt;fwrite =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;fwrite&lt;/span&gt;(df, &lt;span class=&quot;dt&quot;&gt;file =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;output/df_fwrite.csv&amp;quot;&lt;/span&gt;),
                        &lt;span class=&quot;dt&quot;&gt;saveRDS =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;saveRDS&lt;/span&gt;(df, &lt;span class=&quot;dt&quot;&gt;file =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;output/df_saveRDS.rds&amp;quot;&lt;/span&gt;),
                        &lt;span class=&quot;dt&quot;&gt;write_feather =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;write_feather&lt;/span&gt;(df, &lt;span class=&quot;dt&quot;&gt;path =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;output/df_feather.fea&amp;quot;&lt;/span&gt;),
                        &lt;span class=&quot;dt&quot;&gt;write_fst =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;write_fst&lt;/span&gt;(df, &lt;span class=&quot;dt&quot;&gt;path =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;output/df_fst.fst&amp;quot;&lt;/span&gt;), &lt;span class=&quot;dt&quot;&gt;times =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;autoplot&lt;/span&gt;(bench)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/fstPackage.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;fst 형으로 저장하는 방법이 약 2.52초로 다른 방법들에 비해 비약적으로 빠른 것을 볼 수 있다.&lt;/p&gt;
&lt;p&gt;쓰기 속도 외에도 읽기 속도 역시 좋은 성능을 보인다.&lt;/p&gt;
&lt;p&gt;읽기 테스트는 생략하지만 &lt;a href=&quot;http://www.fstpackage.org/&quot;&gt;fst package 홈페이지&lt;/a&gt;에 지금까지의 벤치마킹과 비슷한 실험 결과물이 소개되었으니 참고해 보면 좋겠다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;사용법&quot;&gt;사용법&lt;/h2&gt;
&lt;p&gt;벤치마킹 테스트 코드에 fst 형으로 저장하는 방법에 대한 코드가 있었다. 바로 이 부분인데&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;write_fst&lt;/span&gt;(df, &lt;span class=&quot;dt&quot;&gt;path =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;output/df_fst.fst&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;저장시킬 데이터프레임 객체명, 저장시킬 파일경로를 지정 이 두 가지가 필수이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;data &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;read_fst&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;output/df_fst.fst&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;읽는 방법은 &lt;code&gt;read_fst()&lt;/code&gt; 함수안에 이전에 저장시킨 파일경로를 지정하고 할당하는 방식이다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;특징&quot;&gt;특징&lt;/h2&gt;
&lt;p&gt;fst package 는 여러 특징이 있는데 가장 눈에 띄는 특징은&lt;br /&gt;
자동적으로 병렬스레드를 이용하여 저장 및 읽는 처리속도의 효율을 높인다는 것이다.&lt;br /&gt;
볼륨이 큰 데이터프레임을 &lt;code&gt;write_fst()&lt;/code&gt; 함수로 저장하곤 할 때 이러한 로그가 나타나는 것을 보면 알 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;write_fst&lt;/span&gt;(df, &lt;span class=&quot;dt&quot;&gt;path =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;output/df_fst.fst&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Written 9.6% of 100000000 rows in 2 secs using 4 threads. anyBufferGrown=no; maxBuffUsed=37%. Finished in 18 secs.      
Written 15.8% of 100000000 rows in 3 secs using 4 threads. anyBufferGrown=no; maxBuffUsed=37%. Finished in 15 secs.      
Written 22.5% of 100000000 rows in 4 secs using 4 threads. anyBufferGrown=no; maxBuffUsed=37%. Finished in 13 secs.      
Written 28.7% of 100000000 rows in 5 secs using 4 threads. anyBufferGrown=no; maxBuffUsed=37%. Finished in 12 secs.      
Written 33.7% of 100000000 rows in 6 secs using 4 threads. anyBufferGrown=no; maxBuffUsed=37%. Finished in 11 secs.      
Written 40.4% of 100000000 rows in 7 secs using 4 threads. anyBufferGrown=no; maxBuffUsed=37%. Finished in 10 secs.      
Written 46.6% of 100000000 rows in 8 secs using 4 threads. anyBufferGrown=no; maxBuffUsed=37%. Finished in 9 secs.      
Written 51.6% of 100000000 rows in 9 secs using 4 threads. anyBufferGrown=no; maxBuffUsed=37%. Finished in 8 secs.      
Written 57.2% of 100000000 rows in 10 secs using 4 threads. anyBufferGrown=no; maxBuffUsed=37%. Finished in 7 secs.      
Written 62.8% of 100000000 rows in 11 secs using 4 threads. anyBufferGrown=no; maxBuffUsed=37%. Finished in 6 secs.      
Written 67.8% of 100000000 rows in 12 secs using 4 threads. anyBufferGrown=no; maxBuffUsed=37%. Finished in 5 secs.      
Written 72.8% of 100000000 rows in 13 secs using 4 threads. anyBufferGrown=no; maxBuffUsed=37%. Finished in 4 secs.      
Written 77.9% of 100000000 rows in 14 secs using 4 threads. anyBufferGrown=no; maxBuffUsed=37%. Finished in 3 secs.      
Written 82.9% of 100000000 rows in 15 secs using 4 threads. anyBufferGrown=no; maxBuffUsed=37%. Finished in 3 secs.      
Written 88.5% of 100000000 rows in 16 secs using 4 threads. anyBufferGrown=no; maxBuffUsed=37%. Finished in 2 secs.      
Written 93.5% of 100000000 rows in 17 secs using 4 threads. anyBufferGrown=no; maxBuffUsed=37%. Finished in 1 secs.      
Written 97.4% of 100000000 rows in 18 secs using 4 threads. anyBufferGrown=no; maxBuffUsed=37%. Finished in 0 secs.  &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;data.table package 의 &lt;code&gt;fwrite()&lt;/code&gt;, &lt;code&gt;fread()&lt;/code&gt; 에서도 가지고 있는 기능이지만 fst package가 조금 더 높은 성능을 &lt;a href=&quot;http://www.fstpackage.org/README-multi-threading-1.png&quot;&gt;보이기도 한다&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;압축저장도 지원한다.&lt;br /&gt;
&lt;code&gt;write_fst()&lt;/code&gt; 함수의 인자들을 살펴보면 &lt;code&gt;compress&lt;/code&gt; 인자가 있고 기본적으로 50인데 이를 조정하여 압축률을 높이거나 낮출 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;write_fst&lt;/span&gt;(df, &lt;span class=&quot;dt&quot;&gt;path =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;output/compress_1.fst&amp;quot;&lt;/span&gt;,   &lt;span class=&quot;dt&quot;&gt;compress =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;write_fst&lt;/span&gt;(df, &lt;span class=&quot;dt&quot;&gt;path =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;output/compress_50.fst&amp;quot;&lt;/span&gt;,  &lt;span class=&quot;dt&quot;&gt;compress =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;50&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;write_fst&lt;/span&gt;(df, &lt;span class=&quot;dt&quot;&gt;path =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;output/compress_100.fst&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;compress =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;system&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;ls -lh output/compress*&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;-rw-r--r--@ 1 lovetoken  staff   1.2G Mar  1 10:21 output/compress_1.fst
-rw-r--r--@ 1 lovetoken  staff   247M Mar  1 10:22 output/compress_100.fst
-rw-r--r--@ 1 lovetoken  staff   582M Mar  1 10:21 output/compress_50.fst&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;압축률을 1로 한 것과 100으로 한 것 간의 파일 용량이 각각 1.2Gb, 247Mb 으로 차이가 큰 것을 볼 수 있다.&lt;/p&gt;
&lt;p&gt;마지막으로..&lt;br /&gt;
fst package 가 혹 &lt;code&gt;save()&lt;/code&gt;, &lt;code&gt;saveRDS()&lt;/code&gt; 처럼 R 객체를 저장할 수 있다고 생각하면 안 된다.&lt;br /&gt;
서두에도 말했듯이 데이터프레임 형 객체만 저장할 수 있다.&lt;br /&gt;
데이터프레임 형을 저장하는데 특화된 것이 특징이라면 특징이겠다.&lt;/p&gt;
</description>
        <pubDate>Thu, 01 Mar 2018 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2018/03/01/fstPackage.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2018/03/01/fstPackage.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>R에서 Benchmarking 패키지를 이용한 자료포락분석(Data Envelopment Analysis) 이용하기</title>
        <description>&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;약 5년전 컨설팅 인턴 일을 하면서 자료포락분석&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;(Data envelopment analysis 이하 DEA)이 필요했던 시점이 있다.&lt;br /&gt;
그때 당시 실제로 분석을 하기 위하여 컴퓨터 프로그램을 이용할 필요가 있었고&lt;br /&gt;
&lt;a href=&quot;http://expertchoice.co.kr/expert_choice.html&quot;&gt;Export choice&lt;/a&gt; 프로그램을 이용해 DEA 분석을 한 논문들을 상당수 찾을 수 있었다.&lt;br /&gt;
하지만 Export choice 는 상용 프로그램이었고 새로 알아야 된다는 점들 때문에 빠르게 시도해 볼 수 없었다.&lt;br /&gt;
이때는 깊은 분석보단 만만하게 시도해 볼 수 있었던 환경이 필요했었는데&lt;br /&gt;
마침 DEA 를 해볼 수 있는 R package 가 있었고 그 패키지 이름은 Benchmarking 이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;install.packages&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;Benchmarking&amp;quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(Benchmarking)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Benchmarking 패키지의 &lt;code&gt;dea()&lt;/code&gt; 함수를 이용하여 얼마든지 벤치마킹의 대상이 되는 의사결정단위(자료포괄분석에서 이를 Decision Making Unit. DMU로 줄여 표현한다) 별 efficiencies 값들을 구해낼 수 있었다.&lt;br /&gt;
우선 투입요소와 산출요소가 정해지고 그에 따른 정량적인 데이터가 존재하면&lt;br /&gt;
각 DMU 에 대한 효율성 평가를 수행할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;예제-데이터에-대한-설명&quot;&gt;예제 데이터에 대한 설명&lt;/h2&gt;
&lt;p&gt;Benchmarking package 안에 있는 데이터 셋 중 하나인 &lt;code&gt;charnes1981&lt;/code&gt; 을 예제로 DEA를 간단히 수행해 보겠다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;set.seed&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1004&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(dplyr)

&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt;(charnes1981)
charnes1981 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;charnes1981 %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;tbl_df %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;sample_n&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt;)
charnes1981&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 20 x 11
##     firm    x1    x2    x3    x4    x5    y1    y2    y3   pft
##    &amp;lt;int&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;int&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;int&amp;gt;
##  1    20 25.42  9.05 29.69 31.74     4 29.43 42.63 23.34     1
##  2    17 22.63  4.43 15.40 15.00     2 17.25 20.80 12.07     1
##  3    53 16.20  7.02 26.94 26.30     9 18.23 22.05 17.56     0
##  4    66 23.32  7.10 24.96 28.56    22 16.81 19.72 18.70     0
##  5    29 10.62  2.55 10.10  9.09     4  6.51  7.02  6.16     1
##  6    60 16.28  4.81 18.20 18.98     5 15.15 18.04 13.58     0
##  7    32  6.30  1.93  7.11  7.68     4  4.59  6.16  4.99     1
##  8    24 19.74  6.43 24.20 25.66     3 25.72 30.81 16.54     1
##  9    64 28.38  8.91 30.95 33.33     8 18.63 24.48 23.13     0
## 10    27 27.20  9.38 37.80 31.55     4 31.31 38.32 25.03     1
## 11    15  4.29  5.42 21.45 17.27     5 14.39 18.30 14.33     1
## 12    22 16.34  5.84 20.89 22.10     4 19.40 25.18 16.52     1
## 13     5 11.62  2.21  6.85  6.37     4  7.81  6.94  5.37     1
## 14     9 34.40 11.04 38.16 42.40     8 26.13 29.80 26.29     1
## 15    45  8.32  3.64 12.92 13.13     2  9.47 11.92  8.85     1
## 16     2 29.26 10.24 41.96 40.65     5 24.69 33.89 26.02     1
## 17    11 52.92 11.67 39.48 39.64     5 39.80 37.73 30.29     1
## 18    49  7.14  5.29 23.10 19.06     8 12.17 16.03 15.82     1
## 19    51 11.88  3.59 13.41 13.82     8  9.96 14.34  9.33     0
## 20    54 82.45 15.52 45.00 44.23    13 59.63 64.41 35.89     0
## # ... with 1 more variables: name &amp;lt;fctr&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;data 를 불러온 후&lt;br /&gt;
설명의 편의상 tibble type 으로 &lt;code&gt;charnes1981&lt;/code&gt; 형을 변환 및 20개의 샘플링을 하였다. &lt;a href=&quot;#fn2&quot; class=&quot;footnoteRef&quot; id=&quot;fnref2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;br /&gt;
각 변수들에 대한 설명은 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;firm&lt;/code&gt; : 학교별 ID&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;name&lt;/code&gt; : 주소&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x1&lt;/code&gt; : education level of the mother&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x2&lt;/code&gt; : highest occupation of a family member&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x3&lt;/code&gt; : parental visits to school&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x4&lt;/code&gt; : time spent with children in school-related topics&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;x5&lt;/code&gt; : the number of teachers at the site&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;y1&lt;/code&gt; : reading score&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;y2&lt;/code&gt; : math score&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;y3&lt;/code&gt; : self–esteem score&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;x로 시작하는 변수들은 각 학교들에 대한 독립변수(투입요소) 로 볼 수 있고&lt;br /&gt;
y로 시작하는 변수들은 그 학교에 대한 평가이므로 종속변수(산출요소) 로 볼 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;dea-분석&quot;&gt;DEA 분석&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;X &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;charnes1981 %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;starts_with&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;x&amp;quot;&lt;/span&gt;)) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;as.matrix

Y &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;charnes1981 %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;starts_with&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;y&amp;quot;&lt;/span&gt;)) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;as.matrix   

dea_res &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;dea&lt;/span&gt;(X, Y)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;dea()&lt;/code&gt; 함수의&lt;br /&gt;
첫번째 인자에는 투입변수에 대한 데이터를 matrix 형으로 입력한다.&lt;br /&gt;
위의 예제 경우 5개의 투입변수가 존재하므로 &lt;code&gt;X&lt;/code&gt; 처럼 적절하게 묶어주었다.&lt;/p&gt;
&lt;p&gt;두번째 인자에는 산출변수에 대한 데이터를 역시 matrix 형으로 입력한다.&lt;br /&gt;
마찬가지로 3개의 산출변수를 적절히 묶은 &lt;code&gt;Y&lt;/code&gt; 를 입력했다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dea()&lt;/code&gt; 함수로 반환되는 결과물들은 다양하다.&lt;br /&gt;
관심대상이 효율성 점수만이라면 아래처럼 &lt;code&gt;eff&lt;/code&gt; 속성값만을 호출해 본다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;dea_res$eff&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##  [1] 1.0000000 1.0000000 0.8844074 0.9541975 0.9326048 0.9964845 1.0000000
##  [8] 1.0000000 0.9804835 1.0000000 1.0000000 1.0000000 1.0000000 0.9850544
## [15] 1.0000000 1.0000000 1.0000000 1.0000000 0.9713179 1.0000000&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;의사결정단위 70개 별 Efficiencies 값이 출력된다.&lt;br /&gt;
학교주소별 Efficiencies 값을 매치시켜 표현해보거나&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data.frame&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;School_site_name =&lt;/span&gt; charnes1981$name, &lt;span class=&quot;dt&quot;&gt;Efficiencies =&lt;/span&gt; dea_res$eff)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##    School_site_name Efficiencies
## 1            Racine    1.0000000
## 2          New York    1.0000000
## 3            Fresno    0.8844074
## 4      Jacksonville    0.9541975
## 5           Chigago    0.9326048
## 6      Philidelphia    0.9964845
## 7      Jacksonville    1.0000000
## 8      Portageville    1.0000000
## 9             Flint    0.9804835
## 10         Meridian    1.0000000
## 11       Fall River    1.0000000
## 12         New York    1.0000000
## 13          Lebanon    1.0000000
## 14         Lakewood    0.9850544
## 15         New York    1.0000000
## 16          Buffalo    1.0000000
## 17          Wichita    1.0000000
## 18         San Jose    1.0000000
## 19          Buffalo    0.9713179
## 20          Lebanon    1.0000000&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;아래 plotting 결과물 처럼&lt;br /&gt;
제공되는 &lt;code&gt;dea.plot.frontier()&lt;/code&gt; 함수 결과물인 효율최적선을 통해&lt;br /&gt;
상대적인 효율성 평가를 하는데 용이할 것이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;dea.plot.frontier&lt;/span&gt;(X, Y, &lt;span class=&quot;dt&quot;&gt;txt =&lt;/span&gt; T)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/DEA_1.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dea()&lt;/code&gt; 함수는 DEA분석 주제에 대한 대부분의 기능을 총괄하고 있기 때문에 복잡하고, 제공되는 인자들도 많다.&lt;br /&gt;
투입 혹은 산출 관점에 따라 분석방법이 달라지기도 하고,&lt;br /&gt;
가정이 달라지기도 한다.&lt;br /&gt;
위의 예제처럼 인자의 조종 없이 &lt;code&gt;dea()&lt;/code&gt; 함수를 이용하면 기본값 설정을 따르는데&lt;br /&gt;
투입기준의 Variable returns to scale 가정을 기반하에 효율성 평가를 한다. (자세한건 &lt;code&gt;RTS&lt;/code&gt;, &lt;code&gt;ORIENTATION&lt;/code&gt; 인자의 도움말을 살펴본다)&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;분석-결과-해석&quot;&gt;분석 결과 해석&lt;/h2&gt;
&lt;p&gt;Efficiency 값이 1인 학교는 투입대비 산출 즉 효율성이 20개의 DMU 와 상대적으로 비교했을 때 가장 높다고 할 수 있다.&lt;br /&gt;
하지만 이는 절대적인 효율성 평가가 아닌 상대적 효율성 평가라는 것을 항상 염두해야 한다.&lt;/p&gt;
&lt;p&gt;Efficiency 값이 1 미만인 학교는&lt;br /&gt;
1의 값을 가진 학교보다 비효율이 발생하고 있다는것을 의미하며&lt;br /&gt;
그 값이 작으면 작을수록 비효율이 크다고 해석은 가능하다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://book.naver.com/bookdb/book_detail.nhn?bid=6874299&quot;&gt;책 : 효율성분석이론 DEA 자료포락분석법 - 이정동, 오동현 (지필미디어) 2012.03.30&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;자료포괄분석 으로도 불리는데 무엇이 맞는지는 모르겠다&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn2&quot;&gt;&lt;p&gt;원 데이터의 개수는 70개이며 이중 20개의 랜덤샘플링을 의미함&lt;a href=&quot;#fnref2&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Mon, 22 Jan 2018 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2018/01/22/DEA.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2018/01/22/DEA.html</guid>
        
        
        <category>R</category>
        
      </item>
    
  </channel>
</rss>
