<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description></description>
    <link>https://lovetoken.github.io/</link>
    <atom:link href="https://lovetoken.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 22 Oct 2017 23:14:23 +0900</pubDate>
    <lastBuildDate>Sun, 22 Oct 2017 23:14:23 +0900</lastBuildDate>
    <generator>Jekyll v3.1.6</generator>
    
      <item>
        <title>인터넷 접속이 안되는 CentOS 머신에서 Python3 및 패키지 설치하기</title>
        <description>&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;본 글은 CentOS 최소설치버전으로 설치된 서버에서 (내부망 운용등의 이유로)인터넷 접속이 불가한 상황일 때 Python3 및 패키지를 설치하는 법에 대해 설명하기 위한 글이다.&lt;br /&gt;
패키지의 예시는 &lt;a href=&quot;http://konlpy-ko.readthedocs.io/ko/v0.4.3/&quot;&gt;konlpy&lt;/a&gt; 이다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;가상환경-준비&quot;&gt;가상환경 준비&lt;/h2&gt;
&lt;p&gt;설명을 위하여&lt;br /&gt;
설치의 대상이 되는 CentOS 최소설치 환경을 똑같이 재현할 필요가 있다.&lt;br /&gt;
CentOS 최소설치가 된 가상환경을 &lt;a href=&quot;https://www.docker.com/&quot;&gt;Docker&lt;/a&gt; 을 통해 준비해 보았다.&lt;br /&gt;
(Docker를 모른다면 본 장은 설명을 위한 CentOS 환경을 그대로 재현하기 위함이구나 하고 넘어가면 되겠다)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker run --rm -it centos /bin/bash&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;CentOS 최소설치버전 이미지 다운로드한 후 컨테이너 실행하여 &lt;code&gt;/bin/bash&lt;/code&gt; 를 실행해 CentOS 쉘로 접속하게 된다.&lt;br /&gt;
접속된 환경은 인터넷이 가능한 상황이지만, 인터넷이 안되는 상황을 전제하에 Python3 및 konlpy 패키지를 수동으로 설치해 볼 것이다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;python3-설치파일-준비&quot;&gt;Python3 설치파일 준비&lt;/h2&gt;
&lt;p&gt;이제부턴 CentOS 쉘에서의 상황임을 염두해 둔다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ yum install -y https://centos7.iuscommunity.org/ius-release.rpm
$ yum search python36&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;IUS Community Project의 리포지토리를 yum의 리포지토리에 추가한 후 python36 검색해 본다.&lt;br /&gt;
&amp;quot;python36&amp;quot; 으로 시작되는 다양한 리스트들이 출력될 것이다.&lt;br /&gt;
참고로 yum 의 &lt;code&gt;-y&lt;/code&gt; 옵션 의미는 무조건 Yes로 입력하여 설치를 진행토록 하는 의미이다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mkdir ~/python3
$ cd ~/python3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;적당한 곳에 &lt;code&gt;python3&lt;/code&gt; 디렉토리를 만들고 그곳으로 간다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ yum install -y --downloadonly ----downloaddir=. python36u python36u-libs python36u-devel python36u-pip&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Python3.6 버전대 패키지들을 설치하지 않고 다운로드만 하는 명령어이다.&lt;br /&gt;
위 명령어를 실행하면 관련된 패키지들의 설치 rpm 을 워킹디렉토리(&lt;code&gt;~/python3&lt;/code&gt;)에 저장하게 된다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@e1e70169f547 python3]# ll
-rw-r--r-- 1 root root   56192 Aug  3 04:20 python36u-3.6.2-1.ius.centos7.x86_64.rpm
-rw-r--r-- 1 root root  204112 Aug  3 04:20 python36u-devel-3.6.2-1.ius.centos7.x86_64.rpm
-rw-r--r-- 1 root root 9689852 Aug  3 04:20 python36u-libs-3.6.2-1.ius.centos7.x86_64.rpm
-rw-r--r-- 1 root root 1841528 Feb  3  2017 python36u-pip-9.0.1-1.ius.centos7.noarch.rpm
-rw-r--r-- 1 root root  663324 Mar 22  2017 python36u-setuptools-33.1.1-1.ius.centos7.noarch.rpm&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;실제로 확인해 볼 경우 5개의 rpm 파일들이 준비된 것을 확인할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;konlpy-패키지-리소스-준비&quot;&gt;konlpy 패키지 리소스 준비&lt;/h2&gt;
&lt;p&gt;파이썬의 패키지를 준비하기 위해선 &lt;code&gt;pip&lt;/code&gt; 를 이용하는것이 좋다.&lt;br /&gt;
&lt;code&gt;pip&lt;/code&gt; 를 이용하기 위해서 방금 받은 rpm 을 이용해 파이썬을 설치한다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ yum install -y *&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;정상적으로 설치되면 이때부터 &lt;code&gt;python3.6&lt;/code&gt;, &lt;code&gt;pip3.6&lt;/code&gt; 명령어를 이용할 수 있게 된다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mkdir packages
$ cd packages&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;적당히 &lt;code&gt;~/python3/packages&lt;/code&gt; 디렉토리를 만들고 그곳으로 가자.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ pip3.6 install --download=. tag
$ pip3.6 install --download=. konlpy
$ pip3.6 install --download=. JPype1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위 명령어 중 첫번째는 tag package 에 대한 리소스 압축파일 (&lt;code&gt;.tag.gz&lt;/code&gt;) 을 포함한 의존성이 있는 리소스를 모두 현 워킹디렉토리에 저장만 한다.&lt;br /&gt;
즉 패키지들이 설치되지는 않는다.&lt;br /&gt;
konlpy 와 JPype1 패키지 역시 마찬가지로 리소스를 준비시킨다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@e1e70169f547 package]# ll
-rw-r--r-- 1 root root   147893 Oct 20 00:51 JPype1-0.6.2.tar.gz
-rw-r--r-- 1 root root    38404 Oct 20 00:52 intervaltree-2.1.0.tar.gz
-rw-r--r-- 1 root root 22454979 Oct 20 00:52 konlpy-0.4.4-py2.py3-none-any.whl
-rw-r--r-- 1 root root    32267 Oct 20 00:52 sortedcontainers-1.5.7-py2.py3-none-any.whl
-rw-r--r-- 1 root root    34414 Oct 20 00:52 tag-0.3.3.tar.gz&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;package 리소스 파일들이 준비되어 있는것을 확인할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;실제-인터넷이-불가한-centos-에서의-python3.6-packages-설치&quot;&gt;실제 인터넷이 불가한 CentOS 에서의 python3.6, packages 설치&lt;/h2&gt;
&lt;p&gt;인터넷이 불가한 상황을 전제하로 실제 CentOS 서버에서 위에서 준비한 rpm, package 리소스들을 복사하여 가져온다.&lt;/p&gt;
&lt;p&gt;본 예제의 경우 Docker 가상환경을 기준으로 설명했는데&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker cp &amp;lt;컨테이너명&amp;gt;:~/python3/. &amp;lt;호스트 경로&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;의 방식으로 가상환경에 있던 rpm, package 리소스 들을&lt;br /&gt;
호스트로 떨어트린 후 USB 메모리등을 이용해 복사하여 인터넷이 불가한 CentOS 서버머신에 복사하면 되겠다.&lt;br /&gt;
참고로 컨테이너 명은 &lt;code&gt;docker ps&lt;/code&gt; 를 통해 확인이 가능하다.&lt;br /&gt;
또한 &lt;code&gt;&amp;lt;호스트 경로&amp;gt;&lt;/code&gt;는 가상환경 입장에선 원격경로이므로 아래 예제처럼 작성되야겠다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker cp e1e70169f547:~/python3/. lovetoken@192.168.25.60:~/Download&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(이외의 docker 를 이용하지 않은 상황에선 각자 상황에 따라 대처... 자세한 설명은 생략)&lt;/p&gt;
&lt;p&gt;자 이제부터는 인터넷이 불가한 CentOS 서버상황이라고 가정한다.&lt;br /&gt;
편의상 &lt;code&gt;~/python3&lt;/code&gt; 에 복사한 것을 붙어넣었다고 가정하겠다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd ~/python3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;복사한 python3 폴더로 간다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ yum install -y python36u-3.6.2-1.ius.centos7.x86_64.rpm python36u-devel-3.6.2-1.ius.centos7.x86_64.rpm python36u-libs-3.6.2-1.ius.centos7.x86_64.rpm python36u-pip-9.0.1-1.ius.centos7.noarch.rpm python36u-setuptools-33.1.1-1.ius.centos7.noarch.rpm&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 명령어를 통해서&lt;br /&gt;
yum 은 원격레파지토리를 검색하지 않고 &lt;code&gt;~/python3&lt;/code&gt; 에 있는 rpm 에 의존하여 파이썬을 설치하기 시작한다.&lt;br /&gt;
즉 수동으로 설치가 되는것이다.&lt;br /&gt;
역시 정상적으로 설치되면 &lt;code&gt;python3.6&lt;/code&gt;, &lt;code&gt;pip3.6&lt;/code&gt; 을 실행할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd packages&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;~/python3/packages&lt;/code&gt; 폴더로 가서 이젠 konlpy 패캐지 설치를 시도할 것이다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pip3.6 install JPype1-0.6.2.tar.gz intervaltree-2.1.0.tar.gz konlpy-0.4.4-py2.py3-none-any.whl sortedcontainers-1.5.7-py2.py3-none-any.whl tag-0.3.3.tar.gz&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 명령어를 통해서 인터넷 연결없이 konlpy 관련 패키지들을 수동설치하게 된다.&lt;/p&gt;
</description>
        <pubDate>Sun, 22 Oct 2017 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/python/2017/10/22/python3_install_on_CentOS_manually.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/python/2017/10/22/python3_install_on_CentOS_manually.html</guid>
        
        
        <category>Python</category>
        
      </item>
    
      <item>
        <title>R에서 readr package 의 guess_encoding() 함수를 이용한 Text 파일의 인코딩 타입 추론</title>
        <description>&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;파일을 읽어 들일 때 인코딩 타입에 대한 이슈는 상당히 짜증 나는 유형의 이슈 중 하나라고 생각된다.&lt;br /&gt;
분석환경이 단독 운영체계만을 이용하여 분석한다면 큰 문제는 없겠지만&lt;br /&gt;
Linux 머신이나 Mac, Windows 등으로 넘나들게 되는 순간 데이터의 인코딩 타입을 고려해야 할 것이다.&lt;br /&gt;
통상적으로 이럴 때는 UTF-8 인코딩으로 통일하여 관리하지만&lt;br /&gt;
이것이 어려울 때 2개 이상의 인코딩 타입으로 데이터가 존재하게 될 것이다.&lt;/p&gt;
&lt;p&gt;그런데 인코딩 타입이 2개 이상 혼용되기 시작하면, 데이터를 읽어 들이고 내보내는 단계에서 인코딩타입까지 추가적으로 신경써야 한다는 점이 여러모로 피곤하게 느껴질 것이다.&lt;br /&gt;
데이터 I/O 단계에서 인코딩까지 신경써서 읽어들이는 것은 번거로운 일 일 수 있다.&lt;br /&gt;
애초에 이를 신경쓰는거 자체가 분석 본연에 있어 불필요한 요소일 수 있다.&lt;/p&gt;
&lt;p&gt;이번 글에서는 R에서 readr package 에 있는 &lt;code&gt;guess_encoding()&lt;/code&gt; 의 함수를 설명하고 소개할 것인데, R에서 데이터를 읽어 들이고 내보낼 시 인코딩 타입으로 인한 이슈들과 불편함을 겪는 사람들께 조금이나마 편의와 팁, 힌트를 주고자 작성한 글이다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;상황재현&quot;&gt;상황재현&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;d &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;read.csv&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;text =&lt;/span&gt; 
  &lt;span class=&quot;st&quot;&gt;&amp;quot;이름, 점수&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;  홍길동, 80&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;  철수, 91&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;  영희, 99&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;  Steve, 85&amp;quot;&lt;/span&gt;
)

&lt;span class=&quot;kw&quot;&gt;dir.create&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;data&amp;quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;write.csv&lt;/span&gt;(d, &lt;span class=&quot;st&quot;&gt;&amp;quot;data/Testdata_EUC-KR.csv&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;fileEncoding =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;EUC-KR&amp;quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;write.csv&lt;/span&gt;(d, &lt;span class=&quot;st&quot;&gt;&amp;quot;data/Testdata_UTF-8.csv&amp;quot;&lt;/span&gt;,  &lt;span class=&quot;dt&quot;&gt;fileEncoding =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;UTF-8&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위 코드는 &amp;quot;EUC-KR&amp;quot; 형과 &amp;quot;UTF-8&amp;quot; 형으로 작성된 간단한 데이터 테이블을 data 폴더안 &lt;code&gt;csv&lt;/code&gt; 포맷으로 저장시키는 코드이다.&lt;br /&gt;
두개의 다른 인코딩 형의 똑같은 내용의 데이터가 2개 준비된 것이다.&lt;br /&gt;
이 데이터의 인코딩형의 정보를 모른다고 가정하고 R로 읽어 들일 때 어떠한 문제들이 있는지 보겠다.&lt;/p&gt;
&lt;p&gt;csv 포맷의 데이터를 읽어들이는 방법은 여러가지가 있다.&lt;br /&gt;
가장 기본적인 &lt;code&gt;read.csv()&lt;/code&gt;함수의 경우이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;read.csv&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;data/Testdata_UTF-8.csv&amp;quot;&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# on Mac&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##   X     이름 점수
## 1 1   홍길동   80
## 2 2     철수   91
## 3 3     영희   99
## 4 4    Steve   85&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;quot;UTF-8&amp;quot; 형인 데이터를 먼저 불러와 보았는데 필자는 Mac 으로 동작시켰기 때문에 정상적으로 읽어들여진다.&lt;br /&gt;
하지만 Windows 환경에서는 저렇게 읽어들여지지 않을 것이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;read.csv&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;data/Testdata_UTF-8.csv&amp;quot;&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# on Windows&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Error in make.names(col.names, unique = TRUE) : invalid multibyte string at &amp;#39;&amp;lt;ec&amp;gt;&amp;lt;9d&amp;gt;&amp;lt;b4&amp;gt;由&amp;lt;84&amp;gt;&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Windows 환경에선 이와 같은 에러가 나면서 정말 간단한 예제의 데이터 테이블임에도 불구하고 읽어들이지 못한다.&lt;br /&gt;
이는 &lt;code&gt;read.csv()&lt;/code&gt; 함수가 동작할 때 내부적으로 &lt;code&gt;fileEncoding&lt;/code&gt; 인자값이 &lt;code&gt;Sys.getlocale(&amp;quot;LC_CTYPE&amp;quot;)&lt;/code&gt; 로 반환되는 환경변수값에 의존되어 실행된다.&lt;br /&gt;
Windows 환경에선 결과적으로 &lt;code&gt;read.csv()&lt;/code&gt; 함수가 &amp;quot;CP949&amp;quot; 라는 인코딩형으로 읽어들이게 되고,&lt;br /&gt;
이 인코딩 형이 원본파일의 인코딩 형(&amp;quot;UTF-8&amp;quot;)과 불일치 하기 때문에,&lt;br /&gt;
한글인 변수명이 유효하지 않은 문자열로 일그러져 인식할 수 없기 때문이다.&lt;/p&gt;
&lt;p&gt;이러한 원리 때문에 반대로 &amp;quot;EUC-KR&amp;quot; 형 데이터를 Mac 환경에서 읽어 들일 경우 마찬가지이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;read.csv&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;data/Testdata_EUC-KR.csv&amp;quot;&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# on Mac&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Error in make.names(col.names, unique = TRUE) : invalid multibyte string at &amp;#39;&amp;lt;c0≯&amp;lt;a7&amp;gt;&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;우선 에러없이 데이터를 R로 읽어들이는 해결방법은 이렇다.&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;일어들일 데이터의 텍스트 인코딩형을 알아낸다.&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;read.csv()&lt;/code&gt; 함수의 &lt;code&gt;fileEncoding&lt;/code&gt; 인자값을 알아낸 인코딩형으로 직접 입력한다.&lt;/li&gt;
&lt;li&gt;예를 들면 &lt;code&gt;read.csv(&amp;quot;data/Testdata_UTF-8.csv&amp;quot;, fileEncoding = &amp;quot;UTF-8&amp;quot;)&lt;/code&gt; 이런 코드가 되겠다. 이 코드를 실행하여 정상적으로 일어졌는지 확인한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;3단계 스텝을 통해 데이터를 읽어들이는데 성공한다.&lt;br /&gt;
굳이 세번째 스텝을 설명한 이유는 에러없이 데이터를 일어들였다 하더라도,&lt;br /&gt;
첫번째 스텝에 인코딩형을 제대로 알지 못하여 막장으로 일어들여질 가능성이 있기 때문에&lt;br /&gt;
확인하는 과정이 필요하므로 생겨난 부수적인 스텝이라 할 수 있겠다.&lt;/p&gt;
&lt;p&gt;여하튼 (분석을 하기도 전에) 데이터를 일어들이기 위한 이 3단계는 많은 에너지를 소모하게 만든다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;readrguess_encoding-함수&quot;&gt;&lt;code&gt;readr::guess_encoding()&lt;/code&gt; 함수&lt;/h2&gt;
&lt;p&gt;이제 본 글의 주제인 readr package 의 &lt;code&gt;guess_encoding()&lt;/code&gt; 함수를 소개한다.&lt;br /&gt;
함수명칭에서 볼 수 있듯이 이 함수의 쓰임은 인코딩형을 추론하는 함수인데&lt;br /&gt;
이를 잘 이용하면 위에서 설명한 번잡한 3단계 스텝을 1스텝으로 점프할 수 있다.&lt;/p&gt;
&lt;p&gt;우선 &lt;code&gt;guess_encoding()&lt;/code&gt; 함수를 살펴보자.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(readr) &lt;span class=&quot;co&quot;&gt;# for guess_encoding()&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;guess_encoding&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;data/Testdata_EUC-KR.csv&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 3 x 2
##     encoding confidence
##        &amp;lt;chr&amp;gt;      &amp;lt;dbl&amp;gt;
## 1     EUC-KR       1.00
## 2    GB18030       0.71
## 3 ISO-8859-1       0.21&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;guess_encoding&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;data/Testdata_UTF-8.csv&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1 x 2
##   encoding confidence
##      &amp;lt;chr&amp;gt;      &amp;lt;dbl&amp;gt;
## 1    UTF-8          1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;guess_encoding()&lt;/code&gt; 함수사용법은 간단하다.&lt;br /&gt;
외부 텍스트 파일에 대한 경로를 입력하고 실행하면 된다.&lt;br /&gt;
그러면 외부 텍스트파일의 인코딩형이 무엇일지 자동적으로 추론하고 가능성(confidence) 이 높은 순으로 출력된다.&lt;br /&gt;
&amp;quot;EUC-KR&amp;quot; 형 csv 파일을 일어들여 인코딩을 추론한 결과를 보면 &amp;quot;EUC-KR&amp;quot; 형일 가능성이 가장 높고, 그다음 &amp;quot;GB18030&amp;quot;, &amp;quot;ISO-8859-1&amp;quot; 형을 추론하는것을 볼 수 있다.&lt;br /&gt;
위에서 설명한 3단계 스텝에서 첫번째 스텝을 자동적으로 더 정확하게 추론함으로써 수고를 덜어준다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;read.csv&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;data/Testdata_EUC-KR.csv&amp;quot;&lt;/span&gt;, 
         &lt;span class=&quot;dt&quot;&gt;fileEncoding =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;guess_encoding&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;data/Testdata_EUC-KR.csv&amp;quot;&lt;/span&gt;)[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;] %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;as.character)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##   X     이름 점수
## 1 1   홍길동   80
## 2 2     철수   91
## 3 3     영희   99
## 4 4    Steve   85&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;아예 이런 식으로 내재화시켜버리면 3단계 스텝을 거치지 않고 어떠한 운영체계, 환경이든 융통성 있게 데이터를 잘 읽어 들일 것이다.&lt;br /&gt;
실제로 위 코드는 필자의 Mac 에서 동작했는데도 불구하고 인코딩이슈 없이 한글을 잘 읽어 들인 것을 볼 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;맺음말&quot;&gt;맺음말&lt;/h2&gt;
&lt;p&gt;본 글은 &lt;code&gt;read.csv()&lt;/code&gt; 함수에서 예시로 들었지만 외부 텍스트형 데이터를 읽어들이는 방법은 이 함수 말고도 다양하다.&lt;br /&gt;
필자는 csv 포맷 파일을 읽어들일 때 &lt;code&gt;data.table::fread()&lt;/code&gt;, &lt;code&gt;readr::read_csv()&lt;/code&gt; 등의 함수를 즐겨쓰는 편인데, 이 때도 마찬가지로 &lt;code&gt;guess_encoding()&lt;/code&gt; 함수를 이용해 인코딩 형을 신경쓰지 않고 최대한 분석에 집중하고 있다.&lt;/p&gt;
</description>
        <pubDate>Sat, 07 Oct 2017 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2017/10/07/guessEncoding.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2017/10/07/guessEncoding.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>R에서 기본 내장 graphics package를 이용한 데이터 시각화</title>
        <description>&lt;p&gt;본 글은 R에서 기본 내장 graphics package에 대표격인 &lt;code&gt;plot()&lt;/code&gt; 함수의 기초를 설명해보고자 한다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;plot-함수&quot;&gt;&lt;code&gt;plot()&lt;/code&gt; 함수&lt;/h2&gt;
&lt;p&gt;x 와 y 의 2개 축을 기준으로 좌표를 찍는 컨셉을 가진 함수이다.&lt;br /&gt;
가장 대표적으로 산점도를 표현할 때 간단하게 구현이 가능한 함수로 소개되나,&lt;br /&gt;
범용적으로 사용이 가능한 제너릭 함수 (generic function) 이기 때문에&lt;br /&gt;
입력되는 데이터의 타입과 클래스에 따라 성격에 맞게 다양한 모습으로 데이터 시각화 결과물이 출력된다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;좌표-찍기&quot;&gt;좌표 찍기&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/plotFunction_1-1.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;plot()&lt;/code&gt; 함수는 &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; 인자 2개를 기본적으로 받는다.&lt;br /&gt;
위의 코드를 실행하면 (2, 1)이라는 좌표 한곳에 점을 찍는 모습을 볼 수 있다.&lt;br /&gt;
이러한 특성을 잘 이용하면 복수개의 좌표에 점을 찍을 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;), &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/plotFunction_2-1.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;2개의 점이 찍히는데 각각 (1,1), (2,5) 좌표에 찍히는 것을 볼 수 있다.&lt;/p&gt;
&lt;p&gt;이런 좌표 찍기 특성을 이용하여 자신이 가지고 있는 데이터셋을 &lt;code&gt;plot()&lt;/code&gt; 함수의 &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; 인자에게 넘김으로써 산점도를 표현할 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;names&lt;/span&gt;(cars)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;speed&amp;quot; &amp;quot;dist&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(cars$speed, cars$dist)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/plotFunction_3-1.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;built-in 객체 &lt;code&gt;cars&lt;/code&gt;에서 차의 속도 정보를 담은 벡터 &lt;code&gt;cars$speed&lt;/code&gt; 가 x축으로,&lt;br /&gt;
주행거리 정보를 담은 벡터 &lt;code&gt;cars$dist&lt;/code&gt; 가 y축으로 입력됨으로써&lt;br /&gt;
차량의 속도와 거리 간의 관계를 대략적으로 살펴볼 수 있는 산점도를 보여주는 예제이다.&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;참고로 위의 코드 &lt;code&gt;plot(cars$speed, cars$dist)&lt;/code&gt; 는 아래의 코드를 실행하는 것과 같다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(dist ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;speed, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; cars)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;type-인자&quot;&gt;&lt;code&gt;type&lt;/code&gt; 인자&lt;/h3&gt;
&lt;p&gt;위의 좌표 찍기 두번째 예시인&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;), &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/plotFunction_4-1.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;에서 두 좌표 간 직선을 그리고 싶다면 &lt;code&gt;type&lt;/code&gt; 인자를 조정해보면 된다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;), &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;), &lt;span class=&quot;dt&quot;&gt;type =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;l&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/plotFunction_5-1.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;quot;line&amp;quot;을 의미할 것 같은 &amp;quot;l&amp;quot; 문자를 &lt;code&gt;type&lt;/code&gt; 인자로 넘겨주면 두 좌표가 연결된 선을 그린다.&lt;br /&gt;
&lt;code&gt;type&lt;/code&gt; 는 그림을 어떻게 그릴 것인지 묻는 인자로써, 이 인자값을 입력하지 않으면 기본적으로 &amp;quot;point&amp;quot;의 의미인 &amp;quot;p&amp;quot; 가 대부분 설정된다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;type&lt;/code&gt; 인자가 받을 수 있는 값들은 아래와 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;type = &amp;quot;p&amp;quot;&lt;/code&gt; : 점으로&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type = &amp;quot;l&amp;quot;&lt;/code&gt; : 선으로&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type = &amp;quot;b&amp;quot;&lt;/code&gt; : 점과 선 둘 다 동시에&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type = &amp;quot;o&amp;quot;&lt;/code&gt; : 점과 선 둘 다 동시에 (단 겹쳐짐 : over plotted)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type = &amp;quot;h&amp;quot;&lt;/code&gt; : 히스토그램과 비슷한 형태로 (histogram)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type = &amp;quot;s&amp;quot;&lt;/code&gt; : 계단모양으로 (stair steps)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type = &amp;quot;S&amp;quot;&lt;/code&gt; : 계단모양으로 (upper stair steps)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type = &amp;quot;n&amp;quot;&lt;/code&gt; : 좌표찍지 않음&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;type = n&lt;/code&gt;인 경우는 특이하게 plot의 토대인 축은 표현되나, 좌표가 찍히지 않음으로써&lt;br /&gt;
마치 그림을 그리기 이전 스케치북을 펼치는 것과 같다고 볼 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;), &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;), &lt;span class=&quot;dt&quot;&gt;type =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;n&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/plotFunction_6-1.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;이외의-다양한-인자들&quot;&gt;이외의 다양한 인자들&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;plot()&lt;/code&gt; 함수는 그래픽스 파라미터 &lt;code&gt;par&lt;/code&gt;를 상속받게 되어 다양한 인자들을 사용할 수 있는데, 이 특성을 잘 살리면 더 세부적인 조정이 가능하다.&lt;/p&gt;
&lt;p&gt;그래픽스 파라미터 (Graphical Parameters)의 자세한 내용과 사용 가능 인자가 무엇이 있는지 알고 싶다면&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;?par&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;를 실행시켜 도움말을 볼 수 있다.&lt;br /&gt;
&lt;code&gt;cex&lt;/code&gt;, &lt;code&gt;fg&lt;/code&gt;, &lt;code&gt;lty&lt;/code&gt;, &lt;code&gt;pch&lt;/code&gt; 등의 인자만 살펴보자&lt;/p&gt;
&lt;p&gt;만약 plotting 결과물에서 좌표 포인트의 크기를 조정하고 싶다면 &lt;code&gt;cex&lt;/code&gt; 인자값을 조정한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(dist ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;speed, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; cars, &lt;span class=&quot;dt&quot;&gt;cex =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# 디폴트로 cex=1 임, 즉 2배 크게&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/plotFunction_7-1.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(dist ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;speed, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; cars, &lt;span class=&quot;dt&quot;&gt;cex =&lt;/span&gt; .&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# 2배 작게&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/plotFunction_7-2.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;축의 색깔을 바꾸고 싶다면 전경색을 조절할 수 있는 &lt;code&gt;fg&lt;/code&gt; 인자값을 조정한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(dist ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;speed, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; cars, &lt;span class=&quot;dt&quot;&gt;fg =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;blue&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/plotFunction_8-1.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;만약 line type의 그림을 그렸다면 선의 성격을 &lt;code&gt;lty&lt;/code&gt; 인자를 통해 바꿀 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;), &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;), &lt;span class=&quot;dt&quot;&gt;type =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;l&amp;quot;&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# lty 를 언급하지 않았을 때&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/plotFunction_9-1.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;), &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;), &lt;span class=&quot;dt&quot;&gt;type =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;l&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;lty=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&amp;quot;dashed&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/plotFunction_9-2.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;만약 point type의 그림을 그렸다면 점의 모양을 &lt;code&gt;pch&lt;/code&gt; 인자를 통해 바꿀 수도 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(dist ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;speed, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; cars) &lt;span class=&quot;co&quot;&gt;# pch 를 언급하지 않았을 때&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/plotFunction_10-1.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(dist ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;speed, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; cars, &lt;span class=&quot;dt&quot;&gt;pch =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/plotFunction_10-2.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(dist ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;speed, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; cars, &lt;span class=&quot;dt&quot;&gt;pch =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;25&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# 1 ~ 25개의 모양이 준비되어 있음&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/plotFunction_10-3.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;좌표-찍기의-특성을-어기는-아니-똑똑한-제너릭-함수&quot;&gt;좌표 찍기의 특성을 어기는, 아니 똑똑한 제너릭 함수&lt;/h3&gt;
&lt;p&gt;지금까지 보았듯이 &lt;code&gt;plot()&lt;/code&gt;은 좌표 찍기의 컨셉을 이용하여 데이터시각화 결과물을 출력한다.&lt;br /&gt;
하지만 좌표 찍기에 적합하지 않은 클래스의 데이터가 입력되면 그에 알맞게 좌표 찍기의 컨셉을 버리고 다른 형태로 출력한다.&lt;/p&gt;
&lt;p&gt;아래 코드를 보면&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;fit &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;lm&lt;/span&gt;(dist ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;speed, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; cars)
&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(fit)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/plotFunction_11-1.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;img src=&quot;/assets/plotFunction_11-2.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;img src=&quot;/assets/plotFunction_11-3.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;img src=&quot;/assets/plotFunction_11-4.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;위의 코드는 &lt;code&gt;cars&lt;/code&gt; 를 대상으로 단순회귀적합을 한 lm class의 &lt;code&gt;fit&lt;/code&gt; 객체를 &lt;code&gt;plot()&lt;/code&gt; 함수에 입력한 결과인데 뭔가 많다.&lt;br /&gt;
분명 산점도이긴 산점도인데 더 복잡하고 어떠한 선분과 겹쳐져 그려진 4개의 패널로 구분된 시각화 결과물이 출력된다.&lt;br /&gt;
이는 회귀 적합 이후 모형진단 시 자주 사용하는 데이터 시각화 결과물을 &lt;code&gt;plot()&lt;/code&gt; 함수가 자동으로 알아서 모두 출력해준 것이다.&lt;br /&gt;
산점도 뿐만 아니라 완전히 성격이 바뀐 결과물을 출력하기도 한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(data.tree)
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt;(acme, &lt;span class=&quot;dt&quot;&gt;package =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;data.tree&amp;quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(acme)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/plotFunction_12.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;data.tree 라는 패키지가 있는데,&lt;br /&gt;
이 패키지에 포함되어 있는 &lt;code&gt;acme&lt;/code&gt; 데이터셋은 class 가 &lt;code&gt;data.tree&lt;/code&gt; 로써 특이한 구조를 가지고 있는 데이터셋 이다.&lt;br /&gt;
이를 &lt;code&gt;plot()&lt;/code&gt; 함수에 입력하여 plotting 하면 우리가 기존에 알고 있던 방식의 결과물이 나오지 않고 색다른 결과물이 나온다.&lt;br /&gt;
이러한 이유는 &lt;code&gt;plot()&lt;/code&gt; 이란 함수는 입력되는 데이터의 class에 알맞게 최적으로 표현해줄 수 있는 방법의 코드로 실행되기 때문이다.&lt;br /&gt;
그리고 이러한 특징을 가진 함수는 R에서 generic function이라고 부른다.&lt;br /&gt;
generic function은 사용자가 함수에 대한 문법을 정확하게 지키지 않더라도 최대한 사용자가 기대할 것 같은 결과물을 내보내기 위함이다.&lt;br /&gt;
이러한 R 시스템은 사용자 편의를 올릴 수 있게 해준다.&lt;/p&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;R을 공부하다 보면 눈에 자주 띄는 대표적인 그림이기도 하다&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Fri, 16 Jun 2017 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/data_visualization/2017/06/16/plotFunction.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/data_visualization/2017/06/16/plotFunction.html</guid>
        
        
        <category>R</category>
        
        <category>Data_Visualization</category>
        
      </item>
    
      <item>
        <title>Hello Scala! (스칼라 시작하기)</title>
        <description>&lt;p&gt;대용량 분산처리 분석시스템인 스파크(Spark)를 알기 위해 항상 마주쳤던, 그리고 발목을 잡는것이 스칼라(Scala)이었다.&lt;br /&gt;
스파크를 제대로 이용하기 위해선 스크립팅 기술이 필요한데 가장 대중적인 것이 스칼라이고 그다음이 파이썬(Python) 인 듯 보인다.&lt;br /&gt;
파이썬으로 해도 되지만 스파크의 철학을 제대로 물려받아 활용하기 위해선 스칼라를 이용할 것을 많은 곳에서 권장했다.&lt;br /&gt;
스파크에 관련된 구글링 검색만을 해보아도 예제의 코드는 스칼라코드가 더 많이 검색되었고, 이러한 이유가 분명 있을 것이기에 스칼라 공부를 시작했다.&lt;/p&gt;
&lt;p&gt;첫 공부의 시작에 앞서 책한권은 있어야 마음가짐이 잘 잡힐 것인데&lt;br /&gt;
필자는 아래의 책이 스칼라를 공부하기 위한 첫 책이다.&lt;/p&gt;
&lt;br&gt;&lt;br&gt;&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;image/HelloScala1.jpg&quot;&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&amp;amp;mallGb=KOR&amp;amp;barcode=9791185890791&amp;amp;orderClick=LAH&amp;amp;Kc=#N&quot;&gt;러닝 스칼라 - 제이슨 스와츠 지음 | 김정인, 강성용 옮김 | 제이펍 | 2017년 04월 17일 출간&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;본 글에선 &lt;strong&gt;스칼라 설치와 &amp;quot;Hello world&amp;quot; 의 출력정도의 기본적인 것을 정리&lt;/strong&gt;하는 걸 목표로 한다.&lt;br /&gt;
(단 앞으로의 내용은 Unix 계열 머신을 기준으로 설명함을 알립니다.)&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;스칼라-설치&quot;&gt;스칼라 설치&lt;/h2&gt;
&lt;p&gt;스칼라는 수동으로 설치하는 방법과 자동으로 설치하는 방법으로 나뉜다.&lt;/p&gt;
&lt;h3 id=&quot;수동설치&quot;&gt;수동설치&lt;/h3&gt;
&lt;p&gt;스칼라를 배포하는 &lt;a href=&quot;http://www.scala-lang.org/&quot;&gt;scala-lang.org&lt;/a&gt; 를 들어가면 다운로드 페이지가 있다.&lt;br /&gt;
&lt;code&gt;scala-2.XX.X.tgz&lt;/code&gt; 를 다운로드 한 이후 &lt;code&gt;bin&lt;/code&gt; 폴더를 경로에 추가하면 되겠다.&lt;/p&gt;
&lt;h3 id=&quot;자동설치&quot;&gt;자동설치&lt;/h3&gt;
&lt;p&gt;수동설치가 번거로우면 패키지 매니저를 이용해 설치하면 된다.&lt;br /&gt;
OSX 에선 Homebrew 를 통해 &lt;a href=&quot;https://opentutorials.org/course/128/11129&quot;&gt;Homebrew 설치법은 생활코딩 참고&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;sh&quot;&gt;&lt;code&gt;brew install scala&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;리눅스에선 apt-get&lt;/p&gt;
&lt;pre class=&quot;sh&quot;&gt;&lt;code&gt;apt-get install scala&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;혹은 yum 을 통해&lt;/p&gt;
&lt;pre class=&quot;sh&quot;&gt;&lt;code&gt;yum install scala&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;스칼라 설치가 가능하다.&lt;/p&gt;
수동설치 혹은 자동설치가 성공했다면 명령줄에서 &lt;code&gt;scala&lt;/code&gt; 명령어를 통해 실행 가능하다.
&lt;center&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;https://asciinema.org/a/123507.js&quot; id=&quot;asciicast-123507&quot; async&gt;&lt;/script&gt;
&lt;/center&gt;
&lt;p&gt;위의 예제는 스칼라에서 &lt;code&gt;println()&lt;/code&gt; 함수로 &amp;quot;Hello world&amp;quot; 를 출력하는 예제이다.&lt;br /&gt;
터미널 상에서 스칼라를 쓰기에는 많은 불편함이 있을 것이다.&lt;br /&gt;
적당한 텍스트 에디터에 REPL(Read Evaluate Print Loop) 을 연동시켜 사용하거나, 적절한 IDE(ntegrated Development Environment) 를 이용하는 것이 여러모로 이점이 많겠다.&lt;br /&gt;
이부분은 개인취향이므로 무언가를 추천하지는 않겠지만 필자는 &lt;a href=&quot;https://www.sublimetext.com/&quot;&gt;Sublime text 3&lt;/a&gt; 의 &lt;a href=&quot;https://packagecontrol.io/packages/SublimeREPL&quot;&gt;SublimeREPL 패키지&lt;/a&gt;를 사용해서 스칼라 스크립트를 작성하고 이 글을 작성함을 밝힌다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;값-할당&quot;&gt;값 할당&lt;/h2&gt;
&lt;p&gt;스칼라의 값 할당 방법은 다음과 같은 구문으로 약속되어 있다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;val &amp;lt;식별자&amp;gt;[: &amp;lt;타입&amp;gt;] = &amp;lt;데이터&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;값(value) 의 앞글자 &amp;quot;val&amp;quot; 로 시작하고 식별자 다음에 데이터 타입을 명시하기 위해 &lt;code&gt;:&lt;/code&gt; 로 구분한다.&lt;br /&gt;
그다음 할당할 데이터를 &lt;code&gt;=&lt;/code&gt; 이후에 입력한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode scala&quot;&gt;&lt;code class=&quot;sourceCode scala&quot;&gt;&lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; x: Int = &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; y: Int = &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;
x * y&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;https://asciinema.org/a/123515.js&quot; id=&quot;asciicast-123515&quot; async&gt;&lt;/script&gt;
&lt;/center&gt;
&lt;p&gt;데이터 타입을 항상 명시해야 하는 것은 아니다.&lt;br /&gt;
데이터 타입을 입력하지 않을 경우 타입추론에 의해 자동으로 적당한 타입을 판단하여 실행한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode scala&quot;&gt;&lt;code class=&quot;sourceCode scala&quot;&gt;&lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; x = &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; y = &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;
x * y&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;https://asciinema.org/a/123516.js&quot; id=&quot;asciicast-123516&quot; async&gt;&lt;/script&gt;
&lt;/center&gt;
&lt;p&gt;데이터 타입을 정수(Int)형으로 명시하지 않았음에도 불구하고 &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; 를 정수형으로 정의한 것을 확인할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;res-변수&quot;&gt;&lt;code&gt;res&lt;/code&gt; 변수&lt;/h2&gt;
&lt;p&gt;스칼라에선 &amp;quot;res&amp;quot; 그 뒤에 순차적으로 매겨지는 번호와 결합된 변수를 만들어 결과값 정보를 담는다.&lt;br /&gt;
이 특징을 이용하여 이전에 계산되었던 값을 불러와 재사용할 수 있을 것이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode scala&quot;&gt;&lt;code class=&quot;sourceCode scala&quot;&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;
res0 * res1&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;https://asciinema.org/a/123517.js&quot; id=&quot;asciicast-123517&quot; async&gt;&lt;/script&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;boolean&quot;&gt;Boolean&lt;/h2&gt;
&lt;p&gt;스칼라의 Boolean 타입은 &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; 값을 이용한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode scala&quot;&gt;&lt;code class=&quot;sourceCode scala&quot;&gt;&lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt; &amp;gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt; &amp;lt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt; == &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt; == &lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;https://asciinema.org/a/123520.js&quot; id=&quot;asciicast-123520&quot; async&gt;&lt;/script&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;tuple&quot;&gt;Tuple&lt;/h2&gt;
&lt;p&gt;튜풀은 데이터를 담는 컨테이너 중에서 순서가 있고 복수개의 값들을 담는 컨테이너를 의미한다.&lt;br /&gt;
소괄호를 이용하면 데이터 타입을 명시하지 않고도 튜플을 만들 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode scala&quot;&gt;&lt;code class=&quot;sourceCode scala&quot;&gt;&lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; tuple = (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;4.0&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;Five&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;https://asciinema.org/a/123522.js&quot; id=&quot;asciicast-123522&quot; async&gt;&lt;/script&gt;
&lt;/center&gt;
&lt;p&gt;튜플에 들어가는 각 원소들은 그 원소들끼리의 데이터타입이 통일될 필요는 없다.&lt;br /&gt;
위의 예제처럼 Int, Double, String 3개의 각기다른 데이터타입이 튜플이라는 컨테이너에 담을 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;표현식-블록&quot;&gt;표현식 블록&lt;/h2&gt;
&lt;p&gt;실행시킬 복수줄의 코드단위를 중괄호로 묶어 하나의 표현식(expression)으로 관리하는것이 스칼라에선 가능하다.&lt;br /&gt;
그리고 복잡한 표현식을 실행시킨 결과를 반환값으로 사용할 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode scala&quot;&gt;&lt;code class=&quot;sourceCode scala&quot;&gt;&lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; result = {
  &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; x: Double = &lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;
  x * &lt;span class=&quot;fl&quot;&gt;0.5&lt;/span&gt;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;https://asciinema.org/a/123525.js&quot; id=&quot;asciicast-123525&quot; async&gt;&lt;/script&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;주석&quot;&gt;주석&lt;/h2&gt;
&lt;p&gt;스칼라에서 주석은 &lt;code&gt;//&lt;/code&gt; 을 이용한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode scala&quot;&gt;&lt;code class=&quot;sourceCode scala&quot;&gt;&lt;span class=&quot;co&quot;&gt;// println(&amp;quot;Comment&amp;quot;)&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;Not comment&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;https://asciinema.org/a/123526.js&quot; id=&quot;asciicast-123526&quot; async&gt;&lt;/script&gt;
&lt;/center&gt;
&lt;p&gt;주석이 처리된 코드는 실행되지 않는 것을 확인할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;매치표현식을-이용한-조건부-로직&quot;&gt;매치표현식을 이용한 조건부 로직&lt;/h2&gt;
&lt;p&gt;스칼라에선 if else 구문의 조건문보다 매치표현식을 이용한 조건문을 즐겨 사용한다고 한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode scala&quot;&gt;&lt;code class=&quot;sourceCode scala&quot;&gt;&lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; today = &lt;span class=&quot;st&quot;&gt;&amp;quot;Tue&amp;quot;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (today == &lt;span class=&quot;st&quot;&gt;&amp;quot;Mon&amp;quot;&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;Weekday&amp;quot;&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (today == &lt;span class=&quot;st&quot;&gt;&amp;quot;Tue&amp;quot;&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;Weekday&amp;quot;&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (today == &lt;span class=&quot;st&quot;&gt;&amp;quot;Wed&amp;quot;&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;Weekday&amp;quot;&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (today == &lt;span class=&quot;st&quot;&gt;&amp;quot;Thu&amp;quot;&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;Weekday&amp;quot;&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (today == &lt;span class=&quot;st&quot;&gt;&amp;quot;Fri&amp;quot;&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;Weekday&amp;quot;&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (today == &lt;span class=&quot;st&quot;&gt;&amp;quot;Sat&amp;quot;&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;Weekend&amp;quot;&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (today == &lt;span class=&quot;st&quot;&gt;&amp;quot;Sun&amp;quot;&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;Weekend&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;https://asciinema.org/a/125089.js&quot; id=&quot;asciicast-125089&quot; async&gt;&lt;/script&gt;
&lt;/center&gt;
&lt;p&gt;위의 if else 구문 코드는 &lt;code&gt;today&lt;/code&gt; 요일이 언제인지에 따라 &amp;quot;Weekday&amp;quot;, &amp;quot;Weekend&amp;quot; 로 주중인지 주말인지를 출력한다.&lt;/p&gt;
&lt;p&gt;매치표현식을 이용해본 코드는&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode scala&quot;&gt;&lt;code class=&quot;sourceCode scala&quot;&gt;&lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; today = &lt;span class=&quot;st&quot;&gt;&amp;quot;Tue&amp;quot;&lt;/span&gt;

today &lt;span class=&quot;kw&quot;&gt;match&lt;/span&gt; {
  &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;Mon&amp;quot;&lt;/span&gt; | &lt;span class=&quot;st&quot;&gt;&amp;quot;Tue&amp;quot;&lt;/span&gt; | &lt;span class=&quot;st&quot;&gt;&amp;quot;Wed&amp;quot;&lt;/span&gt; | &lt;span class=&quot;st&quot;&gt;&amp;quot;Thu&amp;quot;&lt;/span&gt; | &lt;span class=&quot;st&quot;&gt;&amp;quot;Fri&amp;quot;&lt;/span&gt; =&amp;gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;Weekday&amp;quot;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;Sat&amp;quot;&lt;/span&gt; | &lt;span class=&quot;st&quot;&gt;&amp;quot;Sun&amp;quot;&lt;/span&gt; =&amp;gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;Weekend&amp;quot;&lt;/span&gt;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;https://asciinema.org/a/125090.js&quot; id=&quot;asciicast-125090&quot; async&gt;&lt;/script&gt;
&lt;/center&gt;
&lt;p&gt;&lt;code&gt;match&lt;/code&gt;, &lt;code&gt;case&lt;/code&gt; 를 통해 간결해 진 코드를 볼 때 if else 구문이 상당히 조악하게 보여졌다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;for-loop&quot;&gt;for loop&lt;/h2&gt;
&lt;p&gt;반복문 for loop 역시 스칼라에서 지원되며 강력한 기능들을 더할 수 있었다.&lt;br /&gt;
기본적인 사용법은 아래 구문 형태를 이용한다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;for (&amp;lt;식별자&amp;gt; &amp;lt;- &amp;lt;반복범위&amp;gt;) &amp;lt;표현식&amp;gt;&lt;/code&gt; 혹은 &lt;code&gt;for {&amp;lt;식별자&amp;gt; &amp;lt;- &amp;lt;반복범위&amp;gt;} &amp;lt;표현식&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;아래는 for 문을 이용하여 &amp;quot;Day1)&amp;quot; 부터 &amp;quot;Day10)&amp;quot; 까지 10개의 날을 출력하는 예제코드이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode scala&quot;&gt;&lt;code class=&quot;sourceCode scala&quot;&gt;&lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; {x &amp;lt;- &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; to &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;} &lt;span class=&quot;fu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;Day&amp;quot;&lt;/span&gt; + x + &lt;span class=&quot;st&quot;&gt;&amp;quot;) &amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;https://asciinema.org/a/125091.js&quot; id=&quot;asciicast-125091&quot; async&gt;&lt;/script&gt;
&lt;/center&gt;
&lt;h3 id=&quot;nested-for-loop&quot;&gt;Nested for loop&lt;/h3&gt;
&lt;p&gt;for 반복문을 중첩시키는 예제의 경우 스칼라에선 세련된 방법이 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode scala&quot;&gt;&lt;code class=&quot;sourceCode scala&quot;&gt;&lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; {x &amp;lt;- &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; to &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;}{
  &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; {y &amp;lt;- &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; to &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;}{
    &lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(x * y)
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위의 예제는 for문 안에 for문이 중첩하여 여섯경우의 곱 결과를 보여준다.&lt;br /&gt;
그런데 이것을 아래와 같이 간단하게 코딩을 줄이는것이 가능하다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode scala&quot;&gt;&lt;code class=&quot;sourceCode scala&quot;&gt;&lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; {x &amp;lt;- &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; to &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;; y &amp;lt;- &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; to &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;} &lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(x * y)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;두 반복자를 &lt;code&gt;;&lt;/code&gt; 를 이용해 for 문에 한꺼번에 입력하거나&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode scala&quot;&gt;&lt;code class=&quot;sourceCode scala&quot;&gt;&lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; {x &amp;lt;- &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; to &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;
     y &amp;lt;- &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; to &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;} &lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(x * y)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;문단을 나누어도 되겠다.&lt;/p&gt;
&lt;center&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;https://asciinema.org/a/130236.js&quot; id=&quot;asciicast-130236&quot; async&gt;&lt;/script&gt;
&lt;/center&gt;
</description>
        <pubDate>Tue, 06 Jun 2017 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/scala/2017/06/06/HelloScala.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/scala/2017/06/06/HelloScala.html</guid>
        
        
        <category>Scala</category>
        
      </item>
    
      <item>
        <title>클라우드 스토리지 서비스 이용을 권장하고 보편화 하려는 이유</title>
        <description>&lt;blockquote&gt;
&lt;p&gt;오늘 작성하는 문서는 내일의 작업을 더 효율적으로 만들어야 한다. - Git for Teams (엠마 제인 호그빈 웨스트비) 과 보이스카우트 규칙&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;필자는 2인 이상 공동작업 프로젝트 시 최소한 &lt;strong&gt;클라우드 스토리지 서비스를 이용해 파일을 관리하자&lt;/strong&gt;는 주장을 많이 펼치는 편이다.&lt;br /&gt;
나는 클라우드 스토리지 서비스를 &lt;a href=&quot;https://www.dropbox.com/business/landing-t61fl?_tk=sem_b_goog&amp;amp;_camp=sem-b-goog-korea&amp;amp;_kw=dropbox%7Ce&amp;amp;_ad=50011987662%7C1t1%7Cc&amp;amp;gclid=CjwKEAjw07nJBRDG_tvshefHhWQSJABRcE-ZOBclGlASA1UBYKhUJhnawAiVLXnyP748IVb2hAQswxoCEoTw_wcB&quot;&gt;드롭박스(Dropbox)&lt;/a&gt;를 통해 처음 알게 되었다.&lt;br /&gt;
드롭박스라는 서비스가 처음 출시되었을 때 (약 2007년)부터 사용했는데 그 이전과 이후의 삶을 비교해보면 확연히 다름이 느껴진다.&lt;br /&gt;
08학번인 나는 운 좋게도 이러한 서비스를 대학생이 되었을 때부터 사용할 수 있었던 환경이었다.&lt;br /&gt;
따라서 학생 시절 클라우드 스토리지 서비스에 대한 거부감이 없는 시절을 보낸 시대인 듯싶다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/CI1.png&quot;&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;본론으로 들어가 보려 한다.&lt;br /&gt;
&lt;strong&gt;글의 주제는 &amp;quot;클라우드 스토리지 서비스 이용을 권장하고 보편화하려는 이유&amp;quot; 이다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;혼자 일할 때는 개인의 컴퓨터 하드에 개인적으로만 파일을 관리하는 것은 전혀 문제 되지 않는다.&lt;br /&gt;
하지만 팀 차원에서 2인 이상이 일할 땐 위의 방식은 경험적으론 언젠간 문제가 닥쳐왔었고, 이 문제는 프로젝트가 장기적이면 장기적일수록 심각한 문제로 파생되고 뜯어고치기 쉽지 않다.&lt;/p&gt;
&lt;p&gt;자 이제 &amp;quot;개인의 컴퓨터 하드에 개인적으로만 파일을 관리&amp;quot; 의 방식을 대조군으로 설정하고 사견을 정리해 보고자 한다.&lt;/p&gt;
&lt;p&gt;팀이 만들어지는 이유를 잠깐 곱씹어 보면, 2명 이상이 바라보는 동일한 목적을 이루기 위한 이합집산이다.&lt;br /&gt;
조금 엄격하게 말한 측면도 있지만 사실은 사실이다.&lt;br /&gt;
또 한가지 엄격하게 더 말하자면 팀의 개개인별 역량과 성격은 서로 다르게 된다.&lt;br /&gt;
우리가 바라보는 그 원대한 목적은 조금 거대하고 어려워서 다양한 역량이 필요하다.&lt;br /&gt;
따라서 팀은 최대한 다른 성격, 서로 다른 역량을 가진 팀원들이 모이게 되는 것이라 생각한다.&lt;br /&gt;
개개인별로 각기 다른 역량을 발휘해 동일한 목적을 좀 더 빠르고 잘 이룰 수 있게 하려는 방법을 사회적으로 고민했고 많은 시행착오가 과거에 있었을 것이다.&lt;br /&gt;
그 결과 많은 곳에선 지속적 통합(Continuous Integration)을 대안으로 제시했다.&lt;br /&gt;
지속적 통합 없이 개개인의 역량이 꾸준하게 발휘될 경우 공동목표에서 벗어나 배가 산으로 가는 경우가 많아질 것이다.&lt;br /&gt;
이처럼 별개의 독립된 환경 속에서 각자 작업을 하다가 끝에 가서 통합을 해야 할 경우 속칭 &lt;strong&gt;&lt;a href=&quot;http://wiki.c2.com/?IntegrationHell&quot;&gt;&amp;quot;통합의 지옥&amp;quot;&lt;/a&gt; 이라 불리는 상황에 빠지게 된다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;팀단위로 일하는 프로젝트에서 &amp;quot;통합의 지옥&amp;quot;에 빠지지 않기 위해선 많은 의사소통이 필요하며, 이 소통에 투자되는 시간은 중요함과 동시에 많이 소요된다.&lt;br /&gt;
이 중요성을 정말 많은 사람들이 잘 알고 있어서인지 대부분의 업무시간이 &amp;quot;회의&amp;quot;로 꽉꽉 채워지는 사례도 많다.&lt;br /&gt;
얼마나 중요하면 정말 일을 못하고 회의만 하다가 하루를 다 보내는 걸까? 왜 이런 일이 일어나는 것일까?&lt;/p&gt;
&lt;p&gt;필자는 이 의문을 항상 가지고 근본적인 원인이 무엇 때문인지 많은 고민해 보았다.&lt;br /&gt;
그 끝에는 대조군으로 설정한 위의 방식 때문이란 결론으로 다다른다.&lt;br /&gt;
어디까지나 사견이고 과장된 생각일 수 있지만 위의 대조군 방식의 가장 우려하는 부분은&lt;br /&gt;
개개인별로 의도한 적은 없어도 자연스럽게 &amp;quot;통합의 지옥&amp;quot;을 필연적으로 만날 수 밖에 없는 틀이고, 더불어 &lt;a href=&quot;http://mstockblog.com/220816437407&quot;&gt;사일로 효과&lt;/a&gt;를 내는 근본적 원인이라는 점이다.&lt;/p&gt;
&lt;p&gt;다시 한번 말하지만, 지금은 지속적 통합을 대안으로 제시하고 있다.&lt;br /&gt;
그리고 개발자에게만 친숙할 것 같은 이 지속적 통합의 단어를 다른 일반인들에게도 손쉽게 적용코자 하는 수많은 서비스가 성공하고 있고 자리를 잡아가고 있다.&lt;br /&gt;
가장 손쉽게 적용할 수 있는 서비스가 바로 클라우드 스토리지 서비스이다.&lt;/p&gt;
&lt;p&gt;클라우드 스토리지 서비스를 이용하게 되면 다양한 이득들이 있지만&lt;br /&gt;
지금 강조하고자 하는 강점은 누구든지 공유폴더를 쉽게 만들 수 있다는 점이고, 이어서 &lt;strong&gt;팀원이 똑같은 곳을 바라보면서(Keep everyone on the same page) 지속적 통합을 유도할 수 있다&lt;/strong&gt;는 것이다.&lt;br /&gt;
인터넷만 연결된 환경이라면 &lt;a href=&quot;https://namu.wiki/w/NAS(%EC%A0%80%EC%9E%A5%EC%9E%A5%EC%B9%98)&quot;&gt;NAS(Network Attached Storage)&lt;/a&gt;처럼 일정 비용과 구축준비가 필요한 방법보단 클라우드 스토리지 서비스를 통해 이 지속적 통합을 간단히 구현할 수 있고,&lt;br /&gt;
자연스럽게 통합된 서로의 생각이 조화되면서 결과물이 만들어 질 수 있으므로 공통된 목표로 달려가는데 도움이 될 것이라 단언한다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/CI2.jpg&quot;&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://brunch.co.kr/@lunarshore/55&quot;&gt;빅데이터와 비즈니스 프로세스 - 정보 처리가 기업 경쟁력 (취합받고 깨진 파일 신경 쓰느라 날린 시간들)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;팀을 위한 Git(Git for Teams) - 엠마 제인 호그빈 웨스트비&lt;/li&gt;
&lt;li&gt;훌륭한 프로그래머 되는 법(Becoming a Better Programmer) - 피트 구들리프&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 01 Jun 2017 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/etc/2017/06/01/Continuous_Integrations.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/etc/2017/06/01/Continuous_Integrations.html</guid>
        
        
        <category>etc</category>
        
      </item>
    
      <item>
        <title>R에서 행렬 간 이루어지는 다양한 곱셈에 대해 알아보기 (행렬의 곱셈, 하다마드 곱셈, 크로네커 곱셈)</title>
        <description>&lt;p&gt;행렬과 행렬간 곱셈은 행렬 A와 B가 아래와 같이 주어졌을 때&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;img src=&quot;/assets/MatrixProduct_1.png&quot; width=&quot;500&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;행렬 A와 행렬 B의 곱은&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;img src=&quot;/assets/MatrixProduct_2.png&quot; width=&quot;450&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;이며, 이때 앞에 위치한 행렬의 열의 수와 뒤에 위치한 행렬의 행의 수가 같아야 행렬곱이 가능하다.&lt;br /&gt;
R에서 위와 같은 행렬의 곱셈을 실행하기 위해서는 &lt;code&gt;*&lt;/code&gt; 연산자가 아닌 &lt;code&gt;%*%&lt;/code&gt; 를 이용한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;(A &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;matrix&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;( &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,  &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;), &lt;span class=&quot;dt&quot;&gt;nrow =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;ncol =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] [,2]
## [1,]    2    1
## [2,]    7    3&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;(B &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;matrix&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(-&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, -&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;), &lt;span class=&quot;dt&quot;&gt;nrow =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;ncol =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] [,2]
## [1,]   -2    1
## [2,]    7   -3&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;A %*%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;B&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] [,2]
## [1,]    3   -1
## [2,]    7   -2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;일반적인 행렬의 곱셈은 &lt;code&gt;%*%&lt;/code&gt; 을 이용해야 한다고 했는데&lt;br /&gt;
그럼 &lt;code&gt;*&lt;/code&gt; 이것을 이용하면 어떻게 될까?&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;하다마드-곱셈-hadamard-product&quot;&gt;하다마드 곱셈 (Hadamard Product)&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;A *&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;B&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] [,2]
## [1,]   -4    1
## [2,]   49   -9&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;동일한 위치의 원소끼리의 곱이 되어 버린다.&lt;br /&gt;
사실 동일차원의 행렬끼리 동일위치원소와 곱해지는 곱셈을 하다마드 곱셈(Hadamard Product) 이라고도 부르는데, 위의 코드가 바로 하다마드 곱셈을 하는 코드로 볼 수 있겠다.&lt;br /&gt;
여하튼 R에서는 &lt;code&gt;%*%&lt;/code&gt; 사이에 행렬객체를 넣고 실행하면 행렬간 곱셈을,&lt;br /&gt;
&lt;code&gt;*&lt;/code&gt; 사이에 넣어주면 하다마드 곱셈을 실행킨다는 차이를 확인할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;크로네커-곱셈-kronecker-product&quot;&gt;크로네커 곱셈 (Kronecker Product)&lt;/h2&gt;
&lt;p&gt;행렬의 곱셈 중 크로네커 곱셈(Kronecker Product)이라는 것도 있다.&lt;br /&gt;
가끔 요긴하게 쓸 때가 있는 이 크로네커 곱셈은 이런 형태이다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;img src=&quot;/assets/MatrixProduct_3.png&quot; width=&quot;500&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;일 때 행렬 A와 행렬 B간 크로네커 곱셈 &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;A&lt;/em&gt; ⊗ &lt;em&gt;B&lt;/em&gt;&lt;/span&gt; 는 아래와 같다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;img src=&quot;/assets/MatrixProduct_4.png&quot; width=&quot;450&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;A&lt;/em&gt; ⊗ &lt;em&gt;B&lt;/em&gt;&lt;/span&gt; 를 계산한 후 행렬의 크기를 보게 된다면 &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;m&lt;/em&gt;&lt;em&gt;n&lt;/em&gt; × &lt;em&gt;n&lt;/em&gt;&lt;em&gt;p&lt;/em&gt;&lt;/span&gt; 행렬이 만들어 지게 될 것이다.&lt;/p&gt;
&lt;p&gt;크로네커 곱셈을 이용하면 행렬의 크기는 크되 일정한 규칙이 존재하는 행렬을 손쉽게 만들 수 있을 것이다.&lt;br /&gt;
예를들면 아래와 같은 행렬을 R에서 만들어 보겠다고 가정한다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;img src=&quot;/assets/MatrixProduct_5.png&quot; width=&quot;200&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;이 행렬 M을 만들기 위해&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;e &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;rep&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;32&lt;/span&gt;), &lt;span class=&quot;kw&quot;&gt;rep&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;24&lt;/span&gt;), &lt;span class=&quot;kw&quot;&gt;rep&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;), &lt;span class=&quot;kw&quot;&gt;rep&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;24&lt;/span&gt;), &lt;span class=&quot;kw&quot;&gt;rep&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;))
(M &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;matrix&lt;/span&gt;(e, &lt;span class=&quot;dt&quot;&gt;ncol =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##       [,1] [,2] [,3] [,4]
##  [1,]    1    1    0    0
##  [2,]    1    1    0    0
##  [3,]    1    1    0    0
##  [4,]    1    1    0    0
##  [5,]    1    1    0    0
##  [6,]    1    1    0    0
##  [7,]    1    1    0    0
##  [8,]    1    1    0    0
##  [9,]    1    0    1    0
## [10,]    1    0    1    0
## [11,]    1    0    1    0
## [12,]    1    0    1    0
## [13,]    1    0    1    0
## [14,]    1    0    1    0
## [15,]    1    0    1    0
## [16,]    1    0    1    0
## [17,]    1    0    0    1
## [18,]    1    0    0    1
## [19,]    1    0    0    1
## [20,]    1    0    0    1
## [21,]    1    0    0    1
## [22,]    1    0    0    1
## [23,]    1    0    0    1
## [24,]    1    0    0    1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;와 같은 형식의 코드를 짤 수도 있다.&lt;br /&gt;
하지만 &lt;code&gt;c(rep(1, 32), rep(0, 24), rep(1, 8), rep(0, 24), rep(1, 8))&lt;/code&gt; 처럼 손이 많이 가는 코드를 작성해야 하는데, 크로네커 곱셈을 약간 응용하면 행렬 M을 좀 더 편하게 만들 수 있을 것이다.&lt;br /&gt;
R에서 크로네커 곱셈을 수행하는 함수는 &lt;code&gt;kronecker()&lt;/code&gt; 이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;(A &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;matrix&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;), &lt;span class=&quot;dt&quot;&gt;ncol =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] [,2] [,3] [,4]
## [1,]    1    1    0    0
## [2,]    1    0    1    0
## [3,]    1    0    0    1&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;(B &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;matrix&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;rep&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;)))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##      [,1]
## [1,]    1
## [2,]    1
## [3,]    1
## [4,]    1
## [5,]    1
## [6,]    1
## [7,]    1
## [8,]    1&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;(M &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;kronecker&lt;/span&gt;(A, B))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##       [,1] [,2] [,3] [,4]
##  [1,]    1    1    0    0
##  [2,]    1    1    0    0
##  [3,]    1    1    0    0
##  [4,]    1    1    0    0
##  [5,]    1    1    0    0
##  [6,]    1    1    0    0
##  [7,]    1    1    0    0
##  [8,]    1    1    0    0
##  [9,]    1    0    1    0
## [10,]    1    0    1    0
## [11,]    1    0    1    0
## [12,]    1    0    1    0
## [13,]    1    0    1    0
## [14,]    1    0    1    0
## [15,]    1    0    1    0
## [16,]    1    0    1    0
## [17,]    1    0    0    1
## [18,]    1    0    0    1
## [19,]    1    0    0    1
## [20,]    1    0    0    1
## [21,]    1    0    0    1
## [22,]    1    0    0    1
## [23,]    1    0    0    1
## [24,]    1    0    0    1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이처럼 &lt;code&gt;kronecker(A, B)&lt;/code&gt; 코드를 실행하면 &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;A&lt;/em&gt; ⊗ &lt;em&gt;B&lt;/em&gt;&lt;/span&gt; 를 연산해준다.&lt;/p&gt;
</description>
        <pubDate>Tue, 30 May 2017 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2017/05/30/MatrixProduct.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2017/05/30/MatrixProduct.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>온라인 설문지 서비스 Typeform 소개, 설문조사 방법에 대한 설문조사</title>
        <description>&lt;p&gt;평범한 일상생활 속에서도 사람의 생각과 의견을 수렴할 일들은 참 많이 일어난다.&lt;br /&gt;
필자의 경우 학창시절을 돌이켜 볼 때 통계관련 수업시 툭하면 마주하는 프로젝트가 &amp;quot;설문조사&amp;quot; 와 관련된 것이었다.&lt;br /&gt;
이때마다 설문지를 워드나 한글로 타이핑하고 굳이 출력해서 손수 나눠준 후 일일이 되돌려 받는 형식의 설문조사가 일방적으로 이루어졌다.&lt;br /&gt;
설문지를 취합해서 코딩과 펀칭을 하는 수고는 즐겁기도 하면서 손이 많이 가고 큰 정성을 필요로 했다.&lt;br /&gt;
반대로 설문지를 응답하는 상황에서도 이러한 형태의 설문조사방식을 많이 겪는 편인 것 같다.&lt;/p&gt;
&lt;p&gt;설문조사자로서의 입장, 그리고 설문응답자로서의 입장들을 겪을 때마다 느껴지는 질문은&lt;br /&gt;
&amp;quot;의견을 온전하게 전달하고 받을 수 있는 최선의 방법은 무엇일까?&amp;quot; 이다.&lt;br /&gt;
소통은 &lt;strong&gt;말하는 사람&lt;/strong&gt;과 &lt;strong&gt;듣는 사람&lt;/strong&gt; 그리고 &lt;strong&gt;전달 매체(언어)&lt;/strong&gt; 이렇게 3가지 요소가 있는데&lt;br /&gt;
설문조사 측면에선 &lt;strong&gt;조사자&lt;/strong&gt;, &lt;strong&gt;응답자&lt;/strong&gt;, 그리고 &lt;strong&gt;조사방법&lt;/strong&gt; 이렇게 3가지 요소와 비슷하다고 생각한다.&lt;br /&gt;
소통에서 전달 매체의 선택이 잘못될 경우 소통이 불가하다.&lt;br /&gt;
이처럼 설문조사에서 조사방법을 잘 선택하고 설계하는 것은 중요한 문제이다.&lt;/p&gt;
&lt;p&gt;그런 의미에서 여러 시도를 해보고 있다.&lt;br /&gt;
지금까지도 많이 쓰이는 전통적인 종이 설문지 배포 및 수거 방법 외에 다른 방법들이 무엇이 있을까 찾아보고 있고&lt;br /&gt;
좀 더 현명한 방법은 무엇일지 실험을 해보고 있다.&lt;/p&gt;
&lt;p&gt;그중 최근 한 실험은 &lt;a href=&quot;https://www.typeform.com&quot;&gt;Typeform&lt;/a&gt; 과 같은 툴을 이용해 온라인 설문조사 방식이다.&lt;br /&gt;
아래는 Typeform 서비스의 힘을 빌려 만들어 본 설문지이다.&lt;br /&gt;
주제는 이글과 연관있는 &amp;quot;설문조사 방법에 대한 설문조사&amp;quot; 이다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;통계 R 프로그래밍 카페에 배포한 온라인 설문지 (관심있다면 설문응답 해주셔도 됩니다)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;typeform-widget&quot; data-url=&quot;https://lovetoken.typeform.com/to/oQCtip&quot; style=&quot;width: 100%; height: 1100px;&quot;&gt;

&lt;/div&gt;
&lt;script&gt;(function(){var qs,js,q,s,d=document,gi=d.getElementById,ce=d.createElement,gt=d.getElementsByTagName,id=&quot;typef_orm&quot;,b=&quot;https://s3-eu-west-1.amazonaws.com/share.typeform.com/&quot;;if(!gi.call(d,id)){js=ce.call(d,&quot;script&quot;);js.id=id;js.src=b+&quot;widget.js&quot;;q=gt.call(d,&quot;script&quot;)[0];q.parentNode.insertBefore(js,q)}})()&lt;/script&gt;
&lt;div style=&quot;font-family: Sans-Serif;font-size: 12px;color: #999;opacity: 0.5; padding-top: 5px;&quot;&gt;
powered by &lt;a href=&quot;https://www.typeform.com/examples/?utm_campaign=oQCtip&amp;amp;utm_source=typeform.com-7938314-Basic&amp;amp;utm_medium=typeform&amp;amp;utm_content=typeform-embedded-poweredbytypeform&amp;amp;utm_term=KO&quot; style=&quot;color: #999&quot; target=&quot;_blank&quot;&gt;Typeform&lt;/a&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;위와 같이 온라인 설문조사를 직접 만들고 배포를 도와주는 서비스는 여러 가지가 있다.&lt;/p&gt;
&lt;p&gt;가장 대중적인 &lt;a href=&quot;https://www.google.com/intl/ko_kr/forms/about/&quot;&gt;Google docs&lt;/a&gt; 부터 시작해 &lt;a href=&quot;https://ko.surveymonkey.com&quot;&gt;Surveymonkey&lt;/a&gt;, &lt;a href=&quot;https://www.mysurveyasia.co.kr&quot;&gt;Mysurvey&lt;/a&gt;, &lt;a href=&quot;https://www.typeform.com&quot;&gt;Typeform&lt;/a&gt; 등이 있으며&lt;br /&gt;
국내서비스로는 &lt;a href=&quot;http://www.nownsurvey.com&quot;&gt;나우서베이&lt;/a&gt;, &lt;a href=&quot;http://www.ozsurvey.co.kr&quot;&gt;오즈서베이&lt;/a&gt; 등이 있다.&lt;/p&gt;
&lt;p&gt;이 중에서 가장 최근에 서비스를 시작한(2014년)&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; Typeform 의 인기가 요즘 높다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;typeform-소개&quot;&gt;Typeform 소개&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Typeform.com Explainer Video&lt;/p&gt;
&lt;/blockquote&gt;
&lt;iframe width=&quot;100%&quot; height=&quot;350&quot; src=&quot;https://www.youtube.com/embed/5ghyOrFDdaY&quot; frameborder=&quot;0&quot; allowfullscreen&gt;
&lt;/iframe&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;온라인 설문서비스는 딱히 설명할 필요가 없을 정도로 GUI 가 매우 잘 되어있는 편이다.&lt;br /&gt;
&amp;quot;선 배움 후 실습&amp;quot; 이 아닌 &amp;quot;선 실습 후 배움&amp;quot; 이 가능한 서비스이다. 쉽기 때문에 이게 가능하다.&lt;br /&gt;
Typeform 역시 마찬가지이다. 가입 후에 로그인하는 즉시 웹상에서 동작한다.&lt;br /&gt;
이것저것 만져보고 단순한 설문문서를 만들어 보자.&lt;br /&gt;
필자가 만든 위 설문지 역시 &lt;a href=&quot;https://www.typeform.com/tour/&quot;&gt;공식 홈페이지의 튜토리얼&lt;/a&gt;을 1분도 안 보고 만든 첫 설문지이다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/tf1.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/tf2.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;설문 문항은 드래그 &amp;amp; 드랍 방식으로 원하는 곳에 배치할 수 있고&lt;br /&gt;
작은 글과 응답 유형별로 제공되는 메뉴를 통해 손쉽게 만들 수 있다.&lt;br /&gt;
구조적인 설문지가 아닌 이상 Multiple choice 기능만으로 설문지를 만드는데 아무 문제가 없을 것이다.&lt;/p&gt;
&lt;p&gt;만드는 즉시 설문지를 배포할 수 있는 링크가 생긴다.&lt;br /&gt;
그 링크는 상단에 Build, Design, Configure, Share, Analyze 5개의 메뉴 중 Share 로 들어가 보면&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/tf3.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;copy 버튼을 눌러 링크를 이용할 수 있다.&lt;br /&gt;
이 링크를 통해 언제 어디서든 응답자에게 설문지를 배포하고 시간과 장소 제약 없이 응답할 수 있게 된다.&lt;/p&gt;
&lt;p&gt;만약 응답자가 링크를 클릭 후 설문에 응답하여 제출버튼을 누른다면&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/tf4.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;설문지를 만든 관리자는&lt;br /&gt;
그 응답자의 결과뿐만 아니라 지금까지 모든 응답에 대해 취합한 report 를 Analyze 메뉴를 통해 확인할 수 있다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/tf5.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;취합결과 역시 &lt;a href=&quot;https://lovetoken.typeform.com/report/oQCtip/vVGD&quot;&gt;여기처럼&lt;/a&gt; 외부링크를 뽑아올 수 있어 공유가 가능하다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/tf6.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;Design 메뉴를 통해 설문지의 템플릿을 원하는 것으로 바꿀 수 있다.&lt;br /&gt;
클릭 몇 번만으로 수려한 디자인의 설문지를 만들 수 있겠다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/tf7.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/tf8.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;이정도만 알아도 사실 다 안 것이고 설문조사를 하는데 아무 문제 없다.&lt;br /&gt;
단 구조화된 설문지(조건부 별로 다른 조사항목이 출현하는 예), 응답완료에 대한 확인메일송신 기능, 파일 업로드 기능 활성화, 응답 및 조사항목 제한해제등을 위해선 요금을 내고 Pro upgrade 를 해야한다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;온라인-설문의-대중화&quot;&gt;온라인 설문의 대중화&lt;/h2&gt;
&lt;p&gt;전통적인 설문방법(설문지를 출력해서 손수 나눠준 후 되돌려 받는 형식)과 온라인 설문방법은 각기 장단점이 존재한다.&lt;br /&gt;
전통적인 설문방법의 장점은 누구든지 쉽게 떠올릴 수 있는 방법이고 펜과 종이만 있으면 가능하다.&lt;br /&gt;
상황에 따라 면대면으로 심층적인 설문을 할 수 있다.&lt;br /&gt;
무엇보다 가장 큰 장점은 전통적이라는 의미에는 전혀 거부감이 없다는 의미를 내포한다는 점에 있다.&lt;/p&gt;
&lt;p&gt;온라인 설문의 장점은 비대면 방식의 특징으로 생기는 것들에 있다.&lt;br /&gt;
설문조사자의 눈치를 보지 않고 언제 어디서든 자유롭게 응답할 수 있기 때문에 오히려 왜곡되지 않는 온전한 의견을 조사자가 응답받을 수도 있다.&lt;br /&gt;
간편한 방법을 통해 응답회수율을 높일 수 있으며,&lt;br /&gt;
응답 이후 관리 측면에서는 전통적인 설문방법과 비교될 수 없는 높은 생산성을 가지고 있다.&lt;/p&gt;
&lt;p&gt;이처럼 각자의 장점들이 있다.&lt;br /&gt;
그런데 (Typeform 서비스를 예로 들었지만 이러한) 온라인 설문 서비스를 알기 전에는 편의성이 얼마나 높은지 인지할 수 없었다.&lt;br /&gt;
그리고 인터넷 매체의 발전에 힘입어 온라인 설문은 자연스럽게 대중화되었고 많은 사람이 채택하는 방법이 되었다.&lt;br /&gt;
필자는 수백명 단위의 응답자와 종이 설문지들에 파묻혀 온 시간을 쏟아 리서치를 한 경험이 많았는데&lt;br /&gt;
자괴감을 많이 느낄 정도로 온라인 설문은 큰 강점을 가지고 있음을 뒤늦게 깨달은 것 같다.&lt;/p&gt;
&lt;p&gt;대세는 거스를 수 없다. 대중화되는 이유를 살펴보고 이용해 봄으로써 새로운 방법을 인지하고 싶다면,&lt;br /&gt;
특히 리서치를 사서 고생하는 느낌이 든다면 이러한 서비스를 적극적으로 사용해 보길 추천하고 싶다.&lt;/p&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;&lt;a href=&quot;https://thenextweb.com/apps/2014/02/12/typeform/#.tnw_KfglfLLI&quot;&gt;Steve O&#39;Hear (September 23, 2014). &amp;quot;Online Survey And Form Builder Typeform Raises €1.2M&amp;quot;.&lt;/a&gt;&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Thu, 04 May 2017 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/etc/2017/05/04/Typeform.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/etc/2017/05/04/Typeform.html</guid>
        
        
        <category>etc</category>
        
      </item>
    
      <item>
        <title>R에서 caret package 를 이용한 데이터 학습 간편화 전략</title>
        <description>&lt;p&gt;기계학습(Machine Learning) 에서 기법이 무엇이 되든, 어떤 알고리즘을 사용할 것이든 공통으로 필요한 과정은 &amp;quot;Learning&amp;quot; 즉 &amp;quot;학습&amp;quot;이다.&lt;br /&gt;
학습의 대상은 전통적으로 훈련데이터(Training dataset)이고, 훈련데이터를 학습시키는 아주 다양한 방법들이 존재한다.&lt;br /&gt;
방법별로 원리와 특징 및 색깔이 다르며, 무엇보다 &lt;strong&gt;워낙 다양한 방법들이 존재하기 때문&lt;/strong&gt;에 아무리 많이 공부를 한 사람이라 한들 모든 알고리즘을 아는것이 한계가 있다고 생각한다.&lt;br /&gt;
때문에 무엇을 채택해서 어느 정도의 파라미터값을 부여해야 알맞은 모델을 만들 수 있을지 현실적인 문제에 부딪히게 된다.&lt;/p&gt;
&lt;p&gt;R에서 배포되고 있는 머신러닝 관련 패키지의 개수는 &lt;a href=&quot;https://cran.r-project.org/web/views/MachineLearning.html&quot;&gt;CRAN Task View: Machine Learning &amp;amp; Statistical Learning&lt;/a&gt;만을 보아도 수십개가 된다.&lt;br /&gt;
이 패키지들을 모두 하나하나 실행해서 상황에 맞는 모델링을 하기 위해 비교실험을 해보는 것도 가능할 것이다.&lt;br /&gt;
하지만 패키지별로 사용방식이 많이 다를 수 있어 이를 인지하는데도 많은 시간이 걸리고, 비교해보고 싶은 알고리즘의 패키지를 찾아 설치하고 로드하는 것 마저 부담으로 다가올 수 있겠다.&lt;/p&gt;
&lt;p&gt;이러한 상황에서 caret 패키지는 예측모델을 만들기 위한 데이터 학습 시 간편한 함수를 제공해 준다.&lt;br /&gt;
특히 금일&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;기준 242개의 머신러닝 알고리즘을 표준화된 인터페이스를 통해 테스트 해 볼 수 있도록 준비가 되어 있고,&lt;br /&gt;
이에 대해서 다양한 파라미터 시나리오를 구성해 손쉽게 튜닝해주고 변수의 중요도를 측정해준다.&lt;br /&gt;
사용자는 편리한 훈련데이터의 학습을 통해 적절한 알고리즘 선택 의사결정에 도움을 받을 수 있다.&lt;/p&gt;
&lt;p&gt;이러한 기대효과를 가진 caret package 에 대해 소개하는 시간을 가져보도록 하겠다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/caret.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;caret 패키지의 명칭은 &amp;quot;&lt;strong&gt;C&lt;/strong&gt;lassification &lt;strong&gt;A&lt;/strong&gt;nd &lt;strong&gt;RE&lt;/strong&gt;gression &lt;strong&gt;T&lt;/strong&gt;raining&amp;quot; 의 앞글자를 따와 명명되었다.&lt;br /&gt;
주 관심 대상이 되는 종속변수(예측변수)가 명목형 변수라면 &amp;quot;Classification&amp;quot;, 연속형 변수라면 &amp;quot;Regression&amp;quot; 으로 갈피를 잡아 &amp;quot;Training&amp;quot; 을 하게 될 텐데, 이 과정을 caret 패키지를 이용해 코딩해 본 가장 간단한 예제로 시작해 보겠다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(tidyverse) &lt;span class=&quot;co&quot;&gt;# for tidy tools (pipe operation, tibble, etc..)&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(caret)

&lt;span class=&quot;kw&quot;&gt;set.seed&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1234&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# for reproducibility&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt;(Sonar, &lt;span class=&quot;dt&quot;&gt;package =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;mlbench&amp;quot;&lt;/span&gt;)
Sonar &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;Sonar %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;tbl_df
Sonar&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 208 x 61
##        V1     V2     V3     V4     V5     V6     V7     V8     V9    V10
## *   &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;
## 1  0.0200 0.0371 0.0428 0.0207 0.0954 0.0986 0.1539 0.1601 0.3109 0.2111
## 2  0.0453 0.0523 0.0843 0.0689 0.1183 0.2583 0.2156 0.3481 0.3337 0.2872
## 3  0.0262 0.0582 0.1099 0.1083 0.0974 0.2280 0.2431 0.3771 0.5598 0.6194
## 4  0.0100 0.0171 0.0623 0.0205 0.0205 0.0368 0.1098 0.1276 0.0598 0.1264
## 5  0.0762 0.0666 0.0481 0.0394 0.0590 0.0649 0.1209 0.2467 0.3564 0.4459
## 6  0.0286 0.0453 0.0277 0.0174 0.0384 0.0990 0.1201 0.1833 0.2105 0.3039
## 7  0.0317 0.0956 0.1321 0.1408 0.1674 0.1710 0.0731 0.1401 0.2083 0.3513
## 8  0.0519 0.0548 0.0842 0.0319 0.1158 0.0922 0.1027 0.0613 0.1465 0.2838
## 9  0.0223 0.0375 0.0484 0.0475 0.0647 0.0591 0.0753 0.0098 0.0684 0.1487
## 10 0.0164 0.0173 0.0347 0.0070 0.0187 0.0671 0.1056 0.0697 0.0962 0.0251
## # ... with 198 more rows, and 51 more variables: V11 &amp;lt;dbl&amp;gt;, V12 &amp;lt;dbl&amp;gt;,
## #   V13 &amp;lt;dbl&amp;gt;, V14 &amp;lt;dbl&amp;gt;, V15 &amp;lt;dbl&amp;gt;, V16 &amp;lt;dbl&amp;gt;, V17 &amp;lt;dbl&amp;gt;, V18 &amp;lt;dbl&amp;gt;,
## #   V19 &amp;lt;dbl&amp;gt;, V20 &amp;lt;dbl&amp;gt;, V21 &amp;lt;dbl&amp;gt;, V22 &amp;lt;dbl&amp;gt;, V23 &amp;lt;dbl&amp;gt;, V24 &amp;lt;dbl&amp;gt;,
## #   V25 &amp;lt;dbl&amp;gt;, V26 &amp;lt;dbl&amp;gt;, V27 &amp;lt;dbl&amp;gt;, V28 &amp;lt;dbl&amp;gt;, V29 &amp;lt;dbl&amp;gt;, V30 &amp;lt;dbl&amp;gt;,
## #   V31 &amp;lt;dbl&amp;gt;, V32 &amp;lt;dbl&amp;gt;, V33 &amp;lt;dbl&amp;gt;, V34 &amp;lt;dbl&amp;gt;, V35 &amp;lt;dbl&amp;gt;, V36 &amp;lt;dbl&amp;gt;,
## #   V37 &amp;lt;dbl&amp;gt;, V38 &amp;lt;dbl&amp;gt;, V39 &amp;lt;dbl&amp;gt;, V40 &amp;lt;dbl&amp;gt;, V41 &amp;lt;dbl&amp;gt;, V42 &amp;lt;dbl&amp;gt;,
## #   V43 &amp;lt;dbl&amp;gt;, V44 &amp;lt;dbl&amp;gt;, V45 &amp;lt;dbl&amp;gt;, V46 &amp;lt;dbl&amp;gt;, V47 &amp;lt;dbl&amp;gt;, V48 &amp;lt;dbl&amp;gt;,
## #   V49 &amp;lt;dbl&amp;gt;, V50 &amp;lt;dbl&amp;gt;, V51 &amp;lt;dbl&amp;gt;, V52 &amp;lt;dbl&amp;gt;, V53 &amp;lt;dbl&amp;gt;, V54 &amp;lt;dbl&amp;gt;,
## #   V55 &amp;lt;dbl&amp;gt;, V56 &amp;lt;dbl&amp;gt;, V57 &amp;lt;dbl&amp;gt;, V58 &amp;lt;dbl&amp;gt;, V59 &amp;lt;dbl&amp;gt;, V60 &amp;lt;dbl&amp;gt;,
## #   Class &amp;lt;fctr&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;예제에 사용할 데이터셋은 &lt;code&gt;mlbench::Sonar&lt;/code&gt; 을 이용해보겠으며 예측대상변수는 &lt;code&gt;Class&lt;/code&gt; 라는 명칭의 명목형으로 M, R 2개의 이분값이 담겨있다.&lt;br /&gt;
이를 예측하는 다양한 모델을 만들어 볼 것이다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;createdatapartition-함수&quot;&gt;&lt;code&gt;createDataPartition()&lt;/code&gt; 함수&lt;/h2&gt;
&lt;p&gt;첫번째로 훈련데이터셋(Training dataset)과 테스트데이터셋(Test dataset)을 나누어 추후에 모델평가에 이용할 준비를 해보겠다. 비율은 70%를 훈련데이터셋에 배정하겠다.&lt;br /&gt;
&lt;code&gt;sample()&lt;/code&gt; 함수를 이용해 훈련데이터셋과 테스트데이터셋의 파티셔닝을 해 볼 수 있지만&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;indexTrain &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;sample&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;kw&quot;&gt;nrow&lt;/span&gt;(Sonar), &lt;span class=&quot;kw&quot;&gt;round&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;nrow&lt;/span&gt;(Sonar) *&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;.&lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;))
training &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;Sonar[ indexTrain, ]
testing  &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;Sonar[-indexTrain, ]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;caret 패키지에 있는 &lt;code&gt;createDataPartition()&lt;/code&gt; 함수를 이용해 볼 수도 있다.&lt;br /&gt;
이 함수에는 &lt;code&gt;p&lt;/code&gt; 인자가 있어 특정비율로 파티셔닝할 때 편하다.&lt;br /&gt;
또한 위의 예제코드 &lt;code&gt;sample()&lt;/code&gt; 함수를 이용할 때는 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EB%8B%A8%EC%88%9C_%EB%AC%B4%EC%9E%91%EC%9C%84_%EC%B6%94%EC%B6%9C%EB%B2%95&quot;&gt;완전무작위추출(SRS; Simple Random Sampling)&lt;/a&gt; 이 되기 때문에 종속변수의 요인별 비율을 고려하지 않고 무작위 샘플링이 되지만, &lt;code&gt;createDataPartition()&lt;/code&gt; 함수를 이용할 경우 종속변수의 요인별 비율만큼 층화랜덤추출을 기본적으로 지원하기 때문에 안전하고 요긴하다.&lt;br /&gt;
단 반환되는 타입이 기본적으로 list 이므로 &lt;code&gt;list&lt;/code&gt; 인자값을 &lt;code&gt;FALSE&lt;/code&gt;로 해 보았다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;indexTrain &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;createDataPartition&lt;/span&gt;(Sonar$Class, &lt;span class=&quot;dt&quot;&gt;p =&lt;/span&gt; .&lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;list =&lt;/span&gt; F)
training &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;Sonar[ indexTrain, ]
testing  &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;Sonar[-indexTrain, ]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;7:3 비율만큼 잘 파티셔닝이 되어있는지 확인해 보면&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;training&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 148 x 61
##        V1     V2     V3     V4     V5     V6     V7     V8     V9    V10
##     &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;
## 1  0.0262 0.0582 0.1099 0.1083 0.0974 0.2280 0.2431 0.3771 0.5598 0.6194
## 2  0.0100 0.0171 0.0623 0.0205 0.0205 0.0368 0.1098 0.1276 0.0598 0.1264
## 3  0.0286 0.0453 0.0277 0.0174 0.0384 0.0990 0.1201 0.1833 0.2105 0.3039
## 4  0.0519 0.0548 0.0842 0.0319 0.1158 0.0922 0.1027 0.0613 0.1465 0.2838
## 5  0.0223 0.0375 0.0484 0.0475 0.0647 0.0591 0.0753 0.0098 0.0684 0.1487
## 6  0.0164 0.0173 0.0347 0.0070 0.0187 0.0671 0.1056 0.0697 0.0962 0.0251
## 7  0.0039 0.0063 0.0152 0.0336 0.0310 0.0284 0.0396 0.0272 0.0323 0.0452
## 8  0.0123 0.0309 0.0169 0.0313 0.0358 0.0102 0.0182 0.0579 0.1122 0.0835
## 9  0.0090 0.0062 0.0253 0.0489 0.1197 0.1589 0.1392 0.0987 0.0955 0.1895
## 10 0.0298 0.0615 0.0650 0.0921 0.1615 0.2294 0.2176 0.2033 0.1459 0.0852
## # ... with 138 more rows, and 51 more variables: V11 &amp;lt;dbl&amp;gt;, V12 &amp;lt;dbl&amp;gt;,
## #   V13 &amp;lt;dbl&amp;gt;, V14 &amp;lt;dbl&amp;gt;, V15 &amp;lt;dbl&amp;gt;, V16 &amp;lt;dbl&amp;gt;, V17 &amp;lt;dbl&amp;gt;, V18 &amp;lt;dbl&amp;gt;,
## #   V19 &amp;lt;dbl&amp;gt;, V20 &amp;lt;dbl&amp;gt;, V21 &amp;lt;dbl&amp;gt;, V22 &amp;lt;dbl&amp;gt;, V23 &amp;lt;dbl&amp;gt;, V24 &amp;lt;dbl&amp;gt;,
## #   V25 &amp;lt;dbl&amp;gt;, V26 &amp;lt;dbl&amp;gt;, V27 &amp;lt;dbl&amp;gt;, V28 &amp;lt;dbl&amp;gt;, V29 &amp;lt;dbl&amp;gt;, V30 &amp;lt;dbl&amp;gt;,
## #   V31 &amp;lt;dbl&amp;gt;, V32 &amp;lt;dbl&amp;gt;, V33 &amp;lt;dbl&amp;gt;, V34 &amp;lt;dbl&amp;gt;, V35 &amp;lt;dbl&amp;gt;, V36 &amp;lt;dbl&amp;gt;,
## #   V37 &amp;lt;dbl&amp;gt;, V38 &amp;lt;dbl&amp;gt;, V39 &amp;lt;dbl&amp;gt;, V40 &amp;lt;dbl&amp;gt;, V41 &amp;lt;dbl&amp;gt;, V42 &amp;lt;dbl&amp;gt;,
## #   V43 &amp;lt;dbl&amp;gt;, V44 &amp;lt;dbl&amp;gt;, V45 &amp;lt;dbl&amp;gt;, V46 &amp;lt;dbl&amp;gt;, V47 &amp;lt;dbl&amp;gt;, V48 &amp;lt;dbl&amp;gt;,
## #   V49 &amp;lt;dbl&amp;gt;, V50 &amp;lt;dbl&amp;gt;, V51 &amp;lt;dbl&amp;gt;, V52 &amp;lt;dbl&amp;gt;, V53 &amp;lt;dbl&amp;gt;, V54 &amp;lt;dbl&amp;gt;,
## #   V55 &amp;lt;dbl&amp;gt;, V56 &amp;lt;dbl&amp;gt;, V57 &amp;lt;dbl&amp;gt;, V58 &amp;lt;dbl&amp;gt;, V59 &amp;lt;dbl&amp;gt;, V60 &amp;lt;dbl&amp;gt;,
## #   Class &amp;lt;fctr&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;testing&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 60 x 61
##        V1     V2     V3     V4     V5     V6     V7     V8     V9    V10
##     &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;
## 1  0.0200 0.0371 0.0428 0.0207 0.0954 0.0986 0.1539 0.1601 0.3109 0.2111
## 2  0.0453 0.0523 0.0843 0.0689 0.1183 0.2583 0.2156 0.3481 0.3337 0.2872
## 3  0.0762 0.0666 0.0481 0.0394 0.0590 0.0649 0.1209 0.2467 0.3564 0.4459
## 4  0.0317 0.0956 0.1321 0.1408 0.1674 0.1710 0.0731 0.1401 0.2083 0.3513
## 5  0.0079 0.0086 0.0055 0.0250 0.0344 0.0546 0.0528 0.0958 0.1009 0.1240
## 6  0.0124 0.0433 0.0604 0.0449 0.0597 0.0355 0.0531 0.0343 0.1052 0.2120
## 7  0.0126 0.0149 0.0641 0.1732 0.2565 0.2559 0.2947 0.4110 0.4983 0.5920
## 8  0.0473 0.0509 0.0819 0.1252 0.1783 0.3070 0.3008 0.2362 0.3830 0.3759
## 9  0.0099 0.0484 0.0299 0.0297 0.0652 0.1077 0.2363 0.2385 0.0075 0.1882
## 10 0.0151 0.0320 0.0599 0.1050 0.1163 0.1734 0.1679 0.1119 0.0889 0.1205
## # ... with 50 more rows, and 51 more variables: V11 &amp;lt;dbl&amp;gt;, V12 &amp;lt;dbl&amp;gt;,
## #   V13 &amp;lt;dbl&amp;gt;, V14 &amp;lt;dbl&amp;gt;, V15 &amp;lt;dbl&amp;gt;, V16 &amp;lt;dbl&amp;gt;, V17 &amp;lt;dbl&amp;gt;, V18 &amp;lt;dbl&amp;gt;,
## #   V19 &amp;lt;dbl&amp;gt;, V20 &amp;lt;dbl&amp;gt;, V21 &amp;lt;dbl&amp;gt;, V22 &amp;lt;dbl&amp;gt;, V23 &amp;lt;dbl&amp;gt;, V24 &amp;lt;dbl&amp;gt;,
## #   V25 &amp;lt;dbl&amp;gt;, V26 &amp;lt;dbl&amp;gt;, V27 &amp;lt;dbl&amp;gt;, V28 &amp;lt;dbl&amp;gt;, V29 &amp;lt;dbl&amp;gt;, V30 &amp;lt;dbl&amp;gt;,
## #   V31 &amp;lt;dbl&amp;gt;, V32 &amp;lt;dbl&amp;gt;, V33 &amp;lt;dbl&amp;gt;, V34 &amp;lt;dbl&amp;gt;, V35 &amp;lt;dbl&amp;gt;, V36 &amp;lt;dbl&amp;gt;,
## #   V37 &amp;lt;dbl&amp;gt;, V38 &amp;lt;dbl&amp;gt;, V39 &amp;lt;dbl&amp;gt;, V40 &amp;lt;dbl&amp;gt;, V41 &amp;lt;dbl&amp;gt;, V42 &amp;lt;dbl&amp;gt;,
## #   V43 &amp;lt;dbl&amp;gt;, V44 &amp;lt;dbl&amp;gt;, V45 &amp;lt;dbl&amp;gt;, V46 &amp;lt;dbl&amp;gt;, V47 &amp;lt;dbl&amp;gt;, V48 &amp;lt;dbl&amp;gt;,
## #   V49 &amp;lt;dbl&amp;gt;, V50 &amp;lt;dbl&amp;gt;, V51 &amp;lt;dbl&amp;gt;, V52 &amp;lt;dbl&amp;gt;, V53 &amp;lt;dbl&amp;gt;, V54 &amp;lt;dbl&amp;gt;,
## #   V55 &amp;lt;dbl&amp;gt;, V56 &amp;lt;dbl&amp;gt;, V57 &amp;lt;dbl&amp;gt;, V58 &amp;lt;dbl&amp;gt;, V59 &amp;lt;dbl&amp;gt;, V60 &amp;lt;dbl&amp;gt;,
## #   Class &amp;lt;fctr&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;훈련데이터셋이 148개, 테스트데이터셋이 60개로 잘 나누어진 것을 볼 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;머신러닝-알고리즘별-최적의-모수를-찾기-위한-학습방법-사전-설정&quot;&gt;머신러닝 알고리즘별 최적의 모수를 찾기 위한 학습방법 사전 설정&lt;/h2&gt;
&lt;p&gt;K 최근접 이웃모델 즉 KNN(K-Neareast Neighbors) 을 통해 명목변수를 예측하려 한다면&lt;br /&gt;
그 이전에 선행되어야 할 것이 &amp;quot;K&amp;quot; 를 몇개로 설정할 것이냐이다.&lt;br /&gt;
랜덤포레스트(RandomForest) 를 이용하려 한다면 노드를 나눌 기준으로 고려할 변수의 개수인 &amp;quot;mtry&amp;quot; 를 얼마로 정해야 할지도 마찬가지이다.&lt;br /&gt;
위의 예시에서 &amp;quot;K&amp;quot;, &amp;quot;mtry&amp;quot; 와 같은 모수는 예비조사를 통해 사람이 정하거나, 데이터에 근거해 최적의 군집개수를 정하는 과정을 통해 (방법이 어떻게 되었든) 정해져야 모델링을 할 수 있다. (단 비모수적 모델링이라면 제외되는 이야기이겠다)&lt;br /&gt;
이처럼 알고리즘 별로 반드시 정해져야 모델링을 실시 할 수 있는 모수들을 caret package 에선 &amp;quot;Tuning parameters&amp;quot; 로 설명하고 있고, LOOCV, K-fold cross validation 등과 같은 방법을 통해서 데이터에 근거한 최적의 parameter 를 찾는 과정을 거친다.&lt;/p&gt;
&lt;p&gt;알고리즘별로 튜닝 파라미터 개수는 달라지는데 p개의 파라미터일 경우 &lt;span class=&quot;math inline&quot;&gt;3&lt;sup&gt;&lt;em&gt;P&lt;/em&gt;&lt;/sup&gt;&lt;/span&gt; 의 그리드를 탐색하여 후보모델들을 테스트하게 된다.&lt;/p&gt;
&lt;p&gt;예를 들면 이렇다.&lt;br /&gt;
KNN(K-Neareast Neighbors) 는 K 하나인 단모수이므로 &lt;span class=&quot;math inline&quot;&gt;3&lt;sup&gt;1&lt;/sup&gt; = 3&lt;/span&gt; 인 3가지 K 값들을 후보로 두고 모델을 비교하게 된다.&lt;br /&gt;
RRLDA(Robust Regularized Linear Discriminant Analysis) 의 경우 모수의 개수가 lambda, hp, penalty 총 3개인데 &lt;span class=&quot;math inline&quot;&gt;3&lt;sup&gt;3&lt;/sup&gt; = 27&lt;/span&gt; 인 27가지 후보를 비교하게 될 것이다.&lt;/p&gt;
&lt;p&gt;3개이던 27개 이던 다수의 후보에 대해서 비교하는 방식 또한 고려대상이다.&lt;br /&gt;
후보의 비교방법을 K-fold cross validation 으로 한다고 할 경우 몇번을 접어 cross validation 을 할 것이냐 란 질문의 K 를 정해야 한다.&lt;br /&gt;
caret 패키지에선 &lt;code&gt;trainControl()&lt;/code&gt; 함수를 통해 일관된 비교방법을 각 후보에게 통일되게 적용하여 평가할 수 있게 도와준다.&lt;/p&gt;
&lt;p&gt;아래 코드는 10-fold cross validation 을 5번 반복하여 가장 좋은 후보의 파라미터 그리드를 찾게 해주는 일종의 장치를 만드는 코드이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;fitControl &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;trainControl&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;method =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;repeatedcv&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;number =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;repeats =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이렇게 만들어진 비교방법에 대한 정보가 담겨있는 &lt;code&gt;fitControl&lt;/code&gt; 객체는 추후에 학습 과정에서 사용하게 될 것이다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;randomforest-로-학습시켜보기&quot;&gt;RandomForest 로 학습시켜보기&lt;/h2&gt;
&lt;p&gt;본격적으로 훈련데이터셋을 이용해 학습을 시켜보겠다.&lt;br /&gt;
학습을 위한 표준화된 인터페이스는 바로 &lt;code&gt;train()&lt;/code&gt; 함수이다.&lt;br /&gt;
이함수에서 &lt;code&gt;method&lt;/code&gt; 인자만 바꿔주면 원하는 학습모델 알고리즘을 구현할 수 있게 된다.&lt;/p&gt;
&lt;p&gt;아래 코드는 랜덤포레스트를 통해 훈련데이터셋을 학습하는 코드다.&lt;br /&gt;
랜덤포레스트 알고리즘을 통해 학습할 것을 &lt;code&gt;method = &amp;quot;rf&amp;quot;&lt;/code&gt; 를 통해 선언한다.&lt;br /&gt;
랜덤포레스트에서 Tuning parameter 에 해당되는 &amp;quot;mtry&amp;quot; 는 10-fold cross validation 을 5번 반복하여 가장 좋게 평가된 것을 선택하는 후보채택방법인 &lt;code&gt;fitControl&lt;/code&gt; 객체를 &lt;code&gt;trControl&lt;/code&gt; 인자에 입력한다.&lt;br /&gt;
&lt;code&gt;verbose&lt;/code&gt; 인자는 기본적으로 &lt;code&gt;TRUE&lt;/code&gt; 로 설정되어 있는데 &amp;quot;mtry&amp;quot; 선정과정이 적나라하게 모두 출력된다.&lt;br /&gt;
이 출력을 막고싶었기 때문에 &lt;code&gt;FALSE&lt;/code&gt; 로 해제하였다.&lt;/p&gt;
&lt;p&gt;더해서 랜덤포레스트를 알고리즘을 이용하기 위한 원 소스인 randomForest 패키지 여부를 먼저 확인하는 과정이 있으므로&lt;br /&gt;
만약 randomForest 패키지가 없다면 설치를 시도할 것인지를 물어볼 것이다. 이럴땐 패키지를 설치하겠다는 의미인 &amp;quot;1&amp;quot;을 입력하면 설치 이후 학습을 연이어 진행한다.&lt;a href=&quot;#fn2&quot; class=&quot;footnoteRef&quot; id=&quot;fnref2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;rf_fit &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;train&lt;/span&gt;(Class ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;., &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; training, &lt;span class=&quot;dt&quot;&gt;method =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;rf&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;trControl =&lt;/span&gt; fitControl, &lt;span class=&quot;dt&quot;&gt;verbose =&lt;/span&gt; F)
rf_fit&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## Random Forest 
## 
## 148 samples
##  60 predictor
##   2 classes: &amp;#39;M&amp;#39;, &amp;#39;R&amp;#39; 
## 
## No pre-processing
## Resampling: Cross-Validated (10 fold, repeated 5 times) 
## Summary of sample sizes: 133, 133, 133, 133, 133, 133, ... 
## Resampling results across tuning parameters:
## 
##   mtry  Accuracy   Kappa    
##    2    0.8401905  0.6762815
##   31    0.7969524  0.5898194
##   60    0.7793333  0.5547874
## 
## Accuracy was used to select the optimal model using  the largest value.
## The final value used for the model was mtry = 2.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;mtry 후보는 2, 31, 60 개로 자동설정된 것을 볼 수 있고, 이 중 Kappa 통계량과 정확도에 의해서 mtry = 2 가 최종적으로 선정된 것을 볼 수 있다.&lt;br /&gt;
선정과정을 자세하게 보고 싶을 경우엔 &lt;code&gt;verbose = F&lt;/code&gt; 를 삭제하고 실행해 보면 좋을 수도 있겠다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;테스트셋에-적용하여-정확도-확인&quot;&gt;테스트셋에 적용하여 정확도 확인&lt;/h2&gt;
&lt;p&gt;보통 훈련데이터셋을 이용해 모델 학습하면&lt;br /&gt;
바로 해보고 싶은 것이 Test dataset 에 적용시켜 영리한 모델인지를 확인해 보는 것이다.&lt;/p&gt;
&lt;p&gt;제너릭 함수인 &lt;code&gt;predict()&lt;/code&gt; 를 이용해 볼 수 도 있겠지만&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;predict&lt;/span&gt;(rf_fit, &lt;span class=&quot;dt&quot;&gt;newdata =&lt;/span&gt; testing)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##  [1] M M R M R R M M R M R R R R M R R R R R R R R M M R R M M R M M M M M
## [36] M M M M M M M M M M M R M M R M M M M M M M M M M
## Levels: M R&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;caret package 의 &lt;code&gt;confusionMatrix()&lt;/code&gt; 를 곁들이면 &lt;a href=&quot;https://en.wikipedia.org/wiki/Confusion_matrix&quot;&gt;혼돈메트릭스(Confusion Matrix)&lt;/a&gt; 및 정확도외 다양한 통계량까지 출력된다.&lt;a href=&quot;#fn3&quot; class=&quot;footnoteRef&quot; id=&quot;fnref3&quot;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;predict&lt;/span&gt;(rf_fit, &lt;span class=&quot;dt&quot;&gt;newdata =&lt;/span&gt; testing) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;confusionMatrix&lt;/span&gt;(testing$Class)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## Confusion Matrix and Statistics
## 
##           Reference
## Prediction  M  R
##          M 30  9
##          R  3 18
##                                           
##                Accuracy : 0.8             
##                  95% CI : (0.6767, 0.8922)
##     No Information Rate : 0.55            
##     P-Value [Acc &amp;gt; NIR] : 4.67e-05        
##                                           
##                   Kappa : 0.5876          
##  Mcnemar&amp;#39;s Test P-Value : 0.1489          
##                                           
##             Sensitivity : 0.9091          
##             Specificity : 0.6667          
##          Pos Pred Value : 0.7692          
##          Neg Pred Value : 0.8571          
##              Prevalence : 0.5500          
##          Detection Rate : 0.5000          
##    Detection Prevalence : 0.6500          
##       Balanced Accuracy : 0.7879          
##                                           
##        &amp;#39;Positive&amp;#39; Class : M               
## &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;60개의 테스트 데이터셋 중 12개가 오분류 되어 약 80% 의 정확도를 가진 것으로 볼 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;tuning-parameters-의-그리드-조정하기&quot;&gt;Tuning parameters 의 그리드 조정하기&lt;/h2&gt;
&lt;h3 id=&quot;사용자-검색-그리드custom-search-grid&quot;&gt;사용자 검색 그리드(custom search grid)&lt;/h3&gt;
&lt;p&gt;최적 파라미터 선정 시 탐색범위와 그리드를 수동으로 조절할 수 있다.&lt;br /&gt;
자동으로 &lt;span class=&quot;math inline&quot;&gt;3&lt;sup&gt;&lt;em&gt;P&lt;/em&gt;&lt;/sup&gt;&lt;/span&gt; 공식에 의해 정해진 mtry 의 후보는 2, 31, 60 로 3개가 되었다.&lt;br /&gt;
만약 더 많은 후보와 상대평가하고 싶을 경우 후보를 사용자가 직접 설정할 수 있다는 것이다.&lt;/p&gt;
&lt;p&gt;아래 코드는 mtry 의 후보를 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 로 바꾸어 설정하고 이 중에서 채택해 보는 코드이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;customGrid &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;expand.grid&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;mtry =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;)
rf_fit2 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;train&lt;/span&gt;(Class ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;., &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; training, &lt;span class=&quot;dt&quot;&gt;method =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;rf&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;trControl =&lt;/span&gt; fitControl, &lt;span class=&quot;dt&quot;&gt;tuneGrid =&lt;/span&gt; customGrid, &lt;span class=&quot;dt&quot;&gt;verbose =&lt;/span&gt; F)

rf_fit2&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## Random Forest 
## 
## 148 samples
##  60 predictor
##   2 classes: &amp;#39;M&amp;#39;, &amp;#39;R&amp;#39; 
## 
## No pre-processing
## Resampling: Cross-Validated (10 fold, repeated 5 times) 
## Summary of sample sizes: 133, 133, 134, 133, 133, 133, ... 
## Resampling results across tuning parameters:
## 
##   mtry  Accuracy   Kappa    
##    1    0.8283810  0.6509334
##    2    0.8449524  0.6849450
##    3    0.8352381  0.6654026
##    4    0.8366667  0.6687853
##    5    0.8390476  0.6740847
##    6    0.8349524  0.6651819
##    7    0.8245714  0.6441155
##    8    0.8406667  0.6766160
##    9    0.8322857  0.6603633
##   10    0.8284762  0.6522812
## 
## Accuracy was used to select the optimal model using  the largest value.
## The final value used for the model was mtry = 2.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;후보를 사용자 검색에 의해 늘려보아도 이전과 같이 mtry = 2 가 최적의 파라미터로 선정되는 것을 볼 수 있다.&lt;/p&gt;
&lt;h3 id=&quot;랜덤-검색-그리드random-selection-of-tuning-parameter-combinations&quot;&gt;랜덤 검색 그리드(&lt;a href=&quot;http://www.jmlr.org/papers/volume13/bergstra12a/bergstra12a.pdf&quot;&gt;random selection of tuning parameter combinations&lt;/a&gt;)&lt;/h3&gt;
&lt;p&gt;튜닝 파라미터의 개수가 많으면 많아질수록 탐색그리드의 개수는 지수적으로 증가하게 되고 동일한 간격의 그리드 구성으로 인해 탐색과정이 비효율적이 될 수 있다.&lt;br /&gt;
지금까지 튜닝 파라미터가 한개인 랜덤포레스트를 예시로 했는데 이번에는 튜닝 파라미터가 2개인 RDA(Regularized Discriminant Analysis) 를 통해 훈련을 해보겠다.&lt;br /&gt;
&lt;code&gt;method = &amp;quot;rda&amp;quot;&lt;/code&gt; 를 통해 알고리즘을 RDA 로 선언할 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;rda_fit &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;train&lt;/span&gt;(Class ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;., &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; training, &lt;span class=&quot;dt&quot;&gt;method =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;rda&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;trControl =&lt;/span&gt; fitControl, &lt;span class=&quot;dt&quot;&gt;verbose =&lt;/span&gt; F)

rda_fit&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## Regularized Discriminant Analysis 
## 
## 148 samples
##  60 predictor
##   2 classes: &amp;#39;M&amp;#39;, &amp;#39;R&amp;#39; 
## 
## No pre-processing
## Resampling: Cross-Validated (10 fold, repeated 5 times) 
## Summary of sample sizes: 133, 133, 133, 133, 134, 133, ... 
## Resampling results across tuning parameters:
## 
##   gamma  lambda  Accuracy   Kappa    
##   0.0    0.0     0.5687619  0.1108443
##   0.0    0.5     0.7151429  0.4264147
##   0.0    1.0     0.7499048  0.4979435
##   0.5    0.0     0.8162857  0.6298722
##   0.5    0.5     0.8340000  0.6646203
##   0.5    1.0     0.7962857  0.5907191
##   1.0    0.0     0.6405714  0.2773524
##   1.0    0.5     0.6392381  0.2748428
##   1.0    1.0     0.6406667  0.2776946
## 
## Accuracy was used to select the optimal model using  the largest value.
## The final values used for the model were gamma = 0.5 and lambda = 0.5.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;총 9개의 파라미터 조합을 비교하는 것을 볼 수 있다.&lt;br /&gt;
바로 위에 소개한 사용자 검색 그리드 역시 &lt;code&gt;expand.grid()&lt;/code&gt; 함수를 이용하여 동일간격 그리드를 검색하게 될 것이다. 이와는 다르게 랜덤 검색 그리드를 이용하면 동일간격 조건을 파괴시켜 파라미터 조합을 구성할 수 도 있다.&lt;br /&gt;
&lt;code&gt;trainControl()&lt;/code&gt; 함수의 &lt;code&gt;search = &amp;quot;random&amp;quot;&lt;/code&gt; 을 통해 검색 타입을 랜덤으로 바꾼다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;fitControl &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;trainControl&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;method =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;repeatedcv&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;number =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;repeats =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;search =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;random&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이후 &lt;code&gt;rda_fit2&lt;/code&gt; 라는 객체이름으로 학습을 다시 시도하고 저장해 본다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;rda_fit2 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;train&lt;/span&gt;(Class ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;., &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; training, &lt;span class=&quot;dt&quot;&gt;method =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;rda&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;trControl =&lt;/span&gt; fitControl, &lt;span class=&quot;dt&quot;&gt;verbose =&lt;/span&gt; F)
rda_fit2&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## Regularized Discriminant Analysis 
## 
## 148 samples
##  60 predictor
##   2 classes: &amp;#39;M&amp;#39;, &amp;#39;R&amp;#39; 
## 
## No pre-processing
## Resampling: Cross-Validated (10 fold, repeated 5 times) 
## Summary of sample sizes: 134, 133, 134, 133, 133, 133, ... 
## Resampling results across tuning parameters:
## 
##   gamma      lambda      Accuracy   Kappa    
##   0.1905631  0.09127881  0.8182857  0.6359082
##   0.4408472  0.90947514  0.8528571  0.7038502
##   0.5510134  0.81992551  0.8500952  0.6971829
## 
## Accuracy was used to select the optimal model using  the largest value.
## The final values used for the model were gamma = 0.4408472 and lambda
##  = 0.9094751.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;튜닝파라미터가 gamma, lambda 2개인데 검색타입을 랜덤으로 바꾸는 순간 &lt;span class=&quot;math inline&quot;&gt;3&lt;sup&gt;&lt;em&gt;P&lt;/em&gt;&lt;/sup&gt;&lt;/span&gt; 공식으로 후보군을 설정하지 않는 것을 확인할 수 있다.&lt;br /&gt;
수동으로 튜닝파라미터 조합개수를 늘려볼 필요가 있다. 이땐 &lt;code&gt;train()&lt;/code&gt; 함수의 &lt;code&gt;tuneLength&lt;/code&gt; 인자를 이용하면 된다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;rda_fit2 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;train&lt;/span&gt;(Class ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;., &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; training, &lt;span class=&quot;dt&quot;&gt;method =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;rda&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;trControl =&lt;/span&gt; fitControl, &lt;span class=&quot;dt&quot;&gt;tuneLength =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;50&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;verbose =&lt;/span&gt; F)
rda_fit2&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## Regularized Discriminant Analysis 
## 
## 148 samples
##  60 predictor
##   2 classes: &amp;#39;M&amp;#39;, &amp;#39;R&amp;#39; 
## 
## No pre-processing
## Resampling: Cross-Validated (10 fold, repeated 5 times) 
## Summary of sample sizes: 133, 133, 133, 133, 134, 133, ... 
## Resampling results across tuning parameters:
## 
##   gamma       lambda       Accuracy   Kappa    
##   0.02467175  0.046240696  0.7835238  0.5655217
##   0.04621138  0.002756874  0.7919048  0.5824003
##   0.07368577  0.095874564  0.8066667  0.6118768
##   0.07701965  0.222859888  0.8202857  0.6398213
##   0.08188038  0.929917497  0.8123810  0.6225995
##   0.08238852  0.477012957  0.8337143  0.6662831
##   0.08304677  0.278592744  0.8242857  0.6477351
##   0.13057207  0.394850662  0.8407619  0.6801815
##   0.16005396  0.740609627  0.8583810  0.7147504
##   0.16216482  0.825921020  0.8475238  0.6931098
##   0.17577373  0.014122051  0.8121905  0.6232475
##   0.18138144  0.343863922  0.8367619  0.6723626
##   0.19299614  0.250964919  0.8272381  0.6530806
##   0.21154934  0.924441815  0.8380952  0.6743253
##   0.29112614  0.062553048  0.8165714  0.6318989
##   0.32592688  0.815187029  0.8491429  0.6957937
##   0.33401985  0.355391729  0.8343810  0.6667045
##   0.33579572  0.585321935  0.8450476  0.6877346
##   0.38974907  0.595071037  0.8462857  0.6901836
##   0.43134665  0.053143749  0.8057143  0.6091455
##   0.46238233  0.225248311  0.8180952  0.6334203
##   0.48010298  0.220008595  0.8167619  0.6308603
##   0.52875129  0.900502936  0.8369524  0.6717790
##   0.59418161  0.835826412  0.8410476  0.6796135
##   0.64002373  0.715450695  0.8450476  0.6871024
##   0.66951286  0.080254850  0.8084762  0.6133645
##   0.66992710  0.557613578  0.8411429  0.6791014
##   0.68394252  0.120018550  0.8085714  0.6136620
##   0.70021389  0.623248231  0.8423810  0.6819366
##   0.70083494  0.075418255  0.8072381  0.6108154
##   0.71019128  0.776717800  0.8287619  0.6548209
##   0.72006479  0.588846389  0.8301905  0.6573055
##   0.73698825  0.234913379  0.8139048  0.6242272
##   0.74356291  0.148414826  0.8139048  0.6242293
##   0.75140091  0.109355597  0.8112381  0.6189670
##   0.75224234  0.263593657  0.8179048  0.6324297
##   0.76679423  0.973216361  0.7871429  0.5722820
##   0.79372463  0.790550417  0.8045714  0.6062931
##   0.82214953  0.130020319  0.8098095  0.6156629
##   0.82467612  0.550611505  0.8059048  0.6081189
##   0.82612455  0.693889297  0.7966667  0.5900626
##   0.84879017  0.495823009  0.7993333  0.5949617
##   0.85219803  0.931135875  0.7571429  0.5118228
##   0.86055616  0.314226715  0.8045714  0.6050836
##   0.86385220  0.089582003  0.7966667  0.5883829
##   0.87890898  0.058559475  0.7939048  0.5827761
##   0.89994468  0.677635454  0.7641905  0.5254671
##   0.93039376  0.101246271  0.7522857  0.5002045
##   0.93660375  0.971543712  0.7182857  0.4340252
##   0.95149425  0.689020876  0.7141905  0.4257570
## 
## Accuracy was used to select the optimal model using  the largest value.
## The final values used for the model were gamma = 0.160054 and lambda
##  = 0.7406096.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;tuneLength = 50&lt;/code&gt; 로 설정해본 결과이다.&lt;br /&gt;
기본 그리드 검색방법에 비교해 보면 채택된 파라미터의 값이 소수점이 더 많아져 자연스럽게 정밀해 진 것을 확인할 수 있다.&lt;br /&gt;
이처럼 튜닝파라미터를 랜덤하게 50개로 설정하여 조금 더 융통성 있는 최적의 파라미터 튜닝 방법을 고려해 볼 수도 있겠다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;병렬처리parallel-processing&quot;&gt;병렬처리(Parallel Processing)&lt;/h2&gt;
&lt;p&gt;병렬처리를 통해 빠른 탐색 전략을 취할 수 있다.&lt;br /&gt;
doMC 패키지와의 연계를 지원하는 caret 패키지는 학습 시 생기는 많은 연산을 병렬처리를 통해 시간 비용을 절감시킬 수 있다. (단 doMC package 는 Unix 계열 머신에서 사용이 가능하다) 특히 튜닝파라미터의 조합 수가 많으면 많을수록 병렬처리는 많은 효용이 있을 것이다.&lt;/p&gt;
&lt;p&gt;필요에 따라 doMC 패키지를 설치하고 로드한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;co&quot;&gt;# install.packages(&amp;quot;doMC&amp;quot;)&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;doMC&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;doMC 패키지를 로드하면 &lt;code&gt;getDoParWorkers()&lt;/code&gt; 를 통해 현재 활성화된 코어수를 확인할 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;getDoParWorkers&lt;/span&gt;() &lt;span class=&quot;co&quot;&gt;# default cores count&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;기본적으론 세팅 이전엔 1코어임을 확인할 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;time &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;system.time&lt;/span&gt;({
  &lt;span class=&quot;kw&quot;&gt;train&lt;/span&gt;(Class ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;., &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; training, &lt;span class=&quot;dt&quot;&gt;method =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;gbm&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;trControl =&lt;/span&gt; fitControl, &lt;span class=&quot;dt&quot;&gt;verbose =&lt;/span&gt; F)
})
time&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##    user  system elapsed 
## 218.508   1.495 221.734&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이때 GBM(Stochastic Gradient Boosting Model)알고리즘으로 학습에 소요되는 시간은 222 초 내외이다.&lt;/p&gt;
&lt;p&gt;이번에는 &lt;code&gt;registerDoMC()&lt;/code&gt; 함수를 이용해 코어수를 2개로 늘린 후 학습에 소요되는 시간을 비교해보자.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;registerDoMC&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;cores =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;getDoParWorkers&lt;/span&gt;()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] 2&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;time &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;system.time&lt;/span&gt;({
  &lt;span class=&quot;kw&quot;&gt;train&lt;/span&gt;(Class ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;., &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; training, &lt;span class=&quot;dt&quot;&gt;method =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;gbm&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;trControl =&lt;/span&gt; fitControl, &lt;span class=&quot;dt&quot;&gt;verbose =&lt;/span&gt; F)
})
time&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##    user  system elapsed 
##   0.595   0.067  44.684&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이때 학습에 소요되는 시간은 45 초 내외이다.&lt;br /&gt;
확실히 소요시간이 줄어든 것을 볼 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://topepo.github.io/caret&quot; class=&quot;uri&quot;&gt;https://topepo.github.io/caret&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;2017-04-23 기준으로 글이 작성 및 수정 되었다&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn2&quot;&gt;&lt;p&gt;1: yes, 2: no&lt;a href=&quot;#fnref2&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn3&quot;&gt;&lt;p&gt;예제가 Classification 일때 이므로 Regression 일때는 논외다&lt;a href=&quot;#fnref3&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Sun, 23 Apr 2017 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2017/04/23/caret_package.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2017/04/23/caret_package.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>R에서 car::vif() 함수를 이용한 분산팽창요인(Variance Inflation Factor) 구하기</title>
        <description>&lt;h2 id=&quot;다중공산성과-분산팽창계수&quot;&gt;다중공산성과 분산팽창계수&lt;/h2&gt;
&lt;p&gt;다중공산성은 주관심대상인 종속변수 Y에 대해 설명하려는 독립변수들 간 강한 상관관계로부터 나온다.&lt;br /&gt;
다중공산성은 회귀분석 모델링을 할 때 다양한 이유로 분석가들을 괴롭히는 문제이다.&lt;br /&gt;
따라서 다중공산성 문제를 사전에 방지하기 위해 다양한 진단법이 존재한다.&lt;br /&gt;
그중 하나가 분산팽창계수를 계산하여 분산팽창요인 여부를 찾는 방법이 있다.&lt;/p&gt;
&lt;p&gt;분산팽창요인(Variance Inflation Factor) 줄여서 VIF는 다음과 같이 찾을 수 있다.&lt;/p&gt;
&lt;p&gt;우선 다중회귀분석 시 종속변수 Y를 제외하고&lt;br /&gt;
나머지 독립변수간의 상관관계만을 고려하여 2개 이상의 독립변수 조합 간 회귀분석을 따로 실시한다.&lt;br /&gt;
실시해본 결과 설명력(결정계수 ; &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;R&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/span&gt;)이 높으면 우리가 우려하는 다중공산성문제가 발생되는 것이며&lt;br /&gt;
만약 독립변수 간 상관관계가 높아 특정조합상(i 번째 독립변수를 종속변수로 두어 회귀분석 실시)에서 회귀선의 설명력이 좋으면 분산팽창계수 값이 커지게 된다.&lt;/p&gt;
&lt;p&gt;분산팽창계수의 정의는 아래와 같다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/vif_1.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;보통 이 분산팽창계수가 10 이상일때 &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;j&lt;/em&gt;&lt;/span&gt;번째 독립변수는 다중공산성이 있는 독립변수라 판단한다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;boston-데이터셋을-이용한-실습예제&quot;&gt;Boston 데이터셋을 이용한 실습예제&lt;/h2&gt;
&lt;p&gt;Boston 데이터셋을 이용하여 다중공산성이 있는 독립변수가 존재하는지 R에서 &lt;code&gt;vif()&lt;/code&gt; 함수를 이용하여 찾아보겠다.&lt;/p&gt;
&lt;p&gt;우선 &lt;code&gt;vif()&lt;/code&gt; 는 car package 안에 내장되어있는 함수이다.&lt;br /&gt;
필요에 따라 패키지를 설치하고 로드한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;install.packages&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;car&amp;quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;car&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;MASS package 에 있는 Boston 데이터셋을 이용할 수 있도록 준비한다.&lt;br /&gt;
참고로 Boston 데이터는 집값에 영향을 주는 것으로 생각되는 요인들을 정하여 Boston 지역 부근의 집들을 전수조사한 데이터라고 한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt;(Boston, &lt;span class=&quot;dt&quot;&gt;package =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;MASS&amp;quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;summary&lt;/span&gt;(Boston)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##       crim                zn             indus            chas        
##  Min.   : 0.00632   Min.   :  0.00   Min.   : 0.46   Min.   :0.00000  
##  1st Qu.: 0.08204   1st Qu.:  0.00   1st Qu.: 5.19   1st Qu.:0.00000  
##  Median : 0.25651   Median :  0.00   Median : 9.69   Median :0.00000  
##  Mean   : 3.61352   Mean   : 11.36   Mean   :11.14   Mean   :0.06917  
##  3rd Qu.: 3.67708   3rd Qu.: 12.50   3rd Qu.:18.10   3rd Qu.:0.00000  
##  Max.   :88.97620   Max.   :100.00   Max.   :27.74   Max.   :1.00000  
##       nox               rm             age              dis        
##  Min.   :0.3850   Min.   :3.561   Min.   :  2.90   Min.   : 1.130  
##  1st Qu.:0.4490   1st Qu.:5.886   1st Qu.: 45.02   1st Qu.: 2.100  
##  Median :0.5380   Median :6.208   Median : 77.50   Median : 3.207  
##  Mean   :0.5547   Mean   :6.285   Mean   : 68.57   Mean   : 3.795  
##  3rd Qu.:0.6240   3rd Qu.:6.623   3rd Qu.: 94.08   3rd Qu.: 5.188  
##  Max.   :0.8710   Max.   :8.780   Max.   :100.00   Max.   :12.127  
##       rad              tax           ptratio          black       
##  Min.   : 1.000   Min.   :187.0   Min.   :12.60   Min.   :  0.32  
##  1st Qu.: 4.000   1st Qu.:279.0   1st Qu.:17.40   1st Qu.:375.38  
##  Median : 5.000   Median :330.0   Median :19.05   Median :391.44  
##  Mean   : 9.549   Mean   :408.2   Mean   :18.46   Mean   :356.67  
##  3rd Qu.:24.000   3rd Qu.:666.0   3rd Qu.:20.20   3rd Qu.:396.23  
##  Max.   :24.000   Max.   :711.0   Max.   :22.00   Max.   :396.90  
##      lstat            medv      
##  Min.   : 1.73   Min.   : 5.00  
##  1st Qu.: 6.95   1st Qu.:17.02  
##  Median :11.36   Median :21.20  
##  Mean   :12.65   Mean   :22.53  
##  3rd Qu.:16.95   3rd Qu.:25.00  
##  Max.   :37.97   Max.   :50.00&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;종속변수는 집값을 의미하는 &lt;code&gt;medv&lt;/code&gt; 변수로 할 것이다.&lt;br /&gt;
나머지 변수 중 이산형 자료로 판단되는 &lt;code&gt;chas&lt;/code&gt;, &lt;code&gt;rad&lt;/code&gt; 변수는 편의상 제외하고 독립변수로 설정해 다중회귀적합을 해본 결과이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;str&lt;/span&gt;(Boston) &lt;span class=&quot;co&quot;&gt;# chas, rad 변수가 integer type 인 것을 확인할 수 있음&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## &amp;#39;data.frame&amp;#39;:    506 obs. of  14 variables:
##  $ crim   : num  0.00632 0.02731 0.02729 0.03237 0.06905 ...
##  $ zn     : num  18 0 0 0 0 0 12.5 12.5 12.5 12.5 ...
##  $ indus  : num  2.31 7.07 7.07 2.18 2.18 2.18 7.87 7.87 7.87 7.87 ...
##  $ chas   : int  0 0 0 0 0 0 0 0 0 0 ...
##  $ nox    : num  0.538 0.469 0.469 0.458 0.458 0.458 0.524 0.524 0.524 0.524 ...
##  $ rm     : num  6.58 6.42 7.18 7 7.15 ...
##  $ age    : num  65.2 78.9 61.1 45.8 54.2 58.7 66.6 96.1 100 85.9 ...
##  $ dis    : num  4.09 4.97 4.97 6.06 6.06 ...
##  $ rad    : int  1 2 2 3 3 3 5 5 5 5 ...
##  $ tax    : num  296 242 242 222 222 222 311 311 311 311 ...
##  $ ptratio: num  15.3 17.8 17.8 18.7 18.7 18.7 15.2 15.2 15.2 15.2 ...
##  $ black  : num  397 397 393 395 397 ...
##  $ lstat  : num  4.98 9.14 4.03 2.94 5.33 ...
##  $ medv   : num  24 21.6 34.7 33.4 36.2 28.7 22.9 27.1 16.5 18.9 ...&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;data &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;subset&lt;/span&gt;(Boston, &lt;span class=&quot;dt&quot;&gt;select =&lt;/span&gt; -&lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(chas, rad)) &lt;span class=&quot;co&quot;&gt;# integer type 인 chas, rad 변수 독립변수에서 제외&lt;/span&gt;
lmfit &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;lm&lt;/span&gt;(medv ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;. , &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; data)
&lt;span class=&quot;kw&quot;&gt;summary&lt;/span&gt;(lmfit)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = medv ~ ., data = data)
## 
## Residuals:
##      Min       1Q   Median       3Q      Max 
## -13.3315  -2.8771  -0.6792   1.6858  27.4744 
## 
## Coefficients:
##               Estimate Std. Error t value Pr(&amp;gt;|t|)    
## (Intercept)  2.970e+01  5.051e+00   5.879 7.59e-09 ***
## crim        -7.010e-02  3.269e-02  -2.144 0.032482 *  
## zn           3.989e-02  1.409e-02   2.831 0.004835 ** 
## indus       -4.198e-02  6.080e-02  -0.691 0.490195    
## nox         -1.458e+01  3.899e+00  -3.740 0.000206 ***
## rm           4.188e+00  4.255e-01   9.843  &amp;lt; 2e-16 ***
## age         -1.868e-03  1.359e-02  -0.137 0.890696    
## dis         -1.503e+00  2.059e-01  -7.301 1.15e-12 ***
## tax          8.334e-04  2.386e-03   0.349 0.727038    
## ptratio     -8.738e-01  1.323e-01  -6.607 1.02e-10 ***
## black        8.843e-03  2.763e-03   3.200 0.001461 ** 
## lstat       -5.267e-01  5.224e-02 -10.083  &amp;lt; 2e-16 ***
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1
## 
## Residual standard error: 4.899 on 494 degrees of freedom
## Multiple R-squared:  0.7225, Adjusted R-squared:  0.7163 
## F-statistic: 116.9 on 11 and 494 DF,  p-value: &amp;lt; 2.2e-16&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;다중회귀분석 결과를 &lt;code&gt;summary()&lt;/code&gt; 함수로 간단히 살펴보면&lt;br /&gt;
독립변수 각각에 대한 회귀계수들과 유의성을 판단할 수 있는 output 들이 출력 된다.&lt;br /&gt;
하지만 지금까지 나와 있는 output 만을 보고 다중공산성이 있는지 없는지 판단하기는 쉽지 않다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vif()&lt;/code&gt; 함수를 꺼내 들어보겠다.&lt;br /&gt;
&lt;code&gt;vif()&lt;/code&gt; 함수 사용방법은 아주아주 간단한 편이다. 아래코드처럼 &lt;code&gt;lm()&lt;/code&gt; 함수로 반환된 객체를 넣어주기만 하면 된다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;vif&lt;/span&gt;(lmfit)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##     crim       zn    indus      nox       rm      age      dis      tax 
## 1.663648 2.272992 3.660714 4.294324 1.880883 3.077311 3.953729 3.403205 
##  ptratio    black    lstat 
## 1.725085 1.338875 2.928554&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;vif&lt;/span&gt;(lmfit) &amp;gt;&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##    crim      zn   indus     nox      rm     age     dis     tax ptratio 
##   FALSE   FALSE   FALSE   FALSE   FALSE   FALSE   FALSE   FALSE   FALSE 
##   black   lstat 
##   FALSE   FALSE&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;vif()&lt;/code&gt; 함수를 실행해 본 결과 종속변수를 제외한 독립변수가 나열되고, 그 밑에 각 독립변수의 분산팽창계수값이 출력된다.&lt;br /&gt;
값을 보니 10을 넘는 변수가 존재하지 않다.&lt;br /&gt;
따라서 현 분석에서 다중공산성이 존재하는 독립변수는 없다고 결론을 낼 수 있겠다.&lt;/p&gt;
</description>
        <pubDate>Sun, 16 Apr 2017 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2017/04/16/vif.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2017/04/16/vif.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>R에서 RImpala 패키지를 이용해 Impala 커넥션 맺기 (with Docker)</title>
        <description>&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/Rimpala.jpg&quot; width=&quot;80%&quot;&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cloudera.com/documentation/enterprise/5-8-x/topics/impala.html&quot;&gt;Impala&lt;/a&gt; 라는걸 사용해 봐야 할 일이 생겼다.&lt;br /&gt;
필자는 Hadoop, SQL 과 같은 기술이 상당히 낯설고 두려움이 있었는데 Impala 를 통해 조금씩 알게 되는 계기가 되었으면 좋겠다.&lt;/p&gt;
&lt;p&gt;Impala 는 아파치 프로젝트에 incubating 단계로 관리되고 있는 프로젝트로써&lt;br /&gt;
HDFS(Hadoop Distributed File System) 안에 있는 데이터를 SQL 을 통해 실시간으로(대화형으로) 분석할 수 있게 도와주는 시스템이라고 한다.&lt;br /&gt;
HDFS 를 이용하기 위해선 MapReduce 프레임워크를 알고 이용했어야 한다는 불편한 제약을 Impala 를 통해 벗어날 수 있다 이해할 수 있겠다.&lt;/p&gt;
&lt;p&gt;Impala 소개는 이쯤 하고 (&lt;del&gt;읔.. 알고있는게 이정도 뿐이다 😅&lt;/del&gt;) 여하튼 지금은 &lt;a href=&quot;https://www.docker.com/&quot;&gt;Docker&lt;/a&gt; 을 통해 Impala 를 간단히 구동시켜보고,&lt;br /&gt;
RImpala package 를 이용해 R 상에서 Impala 와 커넥션을 맺는데 성공했던 과정을 짤막하게 정리하고 적어보고자 한다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;ready-impala&quot;&gt;Ready impala&lt;/h2&gt;
&lt;p&gt;Impala 이용 전 &lt;code&gt;.jar&lt;/code&gt; 리소스들을 준비해야 한다고 한다.&lt;br /&gt;
아래 R 코드를 통해 다운로드 및 워킹디렉토리에 압축해제가 가능하다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;download.file&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;https://github.com/Mu-Sigma/RImpala/blob/master/impala-jdbc-cdh5.zip?raw=true&amp;quot;&lt;/span&gt;, 
              &lt;span class=&quot;st&quot;&gt;&amp;quot;jdbc.zip&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;method =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;curl&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;extra =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;-L&amp;quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;unzip&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;jdbc.zip&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;docker-images-ready&quot;&gt;Docker images ready&lt;/h2&gt;
&lt;p&gt;그다음 터미널을 들어가 Docker 를 구동할 준비를 한다.&lt;br /&gt;
여기서 Docker 를 이용하려는 이유를 언급해야 할 것 같은데&lt;br /&gt;
Impala 를 이용하기 위해선 Hadoop 시스템이 사전에 준비되어야 하고, JDBC 를 위한 Java 설정등 다양한 준비(Requirements)가 매우 부담되기 때문이다.&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;br /&gt;
이러한 이유로 나는 Docker 를 이용해 누군가 개발해 놓은, 사전에 잘 구축한 환경을 사용하고자 하기 때문에&lt;br /&gt;
Docker 구동을 위해 boot2docker 를 시작했다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;boot2docker&lt;/span&gt; init
$ &lt;span class=&quot;kw&quot;&gt;boot2docker&lt;/span&gt; up
$ &lt;span class=&quot;kw&quot;&gt;boot2docker&lt;/span&gt; ssh&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;boot2docker ssh&lt;/code&gt; 를 통해 docker 가상머신에 접속 후 &amp;quot;Impala&amp;quot; 를 검색어로 적당한 이미지를 찾아본다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;docker@boot2docker&lt;/span&gt;:~$ docker search impala&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;NAME                                DESCRIPTION                                     STARS
cloudera/impala-dev                 Impala development environment                  10
codingtony/impala                                                                   5
rooneyp1976/impala                  Impala 2.0.1 on Ubuntu 14.04 Image (fork o...   4
lancope/impala-shell                                                                1
yanlinw/docker-impala               impala 2.0.1 + sqoop + sql server driver        0
mikefaille/ubuntu-impala            Description                                     0
galloplabs/hadoop-cdh-impala                                                        0
yanlinw/docker-impala-sqoop         impala sqoop2                                   0
cpcloud86/impala                                                                    0
damsl/impala                                                                        0
joshdub223/impala                                                                   0
aurele/shiny4saagie-impala          Form that reads/writes from Impala on Saagie    0
sebastianmontero/impala                                                             0
datadudes/impala-rest-api           Simple rest API for Impala                      0
andreysabitov/impala-kudu                                                           0
... [이하 생략]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;여러 가지가 이미지가 준비되어 있는데 그중 개인적으론 &amp;quot;cloudera/impala-dev&amp;quot; 보단 &amp;quot;codingtony/impala&amp;quot; 가 바로 사용하기 좋았다.&lt;br /&gt;
&amp;quot;codingtony/impala&amp;quot; 이미지를 준비 내려받았다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;docker@boot2docker&lt;/span&gt;:~$ docker pull codingtony/impala&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1.4GB 정도가 다운로드 되는데 시간이 조금 소요된다.&lt;br /&gt;
다운로드 이후 image 가 잘 준비되어 있는지 &lt;code&gt;docker images&lt;/code&gt; 를 통해 확인할 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;docker@boot2docker&lt;/span&gt;:~$ docker images&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
codingtony/impala   latest              24f0d50712cf        2 years ago         1.452 GB&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;다음을 통해 준비한 Impala 이미지를 컨테이너로 실행시킨다.&lt;a href=&quot;#fn2&quot; class=&quot;footnoteRef&quot; id=&quot;fnref2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;docker@boot2docker&lt;/span&gt;:~$ docker run -d --name &lt;span class=&quot;st&quot;&gt;&amp;quot;impala&amp;quot;&lt;/span&gt; -p 9000:9000 -p 50010:50010 -p 50020:50020 -p 50070:50070 -p 50075:50075 -p 21000:21000 -p 21050:21050 -p 25000:25000 -p 25010:25010 -p 25020:25020 codingtony/impala&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;참고로 &lt;code&gt;docker run&lt;/code&gt; 의 다양한 옵션들 중 &lt;code&gt;-d,&lt;/code&gt; &lt;code&gt;--name&lt;/code&gt; 은 각각&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-d&lt;/code&gt; : background 프로세스로 실행해 놓겠다는 의미&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--name &amp;quot;impala&amp;quot;&lt;/code&gt; : image 이름의 alias 를 부여, 예를 들어 본 컨테이너에 접근하기 위해선 &amp;quot;codingtony/impala&amp;quot; 의 이름을 다 입력해야 하는데 앞으론 &amp;quot;impala&amp;quot; 라는 이름으로 접근 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;의 의미를 가지고 있다.&lt;br /&gt;
참고로 Impala 컨테이너가 백그라운드로 잘 실행되는 상태인지 확인을 위해선 &lt;code&gt;docker ps&lt;/code&gt; 명령어로 프로세스 확인할 수 있다.&lt;br /&gt;
프로세스가 잘 돌고 있는 것을 확인했다면&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;docker@boot2docker&lt;/span&gt;:~$ docker exec -it impala /bin/bash&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;를 통해 Impala 컨테이너의 bash 셸을 열어 입력/출력이 가능하도록 사용할 수 있고&lt;br /&gt;
&lt;code&gt;impala-shell&lt;/code&gt; 를 실행해 대화형 쿼리를 주고받을 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@cb4ba4d0f902:/# impala-shell

Starting Impala Shell without Kerberos authentication
Connected to cb4ba4d0f902:21000
Server version: impalad version 1.4.2-cdh5 RELEASE (build eac952d4ff674663ec3834778c2b981b252aec78)
Welcome to the Impala shell. Press TAB twice to see a list of available commands.

Copyright (c) 2012 Cloudera, Inc. All rights reserved.

(Shell build version: Impala Shell v1.4.2-cdh5 (eac952d) built on Tue Sep 16 19:15:40 PDT 2014)
[cb4ba4d0f902:21000] &amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;rimpala-package-이용한-로컬에서의-impala-제어&quot;&gt;RImpala package 이용한 로컬에서의 impala 제어&lt;/h2&gt;
&lt;h3 id=&quot;docker-vm-ip-확인&quot;&gt;Docker VM IP 확인&lt;/h3&gt;
&lt;p&gt;로컬 상에서 RImpala package 이용한 로컬 상의 제어를 위해 docker ip 를 확인할 필요가 있다.&lt;br /&gt;
이는 &lt;code&gt;boot2docker ip&lt;/code&gt; 를 통해 쉽게 확인 가능하다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;boot2docker&lt;/span&gt; ip&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;예를 들어 &amp;quot;192.168.59.103&amp;quot; 임을 위의 커멘드를 통해 확인했다고 가정하겠다.&lt;/p&gt;
&lt;h3 id=&quot;r상에-rimpala-패키지를-이용한-커넥션&quot;&gt;R상에 RImpala 패키지를 이용한 커넥션&lt;/h3&gt;
&lt;p&gt;R로 되돌아오자.&lt;br /&gt;
먼저 &lt;code&gt;.jar&lt;/code&gt; 들을 다운받은 디렉토리 path를 &lt;code&gt;rimpala.init()&lt;/code&gt; 함수에 입력한 코드를 먼저 실행하고,&lt;br /&gt;
docker 가상환경의 ip, 그리고 Impala JDBC/ODBC 기본값 포트번호 (21050) 를 &lt;code&gt;rimpala.connect()&lt;/code&gt; 에 입력한 코드를 그다음으로 실행하면 &lt;code&gt;TRUE&lt;/code&gt; 가 반기면 커넥션이 성공한 것이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(RImpala)

&lt;span class=&quot;kw&quot;&gt;rimpala.init&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;libs =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;impala-jdbc-cdh5&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;Classpath added successfully&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;rimpala.connect&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;IP =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;192.168.59.103&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;port =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;21050&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;use-databases&quot;&gt;Use databases&lt;/h3&gt;
&lt;p&gt;자 이제 즐기면(?) 되겠다. database 가 무엇이 있는지 확인부터 해보자.&lt;br /&gt;
&lt;code&gt;show databases;&lt;/code&gt; 쿼리를 날려보는 건 &lt;code&gt;rimpala.showdatabases()&lt;/code&gt; 을 실행하는 것과 같다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;rimpala.showdatabases&lt;/span&gt;()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##               name
## 1 _impala_builtins
## 2          default&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;쿼리문 자체를 이용하고자 한다면 &lt;code&gt;rimpala.query()&lt;/code&gt; 함수를 이용하면 된다.&lt;br /&gt;
단 쿼리문 마지막에 세미콜론(;)은 넣지 않아야 에러가 나지 않았다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;rimpala.query&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;show databases&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##               name
## 1 _impala_builtins
## 2          default&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;사용할 데이터베이스 선택을 해보자.&lt;br /&gt;
&amp;quot;default&amp;quot; database 를 사용하려한다면&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;rimpala.usedatabase&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;default&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;를 하면된다. &lt;code&gt;use default;&lt;/code&gt; 쿼리와 같다.&lt;/p&gt;
&lt;h3 id=&quot;send-query-test&quot;&gt;Send query test&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;tryCatch&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;rimpala.query&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;drop table sample&amp;quot;&lt;/span&gt;), &lt;span class=&quot;dt&quot;&gt;error =&lt;/span&gt; function(e){})&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## NULL&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;tryCatch&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;rimpala.query&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;create table sample(no integer)&amp;quot;&lt;/span&gt;), &lt;span class=&quot;dt&quot;&gt;error =&lt;/span&gt; function(e){})&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## NULL&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;tryCatch&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;rimpala.query&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;insert into sample (no) values (1)&amp;quot;&lt;/span&gt;), &lt;span class=&quot;dt&quot;&gt;error =&lt;/span&gt; function(e){})&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## NULL&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;data &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;rimpala.query&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;select * from sample&amp;quot;&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# output value is data.frame class&lt;/span&gt;
data&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##   no
## 1  1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;rimpala.query()&lt;/code&gt; 함수로 쿼리를 보낼 때 에러를 많이 반환했다.&lt;br /&gt;
하지만 이상하게도 R상에선 에러를 뿜었으나 쿼리가 Impala 에 잘 먹혔다.&lt;br /&gt;
이 때문에 임시방편으로 &lt;code&gt;tryCatch()&lt;/code&gt; 를 통해 예외처리를 했다.&lt;br /&gt;
다만 데이터를 끌어오는데는 쿼리는 문제없이 잘 실행됬다.&lt;/p&gt;
&lt;h3 id=&quot;close-connect-impala&quot;&gt;close connect impala&lt;/h3&gt;
&lt;p&gt;커넥션은 &lt;code&gt;rimpala.close()&lt;/code&gt; 로 끊을 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;rimpala.close&lt;/span&gt;()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.cloudera.com/blog/2013/12/how-to-do-statistical-analysis-with-impala-and-r/&quot;&gt;How-to: Do Statistical Analysis with Impala and R&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://d2.naver.com/helloworld/246342&quot;&gt;Naver D2 - Hadoop에서의 실시간 SQL 질의: Impala&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/codingtony/docker-impala&quot;&gt;Github Readme (codingtony/docker-impala)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;Cloudera 에서 &lt;a href=&quot;https://www.cloudera.com/documentation/enterprise/5-9-x/topics/impala_prereqs.html&quot;&gt;Impala install 페이지&lt;/a&gt;를 보고 지레 겁먹어서 그렇기도 하다&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn2&quot;&gt;&lt;p&gt;&lt;code&gt;docker pull&lt;/code&gt; 과정 없이 바로 &lt;code&gt;docker run&lt;/code&gt; 을 해도 된다. 무슨말이냐면 사실 &lt;code&gt;docker run&lt;/code&gt; 은 이미지가 없을 경우 자동으로 이미지를 다운로드 하기 때문이다&lt;a href=&quot;#fnref2&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Tue, 21 Mar 2017 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2017/03/21/RImpala_package.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2017/03/21/RImpala_package.html</guid>
        
        
        <category>R</category>
        
      </item>
    
  </channel>
</rss>
