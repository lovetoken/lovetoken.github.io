<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description></description>
    <link>https://lovetoken.github.io/</link>
    <atom:link href="https://lovetoken.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 14 Jan 2017 21:05:16 +0900</pubDate>
    <lastBuildDate>Sat, 14 Jan 2017 21:05:16 +0900</lastBuildDate>
    <generator>Jekyll v3.1.6</generator>
    
      <item>
        <title>R에서 다수의 패키지 편하게 불러오기</title>
        <description>&lt;h2 id=&quot;a-상황&quot;&gt;A) 상황&lt;/h2&gt;
&lt;p&gt;R 에서 여러 개의 패키지를 사용해야 하는 프로그램을 작성해야 한다면 &lt;code&gt;library()&lt;/code&gt; 함수로 사용하는 패키지를 불러오는 코드를 서두에 작성하는 전략을 사용할 것이다. &lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;package1&amp;quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;package2&amp;quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;package3&amp;quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;package4&amp;quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;package5&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이처 5개의 패키지를 로드하는 코드로 볼 수 있는데, 만약 필요로 하는 패키지의 수가 5개가 아닌 수십 개가 된다면 수십개의 &lt;code&gt;library()&lt;/code&gt; 함수를 작성하게 될 것이다.&lt;br /&gt;
아쉽게도 &lt;code&gt;library()&lt;/code&gt; 함수는 불러올 대상이 되는 패키지를 복수개로 입력할 수 없어&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;package1&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;package2&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;package3&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;package4&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;package5&amp;quot;&lt;/span&gt;))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Error : 
  &amp;#39;package&amp;#39;는 반드시 길이가 1이어야 합니다&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;와 같은 꼴로는 사용할 수 없기 때문에 코드가 불필요하게 길어진다.&lt;br /&gt;
반복문을 이용해 굳이 해결책을 찾자면 벡터형 문자열을 이용할 수 있을 것인데&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;for(i in &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;package1&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;package2&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;package3&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;package4&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;package5&amp;quot;&lt;/span&gt;)){
  &lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(i, &lt;span class=&quot;dt&quot;&gt;character.only =&lt;/span&gt; T)
} &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;중간에 패키지 로드가 실패했을 경우 (예를 들어 &amp;quot;package3&amp;quot; 호출이 실패)&lt;br /&gt;
이후의 패키지들 (&amp;quot;package4&amp;quot;, &amp;quot;package5&amp;quot;) 이 로드되지 않는 등 실제로 사용하기엔 불편한 점들이 있을 것이다.&lt;/p&gt;
&lt;p&gt;또한, 위에 제시한 어떠한 방법이든&lt;br /&gt;
자신이 만든 프로그램이 다수의 패키지에 의존되면 의존될수록 타인이 자신의 프로그램을 이용할 때 오류가 일어날 가능성도 커진다.&lt;br /&gt;
타인은 프로그램에 의존된 패키지가 모두 설치되어 있을 리 없다.&lt;/p&gt;
&lt;h2 id=&quot;b-pacman-패키지의-p_load-함수&quot;&gt;B) pacman 패키지의 &lt;code&gt;p_load()&lt;/code&gt; 함수&lt;/h2&gt;
&lt;p&gt;이처럼 재현 가능한 연구를 방해하는 요소들을 없애기 위해 고민하다가 pacman package 를 알게 되었고&lt;br /&gt;
pacman 패키지에서 제공되는 여러 함수 중 &lt;code&gt;p_load()&lt;/code&gt; 함수의 도움을 가장 많이 받고 있다.&lt;br /&gt;
일반적인 상황에서 &lt;code&gt;p_load()&lt;/code&gt; 함수는 위에 제시한 불편한 문제들을 잘 해결해 준다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;pacman::&lt;span class=&quot;kw&quot;&gt;p_load&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;package1&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;package2&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;package3&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;package4&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;package5&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;다수의 패키지를 불러올 때 복수의 문자열 벡터를 입력받을 수 있어 코드 길이를 줄일 수 있다.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;불러오길 희망하는 다수의 패키지 중에&lt;br /&gt;
설치가 되지 않은 패키지가 있어도 알아서 설치를 진행한 후 설치가 잘 완료되면 불러오는 기능이 한 번에 수행된다.&lt;br /&gt;
예를 들어 &amp;quot;package3&amp;quot; 이란 패키지가 설치되어있지 않은 상황이라 하더라도&lt;br /&gt;
오류와 함께 코드실행이 멈추는 것이 아니라 CRAN 에 &amp;quot;package3&amp;quot; 을 찾은 후 패키지 설치완료 후 불러온다.&lt;br /&gt;
CRAN 에 존재하지 않는 패키지명칭을 적지 않는 한 &lt;code&gt;p_load()&lt;/code&gt; 함수로 패키지를 로드할 때 오류가 날 일은 거의 없을 것이다.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;코드 중간중간 필요한 시점에서 &lt;code&gt;library()&lt;/code&gt; 호출을 할 수 도 있겠으나, 프로젝트를 시작하기 앞서 필요한 모든 패키지를 보여주기 위해 보통 서두에 몰아 패키지를 호출하는 경우가 많은것 같다&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Thu, 12 Jan 2017 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2017/01/12/multiple_load_packages.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2017/01/12/multiple_load_packages.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>R에서 Startup option 설정하기 (on Mac)</title>
        <description>&lt;p&gt;만약 R에서 꾸준히 + 자주자주 + 빈번하게 활용하는 패키지가 있다면 매번 &lt;code&gt;library()&lt;/code&gt; 로 호출하는 것이 귀찮을 수 있다.&lt;br /&gt;
나의 경우 dplyr package 를 항시 사용하는 편이어서 R이 켜질 때 자동으로 &lt;code&gt;library(dplyr)&lt;/code&gt; 이 실행됐으면 했는데 찾아보니 R은 이런 경우를 생각해 Startup option 들을 제공하고 있다는 것을 알았다.&lt;/p&gt;
&lt;p&gt;여러 방법이 있지만 내가 볼 때 가장 간편한 방법은&lt;br /&gt;
자신의 홈 디렉토리에 &amp;quot;.Rprofile&amp;quot; 이란 숨김파일을 만든 후&lt;br /&gt;
이안에 자주 활용하는 패키지를 호출하는 명령어를 미리 적어 놓는 것이다.&lt;/p&gt;
&lt;p&gt;자세히 정리하면 아래와 같다.&lt;/p&gt;
&lt;h2 id=&quot;a-홈-디렉토리로-들어가-.rprofile-숨김파일-만들기&quot;&gt;A) 홈 디렉토리로 들어가 &amp;quot;.Rprofile&amp;quot; 숨김파일 만들기&lt;/h2&gt;
&lt;p&gt;쉘에서 틸드(~)문자는 사용자의 홈 디렉토리를 의미하는 특별한 기호이다.&lt;br /&gt;
터미널을 실행한 후 틸드문자를 이용해 사용자 홈디렉토리로 이동한다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd ~&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;아마도 &amp;quot;.Rprofile&amp;quot; 파일이 존재할 수도 있다. 물론 없을 수도 있고 상황에 따라 다르다.&lt;br /&gt;
상관없이 텍스트에디터를 이용해 &amp;quot;.Rprofile&amp;quot; 를 수정하거나 새로 만들면 되겠다.&lt;br /&gt;
간편히 nano 를 이용한다고 치면&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nano .Rprofile&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;를 통해 &amp;quot;.Rprofile&amp;quot; 를 열거나 새로 만들게 된다.&lt;/p&gt;
&lt;h2 id=&quot;b-startup-커멘드-및-옵션들-작성하기&quot;&gt;B) Startup 커멘드 및 옵션들 작성하기&lt;/h2&gt;
&lt;p&gt;&amp;quot;.Rprofile&amp;quot; 에 무언가를 작성할 것인데&lt;br /&gt;
바로 이곳에 &lt;code&gt;library(dplyr)&lt;/code&gt; 과 같은 것을 적고 저장시키면&lt;br /&gt;
앞으로 R을 실행하자마자 &lt;code&gt;library(dplyr)&lt;/code&gt; 명령어가 자동으로 실행된다.&lt;br /&gt;
이러한 간단한 원리를 이용해 패키지 자동호출 외에도 &lt;code&gt;options()&lt;/code&gt; set 을 미리 지정하는 것도 매우 좋은 Tip이 될 수 있겠다.&lt;/p&gt;
&lt;p&gt;나의 &amp;quot;.Rprofile&amp;quot; 을 소개하자면 이렇다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;options&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;help_type =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;html&amp;quot;&lt;/span&gt;) ## 1
&lt;span class=&quot;kw&quot;&gt;options&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;stringsAsFactors =&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;FALSE&lt;/span&gt;) ## 2

pacman::&lt;span class=&quot;kw&quot;&gt;p_load&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;useful.lovetoken&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;knitr&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;dplyr&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;ggplot2&amp;quot;&lt;/span&gt;) ## 3

opts_chunk$&lt;span class=&quot;kw&quot;&gt;set&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;fig.path =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;output/figure/&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;fig.align =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;center&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;out.width =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;80%&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;warning =&lt;/span&gt; F, &lt;span class=&quot;dt&quot;&gt;message =&lt;/span&gt; F) ## 4

&lt;span class=&quot;kw&quot;&gt;theme_set&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;theme_bw&lt;/span&gt;()) ## 5&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;함수 도움말을 볼 때 기본적으로 html 포맷의 형태에 문서가 열리는걸로 고정시켰다&lt;a href=&quot;#fn2&quot; class=&quot;footnoteRef&quot; id=&quot;fnref2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;read.csv()&lt;/code&gt; 와 같은 함수에서 &lt;code&gt;stringsAsFactors&lt;/code&gt; 인자값이 &lt;code&gt;getOption(&amp;quot;stringsAsFactors&amp;quot;)&lt;/code&gt; 에 의존되는데 이를 &lt;code&gt;FALSE&lt;/code&gt; 로 고정시켰다&lt;/li&gt;
&lt;li&gt;필자가 자주쓰는 패키지로 R을 실행할 때 무조건 호출될 패키지 4개를 pacman 을 통해 호출했다&lt;/li&gt;
&lt;li&gt;Rmarkdown 을 쓰는 경우 knitr 패키지를 통해 코드청크 글로벌 옵션들을 지정시켰다&lt;/li&gt;
&lt;li&gt;ggplot2 의 메인테마에 대한 설정이다&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;여러분도 여러분 나름의 &amp;quot;.Rprofile&amp;quot; 를 작성해 보시길 🙃&lt;br /&gt;
그리고 본 글은 Mac OS X 를 기준으로 작성한 경우이지만, 리눅스이어도 홈 디렉토리의 경로만 약간 다를 뿐 틸드문자를 이용한 방법은 똑같다고 보면 되겠다.&lt;br /&gt;
윈도우의 경우는 R이 설치된 &amp;quot;C:\Program Files\R\R-***\etc\&amp;quot; 이곳에 &amp;quot;.Rprofile&amp;quot; 를 작성하면 되겠다.&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.onthelambda.com/2014/09/17/fun-with-rprofile-and-customizing-r-startup/&quot;&gt;Fun with .Rprofile and customizing R startup&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://stat.ethz.ch/R-manual/R-devel/library/base/html/Startup.html&quot;&gt;&lt;code&gt;?Startup&lt;/code&gt; in R&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;vi, vim 들도 있지만 이걸 아시는분들을 위한 글은 아닐수도... 있을것 같다&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn2&quot;&gt;&lt;p&gt;IDE 에 따라 도움말 포맷이 유동적으로 설정된다. 이걸 무조건 html type 으로만 열리게 고정시킨 경우이다&lt;a href=&quot;#fnref2&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Tue, 20 Dec 2016 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2016/12/20/RStartup_Option.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2016/12/20/RStartup_Option.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>Google 에서 사용하는 R Code conventions (코딩 스타일 규약)</title>
        <description>&lt;p&gt;구글에서는 코드를 작성할 때 아래 링크로 정리된 규약을 따라 프로그램을 작성한다고 한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://google.github.io/styleguide/Rguide.xml&quot;&gt;Google&#39;s R Style Guide&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;여러가지 규칙이 있고 이에 대한 예제가 상세히 제시되어 있다.&lt;br /&gt;
간단하게 주요 10가지 사항만 정리해 보면&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;한 줄에 80자 이상을 작성하지 않는다.&lt;/li&gt;
&lt;li&gt;단일명령문에는 중괄호 &lt;code&gt;{}&lt;/code&gt; 를 사용하지 않는다.&lt;/li&gt;
&lt;li&gt;모든 연산자에는 양 좌, 우에 띄어쓰기를 하여 자간을 맞춘다.&lt;/li&gt;
&lt;li&gt;쉼표 &lt;code&gt;,&lt;/code&gt; 는 앞에 공백을 두지 않고 뒤에만 넣는다.&lt;/li&gt;
&lt;li&gt;들여쓰기는 Space를 이용해 2칸으로 정한다. Tab 을 사용하지 않는다.&lt;/li&gt;
&lt;li&gt;괄호와 대괄호에서 여는곳과 닫는곳에 공백을 넣지 않는다.&lt;/li&gt;
&lt;li&gt;할당연산자는 &lt;code&gt;&amp;lt;-&lt;/code&gt; 를 사용한다. &lt;code&gt;=&lt;/code&gt; 를 사용하지 않는다.&lt;/li&gt;
&lt;li&gt;함수의 정의에서 인수를 설정할 땐 기본값이 없는 인수를 먼저 나열하고, 그 뒤에 기본값을 갖는 인수를 나열한다.&lt;/li&gt;
&lt;li&gt;프로그램에선 오류를 만들 가능성이 있는 &lt;code&gt;attach()&lt;/code&gt; 를 사용하지 않는다.&lt;/li&gt;
&lt;li&gt;(구글은 일관성을 위하여 세미콜론을 불필요하다고 판단했다) 세미콜론 &lt;code&gt;;&lt;/code&gt; 으로 줄을 끝내거나 같은 줄에 둘 이상의 명령을 넣지 않는다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;정도가 된다.&lt;/p&gt;
&lt;p&gt;나름대로 정리된 코드컨벤션을 읽지 않았을 이전에는 항상 R 스크립트가 뒤죽박죽인 면이 있었는데 앞으론 통일시킬 수 있을 것 같다.&lt;br /&gt;
무엇보다 중요한 건 코딩시 생기는 불필요한 코딩 스타일의 선택에 대한 고민을 줄여 줄 수 있을 거라 생각된다.&lt;/p&gt;
</description>
        <pubDate>Sun, 18 Dec 2016 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2016/12/18/RCodeConventions.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2016/12/18/RCodeConventions.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>Getting Started StackOverflow</title>
        <description>&lt;a href=&quot;http://stackoverflow.com/&quot;&gt;&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/SO_logo.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이 글을 쓰는 시점 스택오버플로우&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;를 눈팅만 한지 2년 가까이 되었다.&lt;br /&gt;
나는 굳이 분류하자면 개발군과 비개발군 중 비개발군에 속하는 사람이다.&lt;br /&gt;
따라서 스택오버플로우에 있는 글들을 눈팅만 해도 충분하게 넘칠 정도로 얻어갔다.&lt;/p&gt;
&lt;p&gt;그런데 요즘시대 개발, 비개발 분류하는것이 의미가 없어질 정도로 다양하게 섭렵해야 하는 시대가 아닌가?&lt;br /&gt;
다양한 컴퓨터언어와 오픈소스도구들을 이것저것 만지작하면서 최소한 개발자들과의 협업이 가능한 수준의 배경지식과 개발능력을 함양할 필요가 있다고 생각이 바뀌기 시작했다.&lt;br /&gt;
그리고 눈팅만 2년째 하다 보니 입문자 입장에서의(나를 위한) 얼토당토않은 낮은 수준의 질문글이 보이지 않는다는 것을 느끼게 되었다.&lt;a href=&quot;#fn2&quot; class=&quot;footnoteRef&quot; id=&quot;fnref2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;br /&gt;
그래서 내가 생각하는 낮은 수준의 질문을 발번역해 영어로 작문하고, 작성된 글을 올리기 위하여 스택오버플로우에 로그인하였다.&lt;a href=&quot;#fn3&quot; class=&quot;footnoteRef&quot; id=&quot;fnref3&quot;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이때부터 스택오버플로우의 사용방법과, 생태계의 메커니즘을 좀 정확히 알고 싶은 마음이 생겼는데&lt;br /&gt;
이를 계기로 이글을 작성한 다음 적극적으로 애용해보려 한다.&lt;/p&gt;
&lt;h2 id=&quot;a-스택오버플로우-간단-소개&quot;&gt;A) 스택오버플로우 간단 소개&lt;/h2&gt;
&lt;p&gt;스택오버플로우는 2008년경에 만들어진 프로그래머들 사이의 질문/답변 커뮤니케이션 사이트이다.&lt;br /&gt;
조엘 스폴스키 등 2명이 기존의 있던 Q&amp;amp;A 사이트인 Experts_Exchange를 더 개방시킨 웹사이트로서 만들어진 사이트라고 한다.&lt;br /&gt;
만들어진지 8년만에 개발관련된 구글링을 하면 절반이 넘는 게시글이 스택오버플로우로 연결되어 있을 정도로 아주 중요한 웹사이트가 되었다.(&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_Overflow&quot;&gt;wiki 참고&lt;/a&gt;)&lt;/p&gt;
&lt;h2 id=&quot;b-스택오버플로우의-운영-원리&quot;&gt;B) 스택오버플로우의 운영 원리&lt;/h2&gt;
&lt;p&gt;스택오버플로우는 reputation 즉 명성도라는 것을 이용한다. (평판이라고도 한다)&lt;br /&gt;
평판제도는 스택오버플로우를 사용할 때 특정 자격을 부여하는 등 사용 동기부여를 주기도 한다.&lt;br /&gt;
이 제도 때문에 사용자들이 좀 더 정확한 질문, 그에 대한 알찬 답변을 상호적으로 주고 받을 수 있는 좋은 메커니즘으로 작용하고 있고, 자연스럽게 주제와 벗어난 질문과 글들이 필터링 되는 좋은 인프라가 뿌리잡았다고 생각한다.&lt;br /&gt;
나도 특정 커뮤니티를 운영하는 사람으로서 부러운, 그리고 여러모로 본받고싶은 생태계이다.&lt;/p&gt;
&lt;p&gt;명성도를 얻는 방법은 구체적인 방법을 뒤에 작성할 것이지만, 결국은 질문과 답변을 주고받으면 자연스럽게 오르는 규칙이다.&lt;br /&gt;
우선 최초 가입시점 자신의 명성도는 1점으로 시작한다. 아래 그림은 Profile로 들어가본 모습이다. &lt;a href=&quot;#fn4&quot; class=&quot;footnoteRef&quot; id=&quot;fnref4&quot;&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/SO_1.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;명성도 외에도 또 다른 숫자가 점과 함께 표기되어 있다.&lt;br /&gt;
이건 배지(Badge)의 개수를 의미한다.&lt;br /&gt;
배지는 있어도 그만 없어도 그만이지만 있으면 기분이 흡족해지는 그런 물건이 아닌가?&lt;br /&gt;
평판도와 함께 각 배지 종류별 갯수도 함께 표시되어진다.&lt;br /&gt;
배지의 종류는 골드, 실버, 브론즈로 3가지가 나뉘는데 지금 나는 브론즈 배지가 2개가 있다는 것을 의미한다.&lt;br /&gt;
활동을 열심히 해서 평판도와 여러 가지 종류의 배지를 획득하게 되면 Profile 은 이런식으로 발전하게 될 것이다. (R의 knitr 패키지 개발자 Yihui Xie 의 Profile 을 예로 들어보았다)&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/SO_2.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;배지와는 다르게 명성도는 스택오버플로우 이용에 직접적인 영향을 끼친다.&lt;br /&gt;
직접적인 영향이라고 해서 차별이 있는 것이 아니다.&lt;br /&gt;
명성도가 없어도 스택오버플로우를 이용하는데 전혀 문제가 없다.&lt;br /&gt;
다만 일종의 특권(Privilege)이 생기는 것으로 생각하는 게 좋다.&lt;/p&gt;
&lt;p&gt;특권은 명성도가 일정치를 초과했을 시점부터 생긴다.&lt;br /&gt;
표로 정리해보면 이렇다. (지금상황에서 무슨 의미인지 정확하게 모르는 특권은 번역하지 않고 영어로 그대로 놔두었는데, 알게 되면 번역하겠다)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;http://stackoverflow.com/help/privileges?tab=all&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;
&lt;colgroup&gt;
&lt;col style=&quot;width: 8%&quot; /&gt;
&lt;col style=&quot;width: 91%&quot; /&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr class=&quot;header&quot;&gt;
&lt;th style=&quot;text-align: left;&quot;&gt;명성도&lt;/th&gt;
&lt;th style=&quot;text-align: left;&quot;&gt;특권내용&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;25,000&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;스택오버플로우 사이트의 내부분석을 위한 Google analytics 접근이 가능&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;20,000&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;신뢰할 수 있는 사용자로 판단되어 스택오버플로우의 모든 질문글에 대해 편집, 삭제 권한이 부여됨&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;15,000&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;보호된 질문을 사용할 수 있음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;10,000&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;access to moderator tools : Access reports, delete questions, review reviews&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;5,000&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;모든 글에 대해 태그를 수정할 수 있음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;3,000&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;cast close and reopen votes : Help decide whether posts are off-topic or duplicates&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;2,500&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;어떤 태그가 다른것과 동일한 의미를 가지는지 결정할 수 있음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;2,000&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;이미 올려진 질문, 질문에 대한 답변을 즉시 편집할 수 있음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;1,500&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;새로운 태그를 만들 수 있음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;1,000&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;established user : You&#39;ve been around for a while; see vote counts&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;1,000&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;특정한 사람들과 대화할 수 있는 대화방을 만들 수 있음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;500&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;access review queues : Access first posts and late answers review queues&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;250&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;자신의 질문글에 대한 투표를 종료할 수 있고, 이후에 종료된 것을 다시 열 수 있음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;200&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;광고를 줄일 수 있는 옵션을 사용할 수 있음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;125&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;질문과 질문의 답변글에 대해 upvote 외에도 downvote 를 할 수 있음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;100&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;위키 커뮤니티에 협업할 수 있음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;100&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;대화방을 만들 수 있음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;100&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;문서에 대하여 제안된 변경사항에 대하여 승인 및 거부할 수 있음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;75&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;자신의 명성을 보상으로 걸 수 있는 질문을 할 수 있음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;50&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;다른 사람의 게시물에 댓글을 달 수 있음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;20&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;대화방에 참석이 가능&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;15&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;신고기능(Flag)을 이용할 수 있음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;15&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;답변글에 대해 투표가 가능, 단 upvote 만 할 수 있음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;10&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;신규유저에 대한 제한처리 기능 해제&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;10&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;create wiki posts : Create answers that can be easily edited by most users&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;5&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;participate in meta : Discuss the site itself: bugs, feedback, and governance&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;1&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;질문 혹은 답변글을 작성할 수 있음&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;지금 명성도가 1인 나는 질문과 답변글을 작성할 수 있다.&lt;br /&gt;
그런데 예를들어 질문을 열심히하고 답변을 주고받으며 명성도가 15점 이상 되면 다른 질문과 답변에 대해서 투표를 할 수 있다.&lt;br /&gt;
정확히 말하면 upvote 가 가능한데 좋은 Q&amp;amp;A 글이라 생각되는 것에 대해서 점수를 준다고 생각하면 된다.&lt;br /&gt;
그리고 upvote 를 받은 글의 주인은 명성도가 오르게 된다.&lt;br /&gt;
반대로 downvote 도 가능하다. (단 명성도 125 필요)&lt;br /&gt;
스택오버플로우는 이렇게 투표를 받은 질문글이 상위로 노출되어 좀 더 가치 있는 질문글과 답변으로 자가발전하게 되는 식이다.&lt;/p&gt;
&lt;p&gt;명성도를 얻는 방법은 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;내가 작성한 질문에 upvote 가 되면 +5&lt;/li&gt;
&lt;li&gt;내가 작성한 답변에 upvote 가 되면 +10&lt;/li&gt;
&lt;li&gt;내가 작성한 답변이 질문자에 의해 승인이 되면 +15&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;c-see-also&quot;&gt;C) See also&lt;/h2&gt;
&lt;p&gt;스택오버플로우의 가장 아쉬운 점은 영어를 사용해야 한다는 점이다.&lt;br /&gt;
개발 및 코드와 함께 작성될 질문글은 많은 부가적인 설명과 함께 작성하게 될 가능성이 높은데&lt;br /&gt;
영어를 완벽하게 구사하지 못한다면 자신이 표출하고 싶은 의미를 서술하기 힘들 것이다.&lt;/p&gt;
&lt;p&gt;이런 이유때문에 아마도 눈팅만 2년째이었을 수도 있다.&lt;br /&gt;
여하튼 이런 애로사항을 많은 사람이 가지고 있었다는 걸 StackOverflow in Korean (이하 &lt;a href=&quot;(http://stackoverflow-in-korean.github.io/)&quot;&gt;SOK&lt;/a&gt;) 를 통해 알 수 있었다.&lt;br /&gt;
스택오버플로우는 내부적으로 Non-english 를 위한 베타버전을 운용하고 있는데&lt;br /&gt;
한국을 위한 스택오버플로우를 만들기위해 SOK 에서 열심히 온라인 활동을 했었지만 &lt;a href=&quot;http://stackoverflow-in-korean.github.io/docs/%EC%97%B0%ED%98%81/&quot;&gt;기각&lt;/a&gt;되었다고 한다.&lt;br /&gt;
진작에 이런 활동을 알고 있었다면 부족하게나마 도움을 주었을텐데 하는 아쉬움이 많이 든다.&lt;/p&gt;
&lt;p&gt;하지만 해결되지 않은 이 애로사항을 속으로 애타게 해결하고자 하는 분들이 많았을 것이라 본다.&lt;br /&gt;
때문에 이러한 사이트들이 이후에 생긴 게 아닐까?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://dolgo.net/&quot;&gt;돌고넷&lt;/a&gt; (http://dolgo.net)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://hashcode.co.kr&quot;&gt;Hashcode&lt;/a&gt; (http://hashcode.co.kr)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow-in-korean.github.io/&quot;&gt;StackOverflow in Korean&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/tour&quot;&gt;Welcome to Stack Overflow&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;StackOverflow 줄여서 SO라고들 많이 표현한다&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn2&quot;&gt;&lt;p&gt;이렇게 느끼게 된 이유는 무엇일까? 아마도 모른다는 것을 모르는 단계에서, 모르는걸 알게 된 단계로 바뀌어서 그런 걸까!&lt;a href=&quot;#fnref2&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn3&quot;&gt;&lt;p&gt;눈팅시절 가입도 안하고 비로그인 상태에서 스택오버플로우를 이용했었다&lt;a href=&quot;#fnref3&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn4&quot;&gt;&lt;p&gt;굳이 Profile 로 들어가서 확인하지 않아도 스택오버플로우의 최상단 배너에 명성도를 확인할 수 있다&lt;a href=&quot;#fnref4&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Sun, 11 Dec 2016 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/etc/2016/12/11/StackOverflow.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/etc/2016/12/11/StackOverflow.html</guid>
        
        
        <category>etc</category>
        
      </item>
    
      <item>
        <title>R에서 모델적합에 사용되는 formula 인자식 사용부분에 대한 고찰</title>
        <description>&lt;p&gt;R을 이용한 모델링을 할 때 &lt;code&gt;formula&lt;/code&gt; 인자값을 어떤 식으로 입력해야 하는지 정리해 볼 필요가 있다.&lt;br /&gt;
대표적으로 &lt;code&gt;lm()&lt;/code&gt; 함수의 첫 번째 인자에 대한 입력값을 예로 들 수 있을 것이다.&lt;br /&gt;
이 인자값에는 약속에 의해 정해진 기호(operator)를 이용하여 모델의 뼈대를 설정할 수 있다.&lt;br /&gt;
몇가지의 기호만 알고 이를 조합한다면 일반적인 뼈대를 구성하는데 문제가 생기진 않을 것이다.&lt;/p&gt;
&lt;p&gt;(본 글에서 사용될 기초데이터는 &lt;code&gt;mtcars&lt;/code&gt; 이다.)&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;head&lt;/span&gt;(mtcars)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##                    mpg cyl disp  hp drat    wt  qsec vs am gear carb
## Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4
## Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4
## Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1
## Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1
## Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2
## Valiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;a-기호&quot;&gt;A) &amp;quot;~&amp;quot; 기호&lt;/h2&gt;
&lt;p&gt;기본적으로 &lt;code&gt;formula&lt;/code&gt; 인자값의 입력은 종속변수를 앞에 쓰고 독립변수를 뒤에 쓰게 되는데&lt;br /&gt;
종속변수와 독립변수를 구분 짓는 기호는 &amp;quot;~&amp;quot; 이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;lm&lt;/span&gt;(mpg ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;wt, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; mtcars)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = mpg ~ wt, data = mtcars)
## 
## Coefficients:
## (Intercept)           wt  
##      37.285       -5.344&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위의 단순선형회귀적합 코드를 살펴보자.&lt;br /&gt;
&lt;code&gt;lm()&lt;/code&gt; 함수의 첫 번째 인자입력값을 보면 &lt;code&gt;mpg ~ wt&lt;/code&gt; 로 되어있다.&lt;br /&gt;
왼쪽 맨 앞의 &lt;code&gt;mpg&lt;/code&gt; 는 종속변수로 지정하고, 오른쪽 뒤에 있는 &lt;code&gt;wt&lt;/code&gt; 는 독립변수로 지정하겠다는 의미가 된다.&lt;/p&gt;
&lt;h2 id=&quot;b-기호&quot;&gt;B) &amp;quot;+&amp;quot; 기호&lt;/h2&gt;
&lt;p&gt;독립변수를 &lt;code&gt;wt&lt;/code&gt; 뿐만 아니라 &lt;code&gt;cyl&lt;/code&gt; 변수까지 고려하는 다중회귀분석을 하고 싶다면 &amp;quot;+&amp;quot; 기호를 이용해 고려대상이 되는 변수를 추가시킬 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;lm&lt;/span&gt;(mpg ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;wt +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;cyl, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; mtcars)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = mpg ~ wt + cyl, data = mtcars)
## 
## Coefficients:
## (Intercept)           wt          cyl  
##      39.686       -3.191       -1.508&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그런데 만약 자신이 가지고 있는 데이터셋에 종속변수를 설명시킬 독립변수들이 이미 모두 포진되어있는 상태라면, 그리고 그 독립변수들을 모두 고려한 다중회귀적합을 시키고 싶다면 어떻게 해야 할까?&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;lm&lt;/span&gt;(mpg ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;cyl +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;disp +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;hp +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;drat +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;wt +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;qsec +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;vs +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;am +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;gear +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;carb, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; mtcars)  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = mpg ~ cyl + disp + hp + drat + wt + qsec + vs + 
##     am + gear + carb, data = mtcars)
## 
## Coefficients:
## (Intercept)          cyl         disp           hp         drat  
##    12.30337     -0.11144      0.01334     -0.02148      0.78711  
##          wt         qsec           vs           am         gear  
##    -3.71530      0.82104      0.31776      2.52023      0.65541  
##        carb  
##    -0.19942&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이런 식으로 고려대상이 되는 독립변수의 명칭을 모두 적은 다음&lt;br /&gt;
사이사이에 &amp;quot;+&amp;quot; 기호를 무식하게 넣어주어야 하는 상황이다.&lt;br /&gt;
하지만 위의 코딩은 매우 비효율적 🙄 손이 아파질 수 있다.&lt;/p&gt;
&lt;h2 id=&quot;c-.-기호&quot;&gt;C) &amp;quot;.&amp;quot; 기호&lt;/h2&gt;
&lt;p&gt;이를 대비해 특수하게 약속된 &amp;quot;.&amp;quot; 기호를 이용하면 좋다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;lm&lt;/span&gt;(mpg ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;., &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; mtcars)  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = mpg ~ ., data = mtcars)
## 
## Coefficients:
## (Intercept)          cyl         disp           hp         drat  
##    12.30337     -0.11144      0.01334     -0.02148      0.78711  
##          wt         qsec           vs           am         gear  
##    -3.71530      0.82104      0.31776      2.52023      0.65541  
##        carb  
##    -0.19942&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;quot;.&amp;quot; 기호는 &amp;quot;전부&amp;quot; 의 의미를 가진다.&lt;br /&gt;
위의 코드는 종속변수로 이미 배정된 mpg 이외의 모든 변수를 독립변수로 고려하라 라는 의미가 된다.&lt;/p&gt;
&lt;h2 id=&quot;d---기호&quot;&gt;D) &amp;quot;-&amp;quot; 기호&lt;/h2&gt;
&lt;p&gt;&amp;quot;+&amp;quot; 기호의 반대는 &amp;quot;-&amp;quot; 이다. 의미 역시 반대이다.&lt;br /&gt;
고려대상에서 추가하는 &amp;quot;+&amp;quot; 와 다르게 &amp;quot;-&amp;quot; 는 고려대상에서 제외시킨다.&lt;br /&gt;
&amp;quot;.&amp;quot; 기호를 통해 모든 독립변수를 배정했는데, 여기서 &lt;code&gt;cyl&lt;/code&gt; 변수만은 독립변수에서 제외하고 싶을 경우&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;lm&lt;/span&gt;(mpg ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;. -&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;cyl, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; mtcars)  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = mpg ~ . - cyl, data = mtcars)
## 
## Coefficients:
## (Intercept)         disp           hp         drat           wt  
##    10.96007      0.01283     -0.02191      0.83520     -3.69251  
##        qsec           vs           am         gear         carb  
##     0.84244      0.38975      2.57743      0.71155     -0.21958&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이렇게 &amp;quot;-&amp;quot; 기호를 활용하면 된다.&lt;/p&gt;
&lt;p&gt;한 가지 덧붙이자면 회귀적합시 기본적으로 절편(intercept)을 고려하는 회귀적합을 하게 되는데, 절편이 0인 모델로 적합하고 싶은 경우 절편항을 제외시켜야 할 것이다.&lt;br /&gt;
&amp;quot;-&amp;quot; 기호를 아래와 같이 이용하면 된다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;lm&lt;/span&gt;(mpg ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;. -&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; mtcars)  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = mpg ~ . - 1, data = mtcars)
## 
## Coefficients:
##      cyl      disp        hp      drat        wt      qsec        vs  
##  0.35083   0.01354  -0.02055   1.24158  -3.82613   1.19140   0.18972  
##       am      gear      carb  
##  2.83222   1.05426  -0.26321&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;결과를 확인해 보면 항시 언급되었던 절편항 &amp;quot;(Intercept)&amp;quot; 이 없어진 것을 확인할 수 있다.&lt;br /&gt;
참고로 아래와 같이 해도 절편항을 제외한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;lm&lt;/span&gt;(mpg ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;. +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; mtcars)  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = mpg ~ . + 0, data = mtcars)
## 
## Coefficients:
##      cyl      disp        hp      drat        wt      qsec        vs  
##  0.35083   0.01354  -0.02055   1.24158  -3.82613   1.19140   0.18972  
##       am      gear      carb  
##  2.83222   1.05426  -0.26321&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;e-기호&quot;&gt;E) &amp;quot;:&amp;quot; 기호&lt;/h2&gt;
&lt;p&gt;회귀적합에서 상호작용에 대해 고려한다면 &amp;quot;:&amp;quot; 기호를 이용하여 상호작용항을 부여할 수 있다.&lt;br /&gt;
만약 종속변수 &lt;code&gt;mpg&lt;/code&gt; 에 대해 설명하는 독립변수를 &lt;code&gt;wt&lt;/code&gt;, &lt;code&gt;cyl&lt;/code&gt; 2개 설정하고,&lt;br /&gt;
이 두 변수의 상호작용까지 고려하고자 한다면 이렇게 하면 된다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;lm&lt;/span&gt;(mpg ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;wt +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;cyl +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;wt:cyl, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; mtcars)  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = mpg ~ wt + cyl + wt:cyl, data = mtcars)
## 
## Coefficients:
## (Intercept)           wt          cyl       wt:cyl  
##     54.3068      -8.6556      -3.8032       0.8084&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그런데 고려대상인 독립변수가 3개 이상, 그리고 독립변수의 조합별 상호작용을 고려하게 된다면 골치가 아플 수 있다.&lt;br /&gt;
예를 들어 &lt;code&gt;mpg&lt;/code&gt; 에 대해 설명하는 독립변수를 &lt;code&gt;wt&lt;/code&gt;, &lt;code&gt;cyl&lt;/code&gt;, &lt;code&gt;gear&lt;/code&gt; 3개이고, 3개의 모든 조합에 대해 상호작용을 고려한다면 &lt;code&gt;formula&lt;/code&gt; 인자값이 아래처럼 매우 길게 된다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;lm&lt;/span&gt;(mpg ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;wt +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;cyl +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;gear +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;wt:cyl +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;wt:gear +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;cyl:gear +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;wt:cyl:gear, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; mtcars)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = mpg ~ wt + cyl + gear + wt:cyl + wt:gear + cyl:gear + 
##     wt:cyl:gear, data = mtcars)
## 
## Coefficients:
## (Intercept)           wt          cyl         gear       wt:cyl  
##     47.3853     -10.4502      -0.8957       2.2704       0.5459  
##     wt:gear     cyl:gear  wt:cyl:gear  
##      0.3527      -0.8794       0.1001&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;f-기호&quot;&gt;F) &amp;quot;*&amp;quot; 기호&lt;/h2&gt;
&lt;p&gt;상호작용항을 고려하되 각 개별항과 상호작용항이 될 수 있는 모든 조합을 알아서 배정시키는&lt;br /&gt;
약속된 기호가 바로 &amp;quot;*&amp;quot; 이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;lm&lt;/span&gt;(mpg ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;wt *&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;cyl *&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;gear, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; mtcars)  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = mpg ~ wt * cyl * gear, data = mtcars)
## 
## Coefficients:
## (Intercept)           wt          cyl         gear       wt:cyl  
##     47.3853     -10.4502      -0.8957       2.2704       0.5459  
##     wt:gear     cyl:gear  wt:cyl:gear  
##      0.3527      -0.8794       0.1001&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위의&lt;br /&gt;
&lt;code&gt;mpg ~ wt * cyl * gear&lt;/code&gt;&lt;br /&gt;
는&lt;br /&gt;
&lt;code&gt;mpg ~ wt + cyl + gear + wt:cyl + wt:gear + cyl:gear + wt:cyl:gear&lt;/code&gt;&lt;br /&gt;
와 동일한 것이다.&lt;br /&gt;
따라서 실행된 코드의 출력결과도 비교해 보면 같은 것을 확인할 수 있다.&lt;/p&gt;
&lt;h2 id=&quot;g-i-함수&quot;&gt;G) &lt;code&gt;I()&lt;/code&gt; 함수&lt;/h2&gt;
&lt;p&gt;만약 분석자 나름대로 다변수들의 정보를 하나로 압축시킨 파생변수로 회귀적합을 하고 싶다면 어떻게 해야 할까?&lt;br /&gt;
예를 들어 &lt;code&gt;hp&lt;/code&gt; 변수값과 루트를 씌운 &lt;code&gt;wt&lt;/code&gt;변수값을 더하고 &lt;code&gt;carb&lt;/code&gt; 변수의 값을 뺀 값을 독립변수로 설정하여 단순회귀적합을 하고 싶다고 가정해보자. (일부러 의미 없이 복잡하게 설정해 봄)&lt;/p&gt;
&lt;p&gt;일단 떠오르는 방법은 &lt;code&gt;mtcars&lt;/code&gt; 에 새로운 변수열을 만들어 위의 상황대로&lt;/p&gt;
&lt;p&gt;hp + sqrt(wt) - carb&lt;/p&gt;
&lt;p&gt;를 계산한 새로운 변수를 만들어 이 변수열과 회귀적합을 하면 될 것이다.&lt;br /&gt;
하지만 &lt;code&gt;I()&lt;/code&gt; 함수를 알게 된다면 새로운 변수를 직접 만들 필요가 없다. 이렇게 하면 된다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;lm&lt;/span&gt;(mpg ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;I&lt;/span&gt;(hp +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;sqrt&lt;/span&gt;(wt) -&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;carb), &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; mtcars)  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = mpg ~ I(hp + sqrt(wt) - carb), data = mtcars)
## 
## Coefficients:
##             (Intercept)  I(hp + sqrt(wt) - carb)  
##                30.20584                 -0.06945&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그런데 한 가지 의문이 생길 수 있다.&lt;br /&gt;
만약 &lt;code&gt;I()&lt;/code&gt; 함수를 이용하지 않고 &lt;code&gt;formula&lt;/code&gt; 에 &lt;code&gt;hp + sqrt(wt) - carb&lt;/code&gt; 의 날것의 형태로 입력하면 되지 않을까? 라는 의문이다.&lt;br /&gt;
실행해보면 다음과 같다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;lm&lt;/span&gt;(mpg ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;hp +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;sqrt&lt;/span&gt;(wt) -&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;carb, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; mtcars)  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = mpg ~ hp + sqrt(wt) - carb, data = mtcars)
## 
## Coefficients:
## (Intercept)           hp     sqrt(wt)  
##    50.42823     -0.02908    -14.70273&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;우리가 줄곧 배운 &lt;code&gt;formula&lt;/code&gt; 의 입력값은 특정한 기호에 의해 약속된 문법을 따른다.&lt;br /&gt;
따라서 &lt;code&gt;hp + sqrt(wt) - carb&lt;/code&gt; 의 형태는 우리가 원하는 파생변수를 만들어 적합시키지 않는다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;hp&lt;/code&gt; 값에 &lt;code&gt;sqrt(wt)&lt;/code&gt; 값이 더해진 후 &lt;code&gt;carb&lt;/code&gt; 변수값이 차감된 것을 원하지만,&lt;br /&gt;
독립변수에 &lt;code&gt;hp&lt;/code&gt;, &lt;code&gt;sqrt(wt)&lt;/code&gt; 가 따로따로 고려되고 &lt;code&gt;carb&lt;/code&gt; 변수가 독립변수로 제외됨을 명시할 뿐이다.&lt;/p&gt;
&lt;p&gt;다시 &lt;code&gt;I()&lt;/code&gt; 함수를 이용한 결과로 돌아가 보면 &lt;code&gt;I()&lt;/code&gt; 의 쓰임은 결국 &lt;code&gt;formula&lt;/code&gt; 인자의 약속된 문법을 escape 하는 역할로 볼 수도 있겠다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;formula&lt;/code&gt; 인자에 입력할 값의 사용방법과 기호의 의미를 정리해 보았다.&lt;br /&gt;
위의 내용 외에도 더 많은 팁과 기호들의 조합을 생각해 볼 수 있을 것이다.&lt;/p&gt;
</description>
        <pubDate>Tue, 06 Dec 2016 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2016/12/06/formula_usage.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2016/12/06/formula_usage.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>R에서 factor 형 자료 처리를 위한 forcats package 에 대해</title>
        <description>&lt;br&gt;&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/forcats_1.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;a-개요&quot;&gt;A) 개요&lt;/h2&gt;
&lt;p&gt;R에서 범주형 변수를 다룰 때 factor 형을 이용한다.&lt;br /&gt;
범주형 자료는 연속형 자료와는 다르게 그 자체의 고유한 의미를 가진다는 특성때문에 정성적인 관리가 필요한 편이다.&lt;br /&gt;
애초에 많은 관심을 필요로 하고 있다고 볼 수 있다.&lt;br /&gt;
이러한 이유로 범주형 자료를 접근하고 핸들링하는 많은 함수들이 R에 존재한다.&lt;/p&gt;
&lt;p&gt;최근에는 factors 의 알파벳 순서를 교묘히(?) 바꾸어 네이밍한 &lt;a href=&quot;https://cran.r-project.org/web/packages/forcats/forcats.pdf&quot;&gt;forcats package&lt;/a&gt; 가 CRAN 에 등록되었는데, &lt;del&gt;고양이를 위한 패키지가 아니라&lt;/del&gt; factor형 핸들링을 위한 함수들이 제공되는 패키지이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The goal of the &lt;strong&gt;forcats&lt;/strong&gt; package is to provide a suite of useful tools that solve common problems with factors.&lt;br /&gt;
- &lt;a href=&quot;https://github.com/tidyverse/forcats&quot;&gt;forcats package 의 README.md 중&lt;/a&gt;에서&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;b-패키지-설치&quot;&gt;B) 패키지 설치&lt;/h2&gt;
&lt;p&gt;CRAN 에 등록되어 있으므로&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;install.packages&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;forcats&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;로 설치할 수 있다.&lt;/p&gt;
&lt;p&gt;major 버전은 아직 0 이므로 계속적으로 개발될 가능성이 있는 상태이다.&lt;br /&gt;
개발버전을 사용하고 싶다면 Github 를 통해 패키지를 설치해도 되겠다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;co&quot;&gt;# Or the the development version from GitHub:&lt;/span&gt;
devtools::&lt;span class=&quot;kw&quot;&gt;install_github&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;tidyverse/forcats&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;c-getting-started&quot;&gt;C) Getting started&lt;/h2&gt;
&lt;p&gt;forcats package 의 함수들은 &amp;quot;fct_&amp;quot; 로 시작한다.&lt;br /&gt;
이후의 단어가 함수쓰임의 의미를 담고 있다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;table&gt;
&lt;colgroup&gt;
&lt;col style=&quot;width: 11%&quot; /&gt;
&lt;col style=&quot;width: 88%&quot; /&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr class=&quot;header&quot;&gt;
&lt;th style=&quot;text-align: left;&quot;&gt;함수명칭&lt;/th&gt;
&lt;th style=&quot;text-align: left;&quot;&gt;내용&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;fct_anon&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;Anonymise factor levels&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;fct_c&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;Concatenate factors, unioning levels.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;fct_collapse&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;Collapse factors into groups.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;fct_count&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;Count entries in a factor&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;fct_drop&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;Drop unnused levels&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;fct_expand&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;Add additional levels to a factor&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;fct_explicit_na&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;Make missing values explicit&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;fct_infreq&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;Reorders levels in order of first appearance or frequency.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;fct_inorder&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;Reorders levels in order of first appearance or frequency.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;fct_lump&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;Lump together least/most common levels into &amp;quot;other&amp;quot;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;fct_recode&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;Change the levels of a factor&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;fct_relevel&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;Change the order of levels in a factor&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;fct_reorder&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;Reorder the levels of a function according to another variable&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;fct_reorder2&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;Reorder the levels of a function according to another variable&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;fct_rev&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;Reverse the levels of a factor&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;fct_shift&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;Shift the order of levels of a factor&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;fct_shuffle&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;Randomly permute the levels of a factor&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;fct_unify&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;Unify the levels in a list of factors&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;fct_unique&lt;/td&gt;
&lt;td style=&quot;text-align: left;&quot;&gt;Unique values of a factor&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;접두사 &amp;quot;fct_&amp;quot; 가 코딩할 때 불편할 수도 있겠다 싶지만, 오히려 &amp;quot;fct_&amp;quot; 가 있음으로 변수형자료를 핸들링하는 것임을 정확하게 인지할 수 있는 tag같은 역할을 하는 것 같기도 해서 나는 개인적으로 좋다. &lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;여하튼 이 함수들 중 자주 사용하는 것을 몇 개 언급해보고자 한다.&lt;/p&gt;
&lt;h3 id=&quot;c-1-fct_recode&quot;&gt;C-1) &lt;code&gt;fct_recode()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;factor 형 자료를 다룰 때 가장 번거로운 것 중 하나는 요인의 성격을 보존한 채 오직 명칭만 변경하는 과정이다.&lt;/p&gt;
&lt;p&gt;예를들면&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;ex &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;factor&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;L&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;M&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;small&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;small&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;L&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;M&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;L&amp;quot;&lt;/span&gt;), 
    &lt;span class=&quot;dt&quot;&gt;levels =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;small&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;M&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;L&amp;quot;&lt;/span&gt;))
ex&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] L     M     small small L     M     L    
## Levels: small M L&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위와 같은 &lt;code&gt;ex&lt;/code&gt; factor 형 자료의 요인들은 &amp;quot;small&amp;quot;, &amp;quot;M&amp;quot;, &amp;quot;L&amp;quot; 3개가 있다.&lt;br /&gt;
흠.. 그런데 요인의 명칭이 뭔가 맘에 들지 않는다(고 가정하자).&lt;br /&gt;
특히 &amp;quot;small&amp;quot; 을 &amp;quot;S&amp;quot; 로 바꾸기만 하면 좋을 것 같아&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;levels&lt;/span&gt;(ex)[&lt;span class=&quot;kw&quot;&gt;levels&lt;/span&gt;(ex) ==&lt;span class=&quot;st&quot;&gt; &amp;quot;small&amp;quot;&lt;/span&gt;] &amp;lt;-&lt;span class=&quot;st&quot;&gt; &amp;quot;S&amp;quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;와 같은 코딩을 필자 이전까지 해왔었다.&lt;br /&gt;
전통적인 방식이지만 어찌 보면 무식하고 조악한 코딩일 수도 있겠다.&lt;/p&gt;
&lt;p&gt;forcats package 에선 위의 예시처럼 요인명칭을 변경할 일이 있을 때&lt;br /&gt;
수준들의 위치를 인덱싱해 수동적으로 바꾸는 방법 대신 &lt;code&gt;fct_recode()&lt;/code&gt; 라는 함수를 통해 바꿀 수 있는 방법을 제공한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;fct_recode&lt;/span&gt;(ex, &lt;span class=&quot;dt&quot;&gt;S =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;small&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] L M S S L M L
## Levels: S M L&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;잠깐 딴 길로 세보자.&lt;br /&gt;
함수로써 제공한다는 것은 의외로 큰 의미가 있는데&lt;br /&gt;
R을 제대로 사용하시는 분들이라면 이 의미는 가볍게 알 것이다.&lt;br /&gt;
&lt;code&gt;fct_recode()&lt;/code&gt; 함수 이외의 forcats package 내에 함수들은 모두 혼자서 외롭게 활용될 일은 거의 없을 것이다.&lt;br /&gt;
아래 코드는 dplyr package 와 함께 &lt;code&gt;fct_recode()&lt;/code&gt; 함수를 좀 더 실용적으로 사용해 본 예라고 할 수 있겠다. (참고로 &lt;code&gt;gss_cat&lt;/code&gt; 는 forcats 패키지에 내장되어있는 데이터셋이다)&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;co&quot;&gt;# Origin&lt;/span&gt;
gss_cat %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;count&lt;/span&gt;(partyid)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 10 &amp;lt;U+00D7&amp;gt; 2
##               partyid     n
##                &amp;lt;fctr&amp;gt; &amp;lt;int&amp;gt;
## 1           No answer   154
## 2          Don&amp;#39;t know     1
## 3         Other party   393
## 4   Strong republican  2314
## 5  Not str republican  3032
## 6        Ind,near rep  1791
## 7         Independent  4119
## 8        Ind,near dem  2499
## 9    Not str democrat  3690
## 10    Strong democrat  3490&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;co&quot;&gt;# Change level values&lt;/span&gt;
gss_cat %&amp;gt;%
&lt;span class=&quot;st&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;mutate&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;partyid =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;fct_recode&lt;/span&gt;(partyid,
    &lt;span class=&quot;st&quot;&gt;&amp;quot;Republican, strong&amp;quot;&lt;/span&gt;    =&lt;span class=&quot;st&quot;&gt; &amp;quot;Strong republican&amp;quot;&lt;/span&gt;,
    &lt;span class=&quot;st&quot;&gt;&amp;quot;Republican, weak&amp;quot;&lt;/span&gt;      =&lt;span class=&quot;st&quot;&gt; &amp;quot;Not str republican&amp;quot;&lt;/span&gt;,
    &lt;span class=&quot;st&quot;&gt;&amp;quot;Independent, near rep&amp;quot;&lt;/span&gt; =&lt;span class=&quot;st&quot;&gt; &amp;quot;Ind,near rep&amp;quot;&lt;/span&gt;,
    &lt;span class=&quot;st&quot;&gt;&amp;quot;Independent, near dem&amp;quot;&lt;/span&gt; =&lt;span class=&quot;st&quot;&gt; &amp;quot;Ind,near dem&amp;quot;&lt;/span&gt;,
    &lt;span class=&quot;st&quot;&gt;&amp;quot;Democrat, weak&amp;quot;&lt;/span&gt;        =&lt;span class=&quot;st&quot;&gt; &amp;quot;Not str democrat&amp;quot;&lt;/span&gt;,
    &lt;span class=&quot;st&quot;&gt;&amp;quot;Democrat, strong&amp;quot;&lt;/span&gt;      =&lt;span class=&quot;st&quot;&gt; &amp;quot;Strong democrat&amp;quot;&lt;/span&gt;
  )) %&amp;gt;%
&lt;span class=&quot;st&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;count&lt;/span&gt;(partyid)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 10 &amp;lt;U+00D7&amp;gt; 2
##                  partyid     n
##                   &amp;lt;fctr&amp;gt; &amp;lt;int&amp;gt;
## 1              No answer   154
## 2             Don&amp;#39;t know     1
## 3            Other party   393
## 4     Republican, strong  2314
## 5       Republican, weak  3032
## 6  Independent, near rep  1791
## 7            Independent  4119
## 8  Independent, near dem  2499
## 9         Democrat, weak  3690
## 10      Democrat, strong  3490&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;c-2-fct_lump&quot;&gt;C-2) &lt;code&gt;fct_lump()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;lump 영단어의 뜻은 &amp;quot;덩어리&amp;quot;, &amp;quot;한 무더기&amp;quot; 정도이다.&lt;br /&gt;
파편들을 모아 한 덩어리로 만들어 주는 &lt;code&gt;fct_lump()&lt;/code&gt;, 곰곰이 생각해 보면 &amp;quot;파편들을 모아 한 덩어리로 만드는&amp;quot; 일은 꽤 많다.&lt;br /&gt;
이런 예제를 생각하면 바로 이해가 될 것 같다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;d2 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;gss_cat %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;count&lt;/span&gt;(partyid) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;arrange&lt;/span&gt;(n)

&lt;span class=&quot;kw&quot;&gt;pie&lt;/span&gt;(d2$n, d2$partyid)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/forcats_2.png&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;응답 비율이 매우 낮은 요인들은 &amp;quot;Don&#39;t know&amp;quot;, &amp;quot;No answer&amp;quot;, &amp;quot;Other party&amp;quot; 등이 있다.&lt;br /&gt;
응답 비율이 너무 낮아서 pie chart 에 잘 보이지 않고 겹쳐저 있다.&lt;br /&gt;
그리고 응답 비율이 너무 낮은것은 때로는 의미가 없어 &amp;quot;etc&amp;quot; 와 같은 기타항목으로 처리하곤 하는데&lt;br /&gt;
이때 &amp;quot;Don&#39;t know&amp;quot;, &amp;quot;No answer&amp;quot;, &amp;quot;Other party&amp;quot; 에 해당되는 요인들을 기타 항목으로 덩어리를 만들기 위해선 뜻밖에 많은 고민이 필요할 수 있다.&lt;/p&gt;
&lt;p&gt;우리가 알고 있는 &lt;code&gt;fct_recode()&lt;/code&gt; 함수로 이를 해결할 수도 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;d2 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;gss_cat %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;mutate&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;partyid =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;fct_recode&lt;/span&gt;(partyid, 
        &lt;span class=&quot;st&quot;&gt;&amp;quot;etc&amp;quot;&lt;/span&gt; =&lt;span class=&quot;st&quot;&gt; &amp;quot;Don&amp;#39;t know&amp;quot;&lt;/span&gt;,
        &lt;span class=&quot;st&quot;&gt;&amp;quot;etc&amp;quot;&lt;/span&gt; =&lt;span class=&quot;st&quot;&gt; &amp;quot;No answer&amp;quot;&lt;/span&gt;,
        &lt;span class=&quot;st&quot;&gt;&amp;quot;etc&amp;quot;&lt;/span&gt; =&lt;span class=&quot;st&quot;&gt; &amp;quot;Other party&amp;quot;&lt;/span&gt;
    )) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;count&lt;/span&gt;(partyid) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;arrange&lt;/span&gt;(n)

&lt;span class=&quot;kw&quot;&gt;pie&lt;/span&gt;(d2$n, d2$partyid)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/forcats_3.png&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;응답 비율이 낮은 요인들을 &amp;quot;etc&amp;quot; 라는 명칭으로 바꾸면 된다.&lt;/p&gt;
&lt;p&gt;음.. 그런데 좋은 해결책으로도 보일 수 있겠지만 이방법은 비효율적인 문제가 역시 있다.&lt;br /&gt;
일단 &amp;quot;Don&#39;t know&amp;quot;, &amp;quot;No answer&amp;quot;, &amp;quot;Other party&amp;quot; 3개의 요인이 응답 비율이 낮은 것임을 사후적으로 인지해야 하고,&lt;br /&gt;
이후 &amp;quot;etc&amp;quot; 라는 명칭으로 바꾸는 것은 뭔가 일을 2번하는 느낌을 받을 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fct_lump()&lt;/code&gt; 함수는 이처럼 &amp;quot;etc&amp;quot; 라는 덩어리를 아주 간단하게 만들어 준다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;d2 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;gss_cat %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;mutate&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;partyid =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;fct_lump&lt;/span&gt;(partyid, &lt;span class=&quot;dt&quot;&gt;n =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;other_level =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;etc&amp;quot;&lt;/span&gt;)) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;count&lt;/span&gt;(partyid) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;arrange&lt;/span&gt;(n)

&lt;span class=&quot;kw&quot;&gt;pie&lt;/span&gt;(d2$n, d2$partyid)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/forcats_4.png&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fct_lump(partyid, n = 7, other_level = &amp;quot;etc&amp;quot;)&lt;/code&gt; 를 살펴보면 &lt;code&gt;n&lt;/code&gt; 인자를 7로 설정하여 7개의 주항목 요인 외에는 &amp;quot;etc&amp;quot; 라는 명칭으로 자동으로 바꿔준다.&lt;br /&gt;
따라서 pie chart를 보면 소수의견인 &amp;quot;Don&#39;t know&amp;quot;, &amp;quot;No answer&amp;quot;, &amp;quot;Other party&amp;quot; 요인들이 &amp;quot;etc&amp;quot; 로 통합된 것을 확인할 수 있다.&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.r-bloggers.com/forcats-0-1-0-%F0%9F%90%88%F0%9F%90%88%F0%9F%90%88%F0%9F%90%88/&quot;&gt;forcats 0.1.0 🐈🐈🐈🐈&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;Rstudio IDE 를 사용하고 있다면 &lt;kbd&gt;tap&lt;/kbd&gt;을 이용한 자동완성을 이용하면 그렇게 불편하지도 않다&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Sun, 13 Nov 2016 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2016/11/13/forcats_package.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2016/11/13/forcats_package.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>Alfred(알프레드) 에서 검색쿼리 등록을 통한 간편검색</title>
        <description>&lt;a href=&quot;https://www.alfredapp.com/&quot;&gt;&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/alfred_1.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Mac에서 Spotlight 대용으로 &lt;a href=&quot;https://www.alfredapp.com/&quot;&gt;Alfred&lt;/a&gt; 를 사용 중이며 최대한 다양한 기능들을 이용해 보고 있었다.&lt;br /&gt;
개인적으로 가장 생산성이 높은, 그리고 자주 사용하는 기능은 검색쿼리를 등록해 한방에 검색하는 편의를 가장 많이 느끼고 있었다.&lt;/p&gt;
&lt;h2 id=&quot;a-alfred-검색쿼리-기능&quot;&gt;A) Alfred 검색쿼리 기능&lt;/h2&gt;
&lt;p&gt;부연설명을 하자면 아래와 같다.&lt;br /&gt;
만약 영어를 잘하고 싶어서 네이버에 &amp;quot;영어를 잘하는 법&amp;quot; 이라는 검색어로 검색을 원할 때 보통 아래와 같은 과정일 것이다. &lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;네이버 웹페이지가 뜨는 것을 기다린 후, &lt;code&gt;영어를 잘하는 법&lt;/code&gt; 으로 검색바에 타자를 치고 엔터를 누름&lt;/strong&gt; &lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;그런데 여기서 네이버라는 특정 검색 서비스 웹페이지를 들어가는 과정이 번거로울 수 있다.&lt;br /&gt;
네이버를 Alfred 에 검색 키워드로 등록하고 (예를 들어 &lt;code&gt;na&lt;/code&gt; 라고 등록한다면) 검색쿼리 설정을 해놓으면 &lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;kbd&gt;⌥&lt;/kbd&gt; + &lt;kbd&gt;Space&lt;/kbd&gt; 로 Alfred 실행 후 &lt;code&gt;na 영어를 잘하는 법&lt;/code&gt; 타자 치고 엔터를 누름&lt;/strong&gt; &lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;이란 과정으로 검색을 간편하게 할 수 있을 것이다.&lt;/p&gt;
&lt;h2 id=&quot;b-alfred-검색쿼리-등록방법-alfred-v3.1.1-을-기준&quot;&gt;B) Alfred 검색쿼리 등록방법 (Alfred v3.1.1 을 기준)&lt;/h2&gt;
&lt;p&gt;등록방법을 구구절절 쓰는 것 보다 스크린캐스트를 보는 것이 좋을 것 같다.&lt;br /&gt;
아래 영상처럼 하면 된다.&lt;br /&gt;
이 영상은 Alfred 에 Github 검색쿼리를 등록한 후 테스트하는 영상이 되겠다.&lt;/p&gt;
&lt;iframe width=&quot;100%&quot; height=&quot;400&quot; src=&quot;https://www.youtube.com/embed/eG_Z5INGfsM&quot; frameborder=&quot;0&quot; allowfullscreen&gt;
&lt;/iframe&gt;
&lt;h2 id=&quot;c-alfred-검색쿼리-예시&quot;&gt;C) Alfred 검색쿼리 예시&lt;/h2&gt;
&lt;p&gt;최근에 나는 Alfred 가 3.X 버전을 출시하면서 이전 1.X 버전을 생각 없이 지웠는데&lt;br /&gt;
아쉽게도 1.X 버전에 커스터마이징 된 환경들이 싹 날라가 버렸다. 😓&lt;/p&gt;
&lt;p&gt;특히 검색쿼리를 다시 찾고 세팅하는 것이 번거로웠는데&lt;br /&gt;
이참에 글로 쫙 정리해놓아야 겠다는 생각이 들었다.&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.naver.com/&quot;&gt;Naver&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;http://search.naver.com/search.naver?query={query}&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://endic.naver.com/?sLn=kr&quot;&gt;Naver 영어사전&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;http://endic.naver.com/search.nhn?sLn=kr&amp;amp;query={query}&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://soundcloud.com&quot;&gt;Soundcloud&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;https://soundcloud.com/search?q={query}&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/&quot;&gt;Github&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;https://github.com/search?q={query}&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.r-bloggers.com/&quot;&gt;R-bloggers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;https://www.r-bloggers.com/search/{query}/&lt;/code&gt;&lt;/pre&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;필자가 자주 이용하는 웹페이지를 기준으로 정리했다. Alfred 에서 기본적으로 지원해주는 구글, 위키, 트위터, 페이스북등의 쿼리를 제외하고 내가 자주 사용하는 사이트들에 대한 부분이다.&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Sun, 23 Oct 2016 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/open_source_tool/2016/10/23/Alfred_SearchQuery.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/open_source_tool/2016/10/23/Alfred_SearchQuery.html</guid>
        
        
        <category>Open_Source_Tool</category>
        
      </item>
    
      <item>
        <title>R에서 ggmap, ggplot2 패키지를 이용한 지도 출력 및 경로 표현하기 간단예제</title>
        <description>&lt;p&gt;&amp;quot;map&amp;quot; 이란 단어에 &amp;quot;Google&amp;quot; 의 &amp;quot;g&amp;quot; 알파벳 2개를 덧붙인 것으로 추정이 바로 되는&lt;br /&gt;
&lt;a href=&quot;https://cran.r-project.org/web/packages/ggmap/ggmap.pdf&quot;&gt;ggmap package&lt;/a&gt; 는 &lt;a href=&quot;https://enterprise.google.com/intl/ko/maps/products/mapsapi.html&quot;&gt;Google map API&lt;/a&gt; 를 이용하여 지도자료를 불러와주는 역할을 하는 패키지이다.&lt;/p&gt;
&lt;p&gt;간략한 예제를 통해 &amp;quot;ggmap&amp;quot; 패키지의 주요 함수 &lt;code&gt;get_googlemap()&lt;/code&gt;, &lt;code&gt;ggmap()&lt;/code&gt; 2개의 사용방법을 알아본 후&lt;br /&gt;
지도위에 간단한 경로를 결합하는 간단한 예제를 실습해 보고자 한다.&lt;/p&gt;
&lt;h2 id=&quot;a-우리나라-지도-호출&quot;&gt;A) 우리나라 지도 호출&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;getmap &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;get_googlemap&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;seoul&amp;quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;ggmap&lt;/span&gt;(getmap)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/ggmap-1-1.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;위의 2줄 코드는 서울시를 중심으로 google 지도 그림을 로드시켜&lt;br /&gt;
R에 plotting 하는 코드이다.&lt;/p&gt;
&lt;p&gt;정말 간단한 로직으로 동작하는 편이다.&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;code&gt;get_googlemap()&lt;/code&gt; 함수를 통해 불러오고 싶은 곳의 장소를 문자열 값으로 첫 번째 인자에 넣어 실행해 이를 객체화 함&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ggmap()&lt;/code&gt; 함수 안에 방금 만든 객체를 입력시킨 후 실행하면 원하는 장소를 중심으로 구글 지도가 plotting 됨&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;로직이 이처럼 간단하므로 앞으로 체인연산자(chain operation)를 사용해 간단히 한 줄로 실행하겠다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;get_googlemap&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;seoul&amp;quot;&lt;/span&gt;) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;ggmap&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;b-ggplot2-의-함수들과-조합&quot;&gt;B) ggplot2 의 함수들과 조합&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ggmap()&lt;/code&gt; 으로 반환되는 결과물은 기본적으로 ggplot 기반의 결과물인데 이점을 이용하여 ggplot2 패키지의 함수와 조합해 지도 위에 새로운 정보들을 더할 수 있다.&lt;br /&gt;
&amp;quot;ggmap&amp;quot;, &amp;quot;ggplot2&amp;quot; 이 두 패키지의 조합은 다양한 Geo Visualization(지리적 시각화) 을 구사할 수 있는 잠재력이 있을거라 생각된다.&lt;br /&gt;
지금은 복잡한 실습보단 간단한 예제를 통해 맛보기를 아래처럼 해보았다.&lt;/p&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/ggmap-3-1.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;그림을 다시 자세히 보면 x축이 &amp;quot;lon&amp;quot; 이라고 적혀있고, y축은 &amp;quot;lat&amp;quot; 라고 적혀 있다.&lt;br /&gt;
&amp;quot;lon&amp;quot; 은 경도(longitude), &amp;quot;lat&amp;quot; 은 위도(latitude) 를 각각 뜻한다고 볼 수 있다.&lt;/p&gt;
&lt;p&gt;즉 위도와 경도의 데이터가 있다면 이 지도 위에 ggplot2 를 이용하여 무언가를 덧그릴 수 있을 것이다.&lt;/p&gt;
&lt;h3 id=&quot;b-1-포인팅&quot;&gt;B-1) 포인팅&lt;/h3&gt;
&lt;p&gt;의미는 크게 없지만, 서초역과 강남역 부근에 무언가 장난을 쳐보려 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;서초역 : 경도 127.007675, 위도 37.491843&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;강남역 : 경도 127.027544, 위도 37.497968&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;즉&lt;br /&gt;
(127.007675, 37.491843), (127.027544, 37.497968)&lt;br /&gt;
좌표에 점을 찍게 되면 서초역과 강남역의 위치에 다음과 같은 모습이 된다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;p1 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;get_googlemap&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;seoul&amp;quot;&lt;/span&gt;) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;ggmap

locationInfo &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;data.frame&lt;/span&gt;(
  &lt;span class=&quot;dt&quot;&gt;Name =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;서초역&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;강남역&amp;quot;&lt;/span&gt;), 
  &lt;span class=&quot;dt&quot;&gt;lon =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;fl&quot;&gt;127.007675&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;127.027544&lt;/span&gt;),
    &lt;span class=&quot;dt&quot;&gt;lat =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;fl&quot;&gt;37.491843&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;37.497968&lt;/span&gt;)
)

p1 +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;geom_point&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; locationInfo, &lt;span class=&quot;kw&quot;&gt;aes&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;x =&lt;/span&gt; lon, &lt;span class=&quot;dt&quot;&gt;y =&lt;/span&gt; lat))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/ggmap-4-1.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;잘 안 보일 수도 있지만 전 사진과 다르게 2개의 점이 추가된 것을 볼 수 있다.&lt;br /&gt;
2개의 검은 점은 각각 서초역과 강남역에 찍혔다.&lt;/p&gt;
&lt;p&gt;지도를 조금 더 확대해 볼 수도 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;p2 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;get_googlemap&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;gangnamgu&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;zoom =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt;) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;ggmap
p2&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/ggmap-5-1.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;지도의 중앙을 &amp;quot;gangnamgu&amp;quot; 즉 강남구로 설정하고 &lt;code&gt;zoom&lt;/code&gt; 인자를 12값으로 설정한 경우이다.&lt;br /&gt;
&lt;code&gt;zoom&lt;/code&gt; 인자의 디폴트 값 10 보다 큰 값을 주었으므로 조금은 확대되어 보이게 된다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;p2 +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;geom_point&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; locationInfo, &lt;span class=&quot;kw&quot;&gt;aes&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;x =&lt;/span&gt; lon, &lt;span class=&quot;dt&quot;&gt;y =&lt;/span&gt; lat))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/ggmap-6-1.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;지도를 확대하든 지도의 중심점을 옮기든 간에 서초역과 강남역에 포인팅하는 코드는 문제없이 작동한다.&lt;br /&gt;
포인팅 말고도 포인팅된 곳에 무엇이 위치해 있는지 라벨링이 되어있다면 더 보기 좋을 것이다.&lt;br /&gt;
라벨링도 ggplot2 기능 그대로 쓰던대로 쓰면 된다.&lt;br /&gt;
아래는 &lt;code&gt;geom_text()&lt;/code&gt; 를 이용해본 예이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;p2 +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;geom_point&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; locationInfo, &lt;span class=&quot;kw&quot;&gt;aes&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;x =&lt;/span&gt; lon, &lt;span class=&quot;dt&quot;&gt;y =&lt;/span&gt; lat)) +
&lt;span class=&quot;st&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;geom_text&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; locationInfo, &lt;span class=&quot;kw&quot;&gt;aes&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;label =&lt;/span&gt; Name), &lt;span class=&quot;dt&quot;&gt;size =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;vjust =&lt;/span&gt; -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/ggmap-7-1.png&quot; /&gt;
&lt;/center&gt;
&lt;h3 id=&quot;b-2-경로-그리기&quot;&gt;B-2) 경로 그리기&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;locationInfo &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;data.frame&lt;/span&gt;(
    &lt;span class=&quot;dt&quot;&gt;Name =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;강남&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;양재&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;양재시민의숲&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;청계산입구&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;판교&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;정자&amp;quot;&lt;/span&gt;), 
    &lt;span class=&quot;dt&quot;&gt;lon =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;fl&quot;&gt;127.028046&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;127.035140&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;127.038451&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;127.054769&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;127.111172&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;127.108367&lt;/span&gt;), 
    &lt;span class=&quot;dt&quot;&gt;lat =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;fl&quot;&gt;37.497001&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;37.483368&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;37.469655&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;37.448196&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;37.394786&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;37.366777&lt;/span&gt;)
)

locationInfo&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##           Name      lon      lat
## 1         강남 127.0280 37.49700
## 2         양재 127.0351 37.48337
## 3 양재시민의숲 127.0385 37.46966
## 4   청계산입구 127.0548 37.44820
## 5         판교 127.1112 37.39479
## 6         정자 127.1084 37.36678&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;신분당선을 기준으로 정자역에서 강남역까지 경로를 표현해 보고자 &lt;code&gt;locationInfo&lt;/code&gt; 내용을 바꾸었다.&lt;br /&gt;
이를 이용하여 신분당선의 대략적인 경로를 표현해 보도록 하겠다. &lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;p3 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;get_googlemap&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;gwacheon&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;zoom =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;11&lt;/span&gt;) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;ggmap
p3 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;p3 +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;geom_point&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; locationInfo, &lt;span class=&quot;kw&quot;&gt;aes&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;x =&lt;/span&gt; lon, &lt;span class=&quot;dt&quot;&gt;y =&lt;/span&gt; lat)) +
&lt;span class=&quot;st&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;geom_text&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; locationInfo, &lt;span class=&quot;kw&quot;&gt;aes&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;label =&lt;/span&gt; Name), &lt;span class=&quot;dt&quot;&gt;size =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;hjust =&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;1.2&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;fontface =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;bold&amp;quot;&lt;/span&gt;)
p3&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/ggmap-9-1.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;우선 과천시를 중심으로 두고 &lt;code&gt;zoom = 11&lt;/code&gt; 로 설정하여 지도를 뿌린 후&lt;br /&gt;
신분당선에 해당되는 역에 점을 찍고 라벨링을 더해보았다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;p3 +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;geom_path&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; locationInfo, &lt;span class=&quot;kw&quot;&gt;aes&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;x =&lt;/span&gt; lon, &lt;span class=&quot;dt&quot;&gt;y =&lt;/span&gt; lat), &lt;span class=&quot;dt&quot;&gt;color =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;blue&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;alpha =&lt;/span&gt; .&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;lwd =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/ggmap-10-1.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;그다음 경로를 표현하기 위해 각 점에 적당한 직선을 &lt;code&gt;geom_path()&lt;/code&gt; 를 통해 그리면 신분당선의 경로가 어떤지를 볼 수 있겠다.&lt;/p&gt;
&lt;h2 id=&quot;c-기타&quot;&gt;C) 기타&lt;/h2&gt;
&lt;p&gt;소개한 &lt;code&gt;get_googlemap()&lt;/code&gt;, &lt;code&gt;ggmap()&lt;/code&gt; 함수의 옵션들은 정말 방대한 편이다.&lt;br /&gt;
모든 것을 건드려 보진 못했지만 유용할 것으로 생각하는 기능 중&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;지도를 꽉 채워 출력하는 기능&lt;/li&gt;
&lt;li&gt;Map type 을 변경하는 기능&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이 눈에 띄었다.&lt;/p&gt;
&lt;h3 id=&quot;c-1-extent-device-로-지도-꽉-채워-보기&quot;&gt;C-1) &lt;code&gt;extent = &amp;quot;device&amp;quot;&lt;/code&gt; 로 지도 꽉 채워 보기&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;get_googlemap&lt;/span&gt;() %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;ggmap&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/ggmap-11-1.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;code&gt;ggmap()&lt;/code&gt; 함수를 디폴트로 사용한 결과이다.&lt;br /&gt;
지도 그림만을 출력하지 못하고 x축, y축이 함께 그려지는데 상황에 따라 불필요할 수 있다.&lt;br /&gt;
온전히 지도 그림만을 출력하고 싶다면&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;get_googlemap&lt;/span&gt;() %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;ggmap&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;extent =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;device&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/ggmap-12-1.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;code&gt;extent = &amp;quot;device&amp;quot;&lt;/code&gt; 를 이용하면 되겠다.&lt;/p&gt;
&lt;h3 id=&quot;c-2-get_googlemap-함수의-maptype-인자를-조정해-지도스타일-바꾸기&quot;&gt;C-2) &lt;code&gt;get_googlemap()&lt;/code&gt; 함수의 &lt;code&gt;maptype&lt;/code&gt; 인자를 조정해 지도스타일 바꾸기&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;get_googlemap()&lt;/code&gt; 함수의 &lt;code&gt;maptype&lt;/code&gt; 인자 값을&lt;br /&gt;
&amp;quot;terrain&amp;quot;, &amp;quot;satellite&amp;quot;, &amp;quot;roadmap&amp;quot;, &amp;quot;hybrid&amp;quot; 등으로 조절해보면&lt;/p&gt;
&lt;p&gt;&lt;em&gt;satellite 로 설정한 결과&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;p4 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;get_googlemap&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;maptype =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;satellite&amp;quot;&lt;/span&gt;) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;ggmap
p4 +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;ggtitle&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;maptype : satellite&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/ggmap-13-1.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;em&gt;terrain 로 설정한 결과&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;p5 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;get_googlemap&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;maptype =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;terrain&amp;quot;&lt;/span&gt;) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;ggmap
p5 +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;ggtitle&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;maptype : terrain&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/ggmap-14-1.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;em&gt;roadmap 로 설정한 결과&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;p6 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;get_googlemap&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;maptype =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;roadmap&amp;quot;&lt;/span&gt;) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;ggmap
p6 +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;ggtitle&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;maptype : roadmap&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/ggmap-15-1.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;em&gt;hybrid 로 설정한 결과&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;p7 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;get_googlemap&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;maptype =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;hybrid&amp;quot;&lt;/span&gt;) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;ggmap
p7 +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;ggtitle&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;maptype : hybrid&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/ggmap-16-1.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;이처럼 쓰임에 맞는 지도 스타일을 선택할 수 있다.&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://journal.r-project.org/archive/2013-1/kahle-wickham.pdf&quot;&gt;ggmap: Spatial Visualization with ggplot2 by David Kahle and Hadley Wickham&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;참고로 지금의 신분당선은 이보다 노선이 더 많아졌다.&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Tue, 18 Oct 2016 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/data_visualization/2016/10/18/ggmap.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/data_visualization/2016/10/18/ggmap.html</guid>
        
        
        <category>R</category>
        
        <category>Data_Visualization</category>
        
      </item>
    
      <item>
        <title>R에서 ggplot2 패키지를 이용한 간단한 Choropleth Map 구현하기</title>
        <description>&lt;h1 id=&quot;a-단계-구분도---choropleth-map&quot;&gt;A) 단계 구분도 - Choropleth Map&lt;/h1&gt;
&lt;p&gt;데이터 시각화를 주제로 모습을 자주 보이는 단계 구분도 (Choropleth Map)에 대해서 알아보고자 한다.&lt;br /&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Choropleth_map&quot;&gt;Choropleth map&lt;/a&gt;은 지역당 특정주제의 통계치를 활용해 시각적인 요소를 가미하여 나타낸 지도로서, 예시를 하나 들자면 국가별 인구의 밀도를 수치에 따라 색깔의 농도를 달리하여 나타내는 지도로 들 수 있다.&lt;/p&gt;
&lt;p&gt;그림으로 표현하면 다음과 같다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/choro1.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://gisutd.tistory.com/7&quot;&gt;꽤 괜찮은 데이터 지도(data map)를 그려주는 Natural Breaks란?&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이런 단계구분도를 R을 이용해 구현해 본 예제는 아래와 같다.&lt;/p&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/choro2.png&quot; /&gt;
&lt;/center&gt;
&lt;blockquote&gt;
&lt;p&gt;R Graphics Cookbook [Programming Insight] - 300page&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;b-r을-이용한-간단한-예제-실습&quot;&gt;B) R을 이용한 간단한 예제 실습&lt;/h1&gt;
&lt;p&gt;위 예제로 든 것을 실제로 만들어 보며 실습을 해보았다.&lt;br /&gt;
R의 여러 패키지의 도움을 빌렸다.&lt;br /&gt;
&amp;quot;maps&amp;quot;, &amp;quot;dplyr&amp;quot;, &amp;quot;&amp;quot;ggplot2&amp;quot; 3개의 패키지 도움을 빌리기 위해 로드한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;co&quot;&gt;# install.packages(&amp;quot;maps&amp;quot;)&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# install.packages(&amp;quot;dplyr&amp;quot;)&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# install.packages(&amp;quot;ggplot2&amp;quot;)&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;ggplot2&amp;quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;maps&amp;quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;dplyr&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&amp;quot;maps&amp;quot; 패키지에는 지도를 그리기 위한 위도, 경도 및 이에 매칭되는 나라에 대한 정보를 데이터프레임셋으로 만들 수 있도록 해주는데,&lt;br /&gt;
모든 나라의 지도정보가 담겨있으므로 Choropleth map 으로 그리고 싶은 나라를 서브세팅하여 전처리하는 것이 가능하다.&lt;br /&gt;
그래픽 엔진으로는 &amp;quot;ggplot2&amp;quot; 패키지를 선택해 Choropleth map을 구현해 볼 것이며,&lt;br /&gt;
&amp;quot;dplyr&amp;quot; 패키지는 데이터 전처리의 간편함수들을 이용하기 위함이다.&lt;/p&gt;
&lt;p&gt;바로 위에 예시로 그린 나라는 미국이다.&lt;br /&gt;
미국만을 서브세팅 하여 그리는 예제만 해보고자 한다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;map_data()&lt;/code&gt; 는 해당지도의 경도, 위도, 지역, 지역명, 지도의 다각형을 그릴 수 있게 해 주는 서브정보들이 담겨있는 데이터프레임을 반환시켜주는데 ggplot2 패키지의 함수임을 유의하며 사용했다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;states_map &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;map_data&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;state&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;map_data 의 첫 번째 인자를 &lt;code&gt;&amp;quot;state&amp;quot;&lt;/code&gt; 로 하여 미국의 주 시에 대한 정보의 데이터프레임을 &lt;code&gt;states_map&lt;/code&gt; 명칭의 객체로 저장했다.&lt;br /&gt;
참고로 &lt;code&gt;&amp;quot;state&amp;quot;&lt;/code&gt; 는 미국의 주, &lt;code&gt;&amp;quot;world&amp;quot;&lt;/code&gt; 는 전세계, &lt;code&gt;&amp;quot;france&amp;quot;&lt;/code&gt; 는 프랑스 지도 정보가 반환된다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;head&lt;/span&gt;(states_map, &lt;span class=&quot;dt&quot;&gt;n =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##         long      lat group order  region subregion
## 1  -87.46201 30.38968     1     1 alabama      &amp;lt;NA&amp;gt;
## 2  -87.48493 30.37249     1     2 alabama      &amp;lt;NA&amp;gt;
## 3  -87.52503 30.37249     1     3 alabama      &amp;lt;NA&amp;gt;
## 4  -87.53076 30.33239     1     4 alabama      &amp;lt;NA&amp;gt;
## 5  -87.57087 30.32665     1     5 alabama      &amp;lt;NA&amp;gt;
## 6  -87.58806 30.32665     1     6 alabama      &amp;lt;NA&amp;gt;
## 7  -87.59379 30.30947     1     7 alabama      &amp;lt;NA&amp;gt;
## 8  -87.59379 30.28655     1     8 alabama      &amp;lt;NA&amp;gt;
## 9  -87.67400 30.27509     1     9 alabama      &amp;lt;NA&amp;gt;
## 10 -87.81152 30.25790     1    10 alabama      &amp;lt;NA&amp;gt;
## 11 -87.88026 30.24644     1    11 alabama      &amp;lt;NA&amp;gt;
## 12 -87.92037 30.24644     1    12 alabama      &amp;lt;NA&amp;gt;
## 13 -87.95475 30.24644     1    13 alabama      &amp;lt;NA&amp;gt;
## 14 -88.00632 30.24071     1    14 alabama      &amp;lt;NA&amp;gt;
## 15 -88.01778 30.25217     1    15 alabama      &amp;lt;NA&amp;gt;
## 16 -88.01205 30.26936     1    16 alabama      &amp;lt;NA&amp;gt;
## 17 -87.99486 30.27509     1    17 alabama      &amp;lt;NA&amp;gt;
## 18 -87.95475 30.27509     1    18 alabama      &amp;lt;NA&amp;gt;
## 19 -87.90318 30.28082     1    19 alabama      &amp;lt;NA&amp;gt;
## 20 -87.82870 30.28655     1    20 alabama      &amp;lt;NA&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;데이터의 앞부분 일부를 보니,&lt;br /&gt;
&amp;quot;alabama&amp;quot; 지역의 다각형을 그리기 위한 경도(long), 위도(lat) 정보가 있는 것을 볼 수 있다.&lt;br /&gt;
물론 alabama 만 있는 것이 아니라 수많은 미국의 주 region 이 존재하는 데이터이다.&lt;br /&gt;
이를 ggplot2 패키지를 이용해 구체화 시키는 코드를 아래와 같이 작성해 보았다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;ggplot&lt;/span&gt;(states_map, &lt;span class=&quot;kw&quot;&gt;aes&lt;/span&gt;(long, lat, &lt;span class=&quot;dt&quot;&gt;group =&lt;/span&gt; group)) +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;geom_polygon&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;color =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;black&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;fill =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;gray&amp;quot;&lt;/span&gt;) +
&lt;span class=&quot;st&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;coord_map&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;polyconic&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/choro3.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;code&gt;ggplot()&lt;/code&gt; 의 첫번째 인자에는 본체 데이터를 입력하고, 두번째 인자에 &lt;code&gt;aes(x = long, y = lat)&lt;/code&gt; 을 지정하여 위도, 경도를 각각 x축과 y축에 매칭시킨다.&lt;br /&gt;
다음으로 &lt;code&gt;geom_polygon()&lt;/code&gt; 와 &lt;code&gt;coord_map()&lt;/code&gt; 함수를 통해 다각형을 그리는 명령을 넣어 구체화 시키면 ggplot2 packages를 이용한 결과물이 위와 같이 나오게 된다.&lt;/p&gt;
&lt;p&gt;그런데 위의 결과물은 단지 지도의 형태만을 볼 수 있고,&lt;br /&gt;
주시내별 어떠한 정보도 담겨있지 않은 공통된 회색이기 때문에&lt;br /&gt;
choropleth map 이라고 할 수 없는 상태이다.&lt;br /&gt;
주시내별 어떠한 정보를 담기 위하여 R의 내장데이터인 &lt;code&gt;USArrests&lt;/code&gt; 를 활용해 보았다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;head&lt;/span&gt;(USArrests)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##            Murder Assault UrbanPop Rape
## Alabama      13.2     236       58 21.2
## Alaska       10.0     263       48 44.5
## Arizona       8.1     294       80 31.0
## Arkansas      8.8     190       50 19.5
## California    9.0     276       91 40.6
## Colorado      7.9     204       78 38.7&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;USArrests&lt;/code&gt; 객체는 미국의 주시내별 폭력∙범죄율 정보를 담고 있는 data.frame 빌트인 객체이다.&lt;br /&gt;
이를 이용하여 미국의 어떠한 마을에 범죄율이 강하고 적은지를 쉽게 확인할 수 있는 choropleth map 을 만들어 보면 의미 있는 결과물이 나올 것이라 예상된다.&lt;br /&gt;
앞에서 사용했던 미국 주시내별 지도위치정보를 담은 데이터프레임셋 &lt;code&gt;states_map&lt;/code&gt; 를 다시 가지고 와서&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;states_map &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;map_data&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;state&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;region 변수와 내장데이터셋 &lt;code&gt;USArrests&lt;/code&gt; 의 region 변수를 &lt;code&gt;merge()&lt;/code&gt; 함수를 이용해 병합해 보았다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;crime_map &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;data.frame&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;region =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;tolower&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;rownames&lt;/span&gt;(USArrests)), USArrests) %&amp;gt;%
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;merge&lt;/span&gt;(states_map, &lt;span class=&quot;dt&quot;&gt;by =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;region&amp;quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;head&lt;/span&gt;(crime_map)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##    region Murder Assault UrbanPop Rape      long      lat group order
## 1 alabama   13.2     236       58 21.2 -87.46201 30.38968     1     1
## 2 alabama   13.2     236       58 21.2 -87.48493 30.37249     1     2
## 3 alabama   13.2     236       58 21.2 -87.95475 30.24644     1    13
## 4 alabama   13.2     236       58 21.2 -88.00632 30.24071     1    14
## 5 alabama   13.2     236       58 21.2 -88.01778 30.25217     1    15
## 6 alabama   13.2     236       58 21.2 -87.52503 30.37249     1     3
##   subregion
## 1      &amp;lt;NA&amp;gt;
## 2      &amp;lt;NA&amp;gt;
## 3      &amp;lt;NA&amp;gt;
## 4      &amp;lt;NA&amp;gt;
## 5      &amp;lt;NA&amp;gt;
## 6      &amp;lt;NA&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이렇게 만들어진 &lt;code&gt;crime_map&lt;/code&gt; 객체의 헤더부분을 살펴보면&lt;br /&gt;
&lt;code&gt;region&lt;/code&gt; 변수에 따른 &lt;code&gt;Murder&lt;/code&gt;, &lt;code&gt;Assault&lt;/code&gt;, &lt;code&gt;UrbanPop&lt;/code&gt;, &lt;code&gt;Rape&lt;/code&gt; 변수정보들이 붙여진 것을 확인할 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;arrange&lt;/span&gt;(crime_map, order) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;ggplot&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;aes&lt;/span&gt;(long, lat, &lt;span class=&quot;dt&quot;&gt;group =&lt;/span&gt; group, &lt;span class=&quot;dt&quot;&gt;fill =&lt;/span&gt; Murder)) +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;geom_polygon&lt;/span&gt;() +
&lt;span class=&quot;st&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;coord_map&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;polyconic&amp;quot;&lt;/span&gt;) +
&lt;span class=&quot;st&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;scale_fill_continuous&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;low =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;pink&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;high =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;black&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/choro4.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;code&gt;arrange()&lt;/code&gt; 를 이용하여 order 변수 순으로 정렬을 해주었는데,&lt;br /&gt;
정렬을 시키는 이유는 올바른 다각형을 그리기 위함이다.&lt;br /&gt;
병합작업 시 원래 순서대로 정렬되어있던 것이 헝클어졌기 때문에 필요한 전처리 작업이다.&lt;br /&gt;
(정렬작업을 하지 않는다면 도저히 무슨 그림인지 알 수 없는 결과물이 나온다)&lt;/p&gt;
&lt;p&gt;이후 &lt;code&gt;ggplot()&lt;/code&gt; 에 &lt;code&gt;fill&lt;/code&gt; 인자를 &lt;code&gt;Murder&lt;/code&gt; 변수로 지정하여 미국의 주시내별 살인범죄수에 따라 색깔의 농도가 진해지는 결과물을 출력하면 되겠다.&lt;br /&gt;
위의 결과물과 맨 첫 번째 소개했던 결과물이 같은 것을 확인할 수 있다.&lt;/p&gt;
</description>
        <pubDate>Fri, 14 Oct 2016 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/data_visualization/2016/10/14/Choropleth_map_basic.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/data_visualization/2016/10/14/Choropleth_map_basic.html</guid>
        
        
        <category>R</category>
        
        <category>Data_Visualization</category>
        
      </item>
    
      <item>
        <title>R에서 lubridate package 에 대해</title>
        <description>&lt;br&gt;&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/lubridate.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cran.r-project.org/web/packages/lubridate/lubridate.pdf&quot;&gt;lubridate package&lt;/a&gt; 는 Garrett Grolemund 와 Hadley Wickham 외 8명의 힘이 더해져 만들어진 날짜처리 생산성 패키지이다.&lt;/p&gt;
&lt;p&gt;날짜(Date) &amp;amp; 시각(Time) 데이터는 전 세계 사람들에 의해 보편적으로 정해진 규칙이 있는데, 이 규칙을 정확하게 알지 못하고 데이터를 처리할 때 혼돈이 일어날 수 있다.&lt;br /&gt;
의외로 위에서 말한 규칙들은 따지고 보면 따져볼수록 많고 복잡하여 인간이 실수할 수 있을 여지가 높다.&lt;br /&gt;
흠 이런 예제랄까?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;어느 연도가 윤년이어서 2월 29일이 있는지 없는지 신경 쓰지 않으면 알 수 없다.&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;4월 31일 데이터셋 정의 (그런 날짜는 존재하지 않는데도 불구하고)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이런 것 외에도 우리가 접할 수 있는 여러 가지 상황을 가정 해 볼 수 있는데&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;분석 시 기준 Timezone 이 변경될 경우&lt;/li&gt;
&lt;li&gt;날짜와 시각이 조합된 데이터의 산술연산이 필요할 경우&lt;/li&gt;
&lt;li&gt;(정말 특이한 사례지만) &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%9D%BC%EA%B4%91_%EC%A0%88%EC%95%BD_%EC%8B%9C%EA%B0%84%EC%A0%9C&quot;&gt;일광절약시간제&lt;/a&gt;에 해당되는 Time index 가 존재할 경우&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;등등 날짜시각 데이터셋에 대한 처리 시 우리를 괴롭힐 만한 요소들은 차고 넘친다.&lt;/p&gt;
&lt;p&gt;이 실수들과 장애물들을 사전에 방지하기 위한 다양한 R 패키지가 제공되고 있다.&lt;br /&gt;
내가 아는 것을 기준으론 &lt;a href=&quot;https://cran.r-project.org/web/packages/xts/xts.pdf&quot;&gt;xts&lt;/a&gt;, &lt;a href=&quot;https://cran.r-project.org/web/packages/zoo/zoo.pdf&quot;&gt;zoo&lt;/a&gt;, lubridate, &lt;a href=&quot;https://cran.r-project.org/web/packages/chron/chron.pdf&quot;&gt;chron&lt;/a&gt; 의 패키지 정도를 알고 있으되, 자주 사용하는 패키지는 xts 이었다.&lt;/p&gt;
&lt;p&gt;이번에 살펴볼 &lt;a href=&quot;https://cran.r-project.org/web/packages/lubridate/lubridate.pdf&quot;&gt;lubridate package&lt;/a&gt; 는 lubricate(기름을 치다, 기름을 바르다, 원활히 하다) 의 &amp;quot;lubri&amp;quot; 와 &amp;quot;date&amp;quot; 를 합성시킨 것으로 추측되는데 이처럼 날짜시각 데이터를 원활하게 가공하는 데 도움을 주기 위한 목적으로 특화된 느낌을 받는다.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;span class=&quot;math display&quot;&gt;&lt;em&gt;l&lt;/em&gt;&lt;em&gt;u&lt;/em&gt;&lt;em&gt;b&lt;/em&gt;&lt;em&gt;r&lt;/em&gt;&lt;em&gt;i&lt;/em&gt; + &lt;em&gt;d&lt;/em&gt;&lt;em&gt;a&lt;/em&gt;&lt;em&gt;t&lt;/em&gt;&lt;em&gt;e&lt;/em&gt;&lt;/span&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;xts, zoo 패키지 조합 역시 강력하지만 강력한 만큼 친숙함은 주지 못한 것 같다.&lt;br /&gt;
이러한 단점을 보완하고자 부가적으로 알아야 하겠다고 마음먹게 된 패키지 중 하나이었고,&lt;br /&gt;
R studio 의 Hadley Wickham 에 의해 유지보수 되고 있다고 해서 그 때문에 공부를 시작하기도 한 것 같다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Lubridate is an R package that makes it easier to work with dates and times.&lt;br /&gt;
- &lt;a href=&quot;https://cran.r-project.org/web/packages/lubridate/vignettes/lubridate.html&quot;&gt;Do more with dates and times in R with lubridate 1.3.0&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;얼마나 기존방법보다 쉬운지를 내가 겪었던 시행착오와 곁들여&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(lubridate)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;를 실행 후 한 번 탐색해 보겠다.&lt;/p&gt;
&lt;h2 id=&quot;a-dates-times-객체-만들기&quot;&gt;A) dates &amp;amp; times 객체 만들기&lt;/h2&gt;
&lt;h3 id=&quot;a-1-date-객체-만들기&quot;&gt;A-1) Date 객체 만들기&lt;/h3&gt;
&lt;p&gt;R에서 2011년 6월 4일 날짜 데이터를 만들려면 가장 기본적인 방법이 아래의 코드일 것이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;as.Date&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;2011-06-04&amp;quot;&lt;/span&gt;)
## [1] &amp;quot;2011-06-04&amp;quot;
&lt;span class=&quot;kw&quot;&gt;as.Date&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;2011-6-4&amp;quot;&lt;/span&gt;)
## [1] &amp;quot;2011-06-04&amp;quot;
&lt;span class=&quot;kw&quot;&gt;as.Date&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;2011/06/04&amp;quot;&lt;/span&gt;)
## [1] &amp;quot;2011-06-04&amp;quot;
## 
## as.Date(&amp;quot;20110604&amp;quot;) # error&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;R의 가장 전통적인 날짜 데이터 class 는 Date 일 것이다.&lt;br /&gt;
마지막 코드 &lt;code&gt;as.Date(&amp;quot;20110604&amp;quot;)&lt;/code&gt; 와 같이 에러가 나는 코드도 한번 작성해 보았는데&lt;br /&gt;
이처럼 날짜 데이터셋을 만들기 위해 문자열을 input 하는 방식으로 사용할 경우 문자열을 어떠한 양식에 따라 작성할 것인지도 사람마다 제각각이고 그에 따라 코드가 실행되지 않는 경우가 발생할 것이다.&lt;br /&gt;
그 양식 중 &lt;code&gt;&amp;quot;20110604&amp;quot;&lt;/code&gt; 와 같이 딜리미터가 없는 문자열은 &lt;code&gt;as.Date()&lt;/code&gt; 가 날짜로 변환할 때&lt;br /&gt;
어디가 year 이고 month 이며 day 인지 알 수 없어한다.&lt;/p&gt;
&lt;p&gt;또한&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;as.Date&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;06-04-2011&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;0006-04-20&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;처럼 미국식 날짜 표기법을 사용할 경우에도 마찬가지 문제가 발생한다.&lt;/p&gt;
&lt;p&gt;이번엔 lubridate package 의 &amp;quot;y&amp;quot;, &amp;quot;m&amp;quot;, &amp;quot;d&amp;quot; 심볼을 이용한 함수들을 이용해 보겠다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;ymd&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;2011/06/04&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;2011-06-04&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;quot;y&amp;quot;, &amp;quot;m&amp;quot;, &amp;quot;d&amp;quot; 심볼이라고 소개했는데 각각 year, month, day 로 이해할 수 있고&lt;br /&gt;
이 심볼의 순서를 바꾸어도 먹히는 함수들이 사전에 준비되어 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;mdy&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;06/04/2011&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;2011-06-04&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;quot;06/04/2011&amp;quot; 은 2011년 6월 4일을 미국식으로 날짜 표기한 것인데, 이를 제대로 인식하기 위해서 심볼들의 순서를 그에 맞춘 함수를 이용하면 되겠다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;dmy&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;04/06/2011&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;2011-06-04&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;문자열 양식에는 어느정도의 관용이 있는지 살펴보았다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;ymd&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;2011/06/04&amp;quot;&lt;/span&gt;)
## [1] &amp;quot;2011-06-04&amp;quot;
&lt;span class=&quot;kw&quot;&gt;ymd&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;2011-06-04&amp;quot;&lt;/span&gt;)
## [1] &amp;quot;2011-06-04&amp;quot;
&lt;span class=&quot;kw&quot;&gt;ymd&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;20110604&amp;quot;&lt;/span&gt;)
## [1] &amp;quot;2011-06-04&amp;quot;
&lt;span class=&quot;kw&quot;&gt;ymd&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;110604&amp;quot;&lt;/span&gt;)
## [1] &amp;quot;2011-06-04&amp;quot;
&lt;span class=&quot;kw&quot;&gt;ymd&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;11.06.04&amp;quot;&lt;/span&gt;)
## [1] &amp;quot;2011-06-04&amp;quot;
&lt;span class=&quot;kw&quot;&gt;ymd&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;11,06,04&amp;quot;&lt;/span&gt;)
## [1] &amp;quot;2011-06-04&amp;quot;
&lt;span class=&quot;kw&quot;&gt;ymd&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;11_06.04&amp;quot;&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# ?&lt;/span&gt;
## [1] &amp;quot;2011-06-04&amp;quot;
&lt;span class=&quot;kw&quot;&gt;ymd&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;2011  06  04&amp;quot;&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# ㅋㅋ?&lt;/span&gt;
## [1] &amp;quot;2011-06-04&amp;quot;
&lt;span class=&quot;kw&quot;&gt;ymd&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;2011!?06??!04&amp;quot;&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# !?&lt;/span&gt;
## [1] &amp;quot;2011-06-04&amp;quot;
&lt;span class=&quot;kw&quot;&gt;ymd&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;2011 =06??04&amp;quot;&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# -_-?&lt;/span&gt;
## [1] &amp;quot;2011-06-04&amp;quot;
&lt;span class=&quot;kw&quot;&gt;ymd&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;11 No 06 way 04&amp;quot;&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# No way!&lt;/span&gt;
## [1] &amp;quot;2011-06-04&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;lubridate package 설명서에는&lt;br /&gt;
&lt;strong&gt;heterogeneous format(불균일한 양식)&lt;/strong&gt;에 대한 다양한 준비들이 되어있음을 강조한 문구가 담겨 있는 걸 보았다.&lt;br /&gt;
이처럼 인간의 실수는 웬만하면 커버할 듯한 위용이다.&lt;/p&gt;
&lt;h3 id=&quot;a-2-dates-times-객체-만들기&quot;&gt;A-2) Dates + Times 객체 만들기&lt;/h3&gt;
&lt;p&gt;&amp;quot;2011년 6월 4일&amp;quot; 에 구체적인 시각까지 더해서&lt;br /&gt;
&amp;quot;2011년 6월 4일 13시 30분 50초&amp;quot; 를 R에서 만들어 보겠다.&lt;/p&gt;
&lt;p&gt;시각까지 더해진 정보는 Date class 로 정보를 담을 수 없다.&lt;br /&gt;
즉 &lt;code&gt;as.Date()&lt;/code&gt; 함수로 2011년 6월 4일 13시 30분 50초 정보를 만들 수 없다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;as.Date&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;2011-06-04 13:30:50&amp;quot;&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# 시각정보가 사라짐&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;2011-06-04&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이때부턴 포직스(POSIX) 클래스를 대중적으로 이용하는것으로 알고 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;as.POSIXct&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;2011-06-04 13:30:50&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;2011-06-04 13:30:50 KST&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이번엔 lubridate package 의 경우이다.&lt;br /&gt;
lubridate package 에는 &amp;quot;y&amp;quot;, &amp;quot;m&amp;quot;, &amp;quot;d&amp;quot; 심볼 뿐만 아니라 &amp;quot;h&amp;quot;, &amp;quot;m&amp;quot;, &amp;quot;s&amp;quot; 역시 준비되어 있다.&lt;br /&gt;
각각 hour, minute, second 로 이해할 수 있다.&lt;br /&gt;
위의 설명했던 대로 &amp;quot;y&amp;quot;, &amp;quot;m&amp;quot;, &amp;quot;d&amp;quot; 와 &amp;quot;h&amp;quot;, &amp;quot;m&amp;quot;, &amp;quot;s&amp;quot; 를 잘 조합하여 사용하면&lt;br /&gt;
비교적 편하게 &amp;quot;2011년 6월 4일 13시 30분 50초&amp;quot; 정보를 담을 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;ymd_hms&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;2011-06-04 13:30:50&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;2011-06-04 13:30:50 UTC&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;as.POSIXct()&lt;/code&gt; 와 비교해볼 때 날짜시각 객체를 만드는 방법이 별반 틀릴 것이 없다.&lt;br /&gt;
하지만 조금 더 융통성이 있게 사용할 수 있는 점들이 몇 가지 눈에 띈다.&lt;/p&gt;
&lt;p&gt;만약 분, 초 단위의 정보가 없는 경우 &amp;quot;2011년 6월 4일 13시&amp;quot; 의 정보가 투입된다고 가정하면 어떨까?&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;ymd_h&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;2011-06-04 13&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;2011-06-04 13:00:00 UTC&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ymd_hms()&lt;/code&gt; 에서 &amp;quot;m&amp;quot;, &amp;quot;s&amp;quot; 심볼을 제외한 &lt;code&gt;ymd_h()&lt;/code&gt; 함수를 이용해 파싱하면 된다.&lt;br /&gt;
하지만 &lt;code&gt;as.POSIXct()&lt;/code&gt; 으로 &lt;code&gt;&amp;quot;2011-06-04 13&amp;quot;&lt;/code&gt; 를 파싱하는 방법은 조금 고민을 해야하거나 투입되는 문자열 자체를 사전에 건드려야 하는 과정이 필요하다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;as.POSIXct&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;2011-06-04 13&amp;quot;&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# No&lt;/span&gt;
## [1] &amp;quot;2011-06-04 KST&amp;quot;
&lt;span class=&quot;kw&quot;&gt;as.POSIXct&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;2011-06-04 13:00:00&amp;quot;&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# Yes&lt;/span&gt;
## [1] &amp;quot;2011-06-04 13:00:00 KST&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이런 예시로 볼 때 lubridate package 는 사용자 관점으로 친숙한 도구들이 여럿 준비되어 있다.&lt;br /&gt;
이외에도 heterogeneous format 에 대한 대비 역시 날짜 + 시각 데이터에도 적용된다.&lt;/p&gt;
&lt;h2 id=&quot;b-부분정보-추출-extracting-information&quot;&gt;B) 부분정보 추출 (Extracting information)&lt;/h2&gt;
&lt;p&gt;lubridate package 에는 부분정보를 추출하기 위한 간편 함수들이 여럿 준비되어 있다.&lt;br /&gt;
&lt;code&gt;second()&lt;/code&gt;, &lt;code&gt;minute()&lt;/code&gt;, &lt;code&gt;hour()&lt;/code&gt;, &lt;code&gt;day()&lt;/code&gt;, &lt;code&gt;wday()&lt;/code&gt;, &lt;code&gt;yday()&lt;/code&gt;, &lt;code&gt;week()&lt;/code&gt;, &lt;code&gt;month()&lt;/code&gt;, &lt;code&gt;year()&lt;/code&gt; 처럼 함수명칭도 상식적으로 이해하기 쉬운 것들이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;ld1 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;ymd_hms&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;2011-06-04 13:30:50&amp;quot;&lt;/span&gt;)

&lt;span class=&quot;kw&quot;&gt;year&lt;/span&gt;(ld1)
## [1] 2011
&lt;span class=&quot;kw&quot;&gt;month&lt;/span&gt;(ld1)
## [1] 6
&lt;span class=&quot;kw&quot;&gt;day&lt;/span&gt;(ld1)
## [1] 4
&lt;span class=&quot;kw&quot;&gt;wday&lt;/span&gt;(ld1)
## [1] 7
&lt;span class=&quot;kw&quot;&gt;yday&lt;/span&gt;(ld1)
## [1] 155
&lt;span class=&quot;kw&quot;&gt;hour&lt;/span&gt;(ld1)
## [1] 13
&lt;span class=&quot;kw&quot;&gt;minute&lt;/span&gt;(ld1)
## [1] 30
&lt;span class=&quot;kw&quot;&gt;second&lt;/span&gt;(ld1)
## [1] 50&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;특히 month, wday 의 경우 &lt;code&gt;label&lt;/code&gt; 인자를 가지고 있는데 이를 &lt;code&gt;TRUE&lt;/code&gt; 로 설정할 경우에&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;month&lt;/span&gt;(ld1, &lt;span class=&quot;dt&quot;&gt;label =&lt;/span&gt; T)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] Jun
## 12 Levels: Jan &amp;lt; Feb &amp;lt; Mar &amp;lt; Apr &amp;lt; May &amp;lt; Jun &amp;lt; Jul &amp;lt; Aug &amp;lt; Sep &amp;lt; ... &amp;lt; Dec&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;wday&lt;/span&gt;(ld1, &lt;span class=&quot;dt&quot;&gt;label =&lt;/span&gt; T)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] Sat
## Levels: Sun &amp;lt; Mon &amp;lt; Tues &amp;lt; Wed &amp;lt; Thurs &amp;lt; Fri &amp;lt; Sat&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;월, 요일의 명칭을 factor 로 볼 수 있다.&lt;/p&gt;
&lt;h3 id=&quot;b-1-부분정보-수정&quot;&gt;B-1) 부분정보 수정&lt;/h3&gt;
&lt;p&gt;&amp;quot;2011년 6월 4일 13:30:50&amp;quot; 로 저장되어있던 &lt;code&gt;ld1&lt;/code&gt; 에 대해 시각(hour)을 10시로 바꾸려면 어떻게 하여야 할까?&lt;br /&gt;
내가볼 때 가장 간단한 방법은 부분정보 추출시 사용했던 간편함수들과 assign 연산자를 조합시켜 변경하는 방법이다.&lt;br /&gt;
아래처럼 사용하면 된다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;hour&lt;/span&gt;(ld1) &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;
ld1&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;2011-06-04 10:30:50 UTC&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;update()&lt;/code&gt; 제너릭 함수를 사용할 수도 있는데, 엄밀히 말하면 &lt;code&gt;update.POSIXt()&lt;/code&gt; 를 이용하는 방법다.&lt;br /&gt;
아래 코드는 &lt;code&gt;update()&lt;/code&gt; 함수를 이용해 10시로 변경된 &lt;code&gt;ld1&lt;/code&gt; 을 다시 13로 되돌리는 코드이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;ld1 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;update&lt;/span&gt;(ld1, &lt;span class=&quot;dt&quot;&gt;hour =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;13&lt;/span&gt;)
ld1&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;2011-06-04 13:30:50 UTC&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;POSIXlt class 인 경우엔 &lt;code&gt;$&lt;/code&gt; 와 assign operator 를 조합해 사용할 수 있는데 이 또한 매력적인 방법이라 생각된다.&lt;br /&gt;
하지만 아쉽게도 &lt;code&gt;ld1&lt;/code&gt; 는 POSIXct class 이므로 &lt;code&gt;$&lt;/code&gt; 가 바로 먹히지는 않는다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;ld1$hour &lt;span class=&quot;co&quot;&gt;# error&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;굳이 &lt;code&gt;$&lt;/code&gt; 과 assign operator 를 조합해 사용하고 싶다면 &lt;code&gt;as.POSIXlt()&lt;/code&gt; 를 한번 거쳐야 할 것이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;ld2 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;as.POSIXlt&lt;/span&gt;(ld1)
ld2$hour &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;
ld2&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;2011-06-04 10:30:50 UTC&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;c-날짜시각에-대한-산술연산&quot;&gt;C) 날짜시각에 대한 산술연산&lt;/h2&gt;
&lt;p&gt;lubridate 와 같은 패키지를 공부하는 목적 중 가장 중요한 특징이 아닐까 싶다.&lt;br /&gt;
날짜 + 시각에 대한 산술연산은 매우 민감하고도, 생각보다 짜증 나는 문제이다.&lt;/p&gt;
&lt;p&gt;사과 30개가 있는데, 사과 2개를 더하면 32개가 된다.&lt;br /&gt;
1월 30일인데, 2틀을 더하면(지나면) 32일이 될까?&lt;br /&gt;
개인적으론 32일이 되어버렸으면 좋겠지만 32일이란 건 존재하지 않는다. 2월 1일이 된다.&lt;/p&gt;
&lt;p&gt;나처럼 단순무식한 것을 좋아하는 사람에겐 날짜 + 시각에 대한 산술연산은 많은 피로도를 줄 수 있다.&lt;br /&gt;
lubridate package 는 이를 예방할 수 있는 강력한 함수들이 많이 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;ymd&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;2016-01-30&amp;quot;&lt;/span&gt;) +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;days&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;2016-02-01&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위의 코드는 1월 30일인데, 2틀을 더하면(지나면)&lt;br /&gt;
의 문제를 풀어주는 코드이다.&lt;/p&gt;
&lt;p&gt;특정기간이 지나면 무슨일이 되는지 이렇게 산술연산이 가능하다.&lt;/p&gt;
&lt;p&gt;지금까지 단일시점 한개의 날짜시각 데이터를 가지고 놀았는데&lt;br /&gt;
이런 식으로 R의 Vectorization 특징을 활용하여 복수개의 시점을 만들 수도 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;ymd&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;2016-01-30&amp;quot;&lt;/span&gt;) -&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;days&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;2016-01-29&amp;quot; &amp;quot;2016-01-28&amp;quot; &amp;quot;2016-01-27&amp;quot; &amp;quot;2016-01-26&amp;quot; &amp;quot;2016-01-25&amp;quot;
##  [6] &amp;quot;2016-01-24&amp;quot; &amp;quot;2016-01-23&amp;quot; &amp;quot;2016-01-22&amp;quot; &amp;quot;2016-01-21&amp;quot; &amp;quot;2016-01-20&amp;quot;
## [11] &amp;quot;2016-01-19&amp;quot; &amp;quot;2016-01-18&amp;quot; &amp;quot;2016-01-17&amp;quot; &amp;quot;2016-01-16&amp;quot; &amp;quot;2016-01-15&amp;quot;
## [16] &amp;quot;2016-01-14&amp;quot; &amp;quot;2016-01-13&amp;quot; &amp;quot;2016-01-12&amp;quot; &amp;quot;2016-01-11&amp;quot; &amp;quot;2016-01-10&amp;quot;
## [21] &amp;quot;2016-01-09&amp;quot; &amp;quot;2016-01-08&amp;quot; &amp;quot;2016-01-07&amp;quot; &amp;quot;2016-01-06&amp;quot; &amp;quot;2016-01-05&amp;quot;
## [26] &amp;quot;2016-01-04&amp;quot; &amp;quot;2016-01-03&amp;quot; &amp;quot;2016-01-02&amp;quot; &amp;quot;2016-01-01&amp;quot; &amp;quot;2015-12-31&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;잠깐 &lt;code&gt;days()&lt;/code&gt; 함수명칭을 살펴보자.&lt;br /&gt;
위에서 부분정보 추출 간편함수중 &lt;code&gt;day()&lt;/code&gt; 가 있었는데 마지막에 &amp;quot;s&amp;quot; 가 붙음으로써 쓰임이 달라진 것을 볼 수 있다.&lt;br /&gt;
&lt;code&gt;days()&lt;/code&gt; 뿐만 아니라 &lt;code&gt;seconds()&lt;/code&gt;, &lt;code&gt;minutes()&lt;/code&gt;, &lt;code&gt;hours()&lt;/code&gt;, &lt;code&gt;weeks()&lt;/code&gt;, &lt;code&gt;years()&lt;/code&gt;, &lt;code&gt;milliseconds()&lt;/code&gt;, &lt;code&gt;microseconds()&lt;/code&gt;, &lt;code&gt;nanoseconds()&lt;/code&gt;, &lt;code&gt;picoseconds()&lt;/code&gt; 의 함수들이 이와 같은 산술연산에서 사용할 수 있는 패밀리이다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cran.r-project.org/web/packages/lubridate/vignettes/lubridate.html&quot;&gt;Do more with dates and times in R with lubridate 1.3.0&lt;/a&gt; 에서 꽤 감명깊은(?) 예제를 발견했는데&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;ymd&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;2013-01-31&amp;quot;&lt;/span&gt;) +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;months&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;11&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;2013-01-31&amp;quot; NA           &amp;quot;2013-03-31&amp;quot; NA           &amp;quot;2013-05-31&amp;quot;
##  [6] NA           &amp;quot;2013-07-31&amp;quot; &amp;quot;2013-08-31&amp;quot; NA           &amp;quot;2013-10-31&amp;quot;
## [11] NA           &amp;quot;2013-12-31&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위 결과를 통해&lt;br /&gt;
월 중에 31일이 존재하지 않는 월이 어디인지를 알 수 있게 된다.&lt;/p&gt;
&lt;h2 id=&quot;d-lubridate-와-dplyr-간의-조합&quot;&gt;D) lubridate 와 dplyr 간의 조합&lt;/h2&gt;
&lt;p&gt;lubridate 이든 xts 이든 간에&lt;br /&gt;
결국은 이러한 Time index 정보들이 담긴 Table 형태에 정보들을 가공하고 처리하게 될 가능성이 매우 높다.&lt;br /&gt;
dplyr package 와 조합해 현업에서 어떻게 시너지를 일으킬 지를&lt;br /&gt;
보잘것없는 예제를 통해 조금이나마 확인해 보고 싶다.&lt;br /&gt;
lubridate package 에 내장된 데이터셋 &lt;code&gt;lakers&lt;/code&gt; 를 이용해 보았다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(dplyr)
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt;(lakers)

lakers &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;lakers %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;tbl_df
lakers&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 34,624 &amp;lt;U+00D7&amp;gt; 13
##        date opponent game_type  time period      etype  team
##       &amp;lt;int&amp;gt;    &amp;lt;chr&amp;gt;     &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;  &amp;lt;int&amp;gt;      &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;
## 1  20081028      POR      home 12:00      1  jump ball   OFF
## 2  20081028      POR      home 11:39      1       shot   LAL
## 3  20081028      POR      home 11:37      1    rebound   LAL
## 4  20081028      POR      home 11:25      1       shot   LAL
## 5  20081028      POR      home 11:23      1    rebound   LAL
## 6  20081028      POR      home 11:22      1       shot   LAL
## 7  20081028      POR      home 11:22      1       foul   POR
## 8  20081028      POR      home 11:22      1 free throw   LAL
## 9  20081028      POR      home 11:00      1       foul   LAL
## 10 20081028      POR      home 10:53      1       shot   POR
## # ... with 34,614 more rows, and 6 more variables: player &amp;lt;chr&amp;gt;,
## #   result &amp;lt;chr&amp;gt;, points &amp;lt;int&amp;gt;, type &amp;lt;chr&amp;gt;, x &amp;lt;int&amp;gt;, y &amp;lt;int&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;잘 보면 &lt;code&gt;date&lt;/code&gt;, &lt;code&gt;time&lt;/code&gt; 변수가 서로 나뉘어 있다.&lt;br /&gt;
이를 지금까지 배운 lubridate 함수들을 이용하여 통합시켜 관리해보고 싶었다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;lakers &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;lakers %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;mutate&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;date =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;paste&lt;/span&gt;(date, time) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;ymd_hm) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;rename&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;time_index =&lt;/span&gt; date) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt;(-time)

lakers&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 34,624 &amp;lt;U+00D7&amp;gt; 12
##             time_index opponent game_type period      etype  team
##                 &amp;lt;dttm&amp;gt;    &amp;lt;chr&amp;gt;     &amp;lt;chr&amp;gt;  &amp;lt;int&amp;gt;      &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;
## 1  2008-10-28 12:00:00      POR      home      1  jump ball   OFF
## 2  2008-10-28 11:39:00      POR      home      1       shot   LAL
## 3  2008-10-28 11:37:00      POR      home      1    rebound   LAL
## 4  2008-10-28 11:25:00      POR      home      1       shot   LAL
## 5  2008-10-28 11:23:00      POR      home      1    rebound   LAL
## 6  2008-10-28 11:22:00      POR      home      1       shot   LAL
## 7  2008-10-28 11:22:00      POR      home      1       foul   POR
## 8  2008-10-28 11:22:00      POR      home      1 free throw   LAL
## 9  2008-10-28 11:00:00      POR      home      1       foul   LAL
## 10 2008-10-28 10:53:00      POR      home      1       shot   POR
## # ... with 34,614 more rows, and 6 more variables: player &amp;lt;chr&amp;gt;,
## #   result &amp;lt;chr&amp;gt;, points &amp;lt;int&amp;gt;, type &amp;lt;chr&amp;gt;, x &amp;lt;int&amp;gt;, y &amp;lt;int&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위의 코드를 설명하면&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;code&gt;date&lt;/code&gt;, &lt;code&gt;time&lt;/code&gt; 두변수를 붙인 문자열에 대해 &lt;code&gt;ymd_hm()&lt;/code&gt; 함수로 넘긴 후&lt;/li&gt;
&lt;li&gt;&lt;code&gt;time_index&lt;/code&gt; 라는 변수에 담고,&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;date&lt;/code&gt;, &lt;code&gt;time&lt;/code&gt; 두 변수를 제외한 것이다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이렇게 알맞게 변형된 &lt;code&gt;lakers&lt;/code&gt; 를 이용해 좀 더 의미가 있을만한 탐색을 해보겠다.&lt;/p&gt;
&lt;h3 id=&quot;d-1-group-by-연산&quot;&gt;D-1) Group by 연산&lt;/h3&gt;
&lt;p&gt;첫번째는 Group by 연산이다.&lt;br /&gt;
월별 평균을 &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; 변수에 대해서 계산해보겠다.&lt;br /&gt;
이때 우리가 알고있는 &lt;code&gt;month()&lt;/code&gt; 함수를 이용하면 아주 간편하게 할 수 있겠다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;lakers %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;group_by&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;month&lt;/span&gt;(time_index)) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;summarize&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;mean_x =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;mean&lt;/span&gt;(x, &lt;span class=&quot;dt&quot;&gt;na.rm =&lt;/span&gt; T), &lt;span class=&quot;dt&quot;&gt;mean_y =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;mean&lt;/span&gt;(y, &lt;span class=&quot;dt&quot;&gt;na.rm =&lt;/span&gt; T))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 7 &amp;lt;U+00D7&amp;gt; 3
##   `month(time_index)`   mean_x   mean_y
##                 &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;
## 1                   1 25.49382 13.89279
## 2                   2 25.01759 13.17499
## 3                   3 25.51587 13.20571
## 4                   4 25.38344 13.46396
## 5                  10 24.92188 13.12500
## 6                  11 25.47463 13.36926
## 7                  12 25.05895 13.48262&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;연별 평균을 계산하고 싶다면 &lt;code&gt;year()&lt;/code&gt; 이용하면 된다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;lakers %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;group_by&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;year&lt;/span&gt;(time_index)) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;summarize&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;mean_x =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;mean&lt;/span&gt;(x, &lt;span class=&quot;dt&quot;&gt;na.rm =&lt;/span&gt; T), &lt;span class=&quot;dt&quot;&gt;mean_y =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;mean&lt;/span&gt;(y, &lt;span class=&quot;dt&quot;&gt;na.rm =&lt;/span&gt; T))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 2 &amp;lt;U+00D7&amp;gt; 3
##   `year(time_index)`   mean_x   mean_y
##                &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;
## 1               2008 25.23402 13.40776
## 2               2009 25.36407 13.44319&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;d-2-filter&quot;&gt;D-2) Filter&lt;/h3&gt;
&lt;p&gt;두번째는 &lt;code&gt;filter()&lt;/code&gt; 를 이용해 분석에 사용할 기간을 서브세팅 해보는 예제를 만들어 보고 싶었다.&lt;br /&gt;
아래 코드는 &amp;quot;2008-10-28 12:00:00&amp;quot; 이전의 기간을 서브세팅 하는 코드이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;lakers %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;filter&lt;/span&gt;(time_index &amp;lt;=&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;ymd_hms&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;2008-10-28 12:00:00&amp;quot;&lt;/span&gt;))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 416 &amp;lt;U+00D7&amp;gt; 12
##             time_index opponent game_type period      etype  team
##                 &amp;lt;dttm&amp;gt;    &amp;lt;chr&amp;gt;     &amp;lt;chr&amp;gt;  &amp;lt;int&amp;gt;      &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;
## 1  2008-10-28 12:00:00      POR      home      1  jump ball   OFF
## 2  2008-10-28 11:39:00      POR      home      1       shot   LAL
## 3  2008-10-28 11:37:00      POR      home      1    rebound   LAL
## 4  2008-10-28 11:25:00      POR      home      1       shot   LAL
## 5  2008-10-28 11:23:00      POR      home      1    rebound   LAL
## 6  2008-10-28 11:22:00      POR      home      1       shot   LAL
## 7  2008-10-28 11:22:00      POR      home      1       foul   POR
## 8  2008-10-28 11:22:00      POR      home      1 free throw   LAL
## 9  2008-10-28 11:00:00      POR      home      1       foul   LAL
## 10 2008-10-28 10:53:00      POR      home      1       shot   POR
## # ... with 406 more rows, and 6 more variables: player &amp;lt;chr&amp;gt;,
## #   result &amp;lt;chr&amp;gt;, points &amp;lt;int&amp;gt;, type &amp;lt;chr&amp;gt;, x &amp;lt;int&amp;gt;, y &amp;lt;int&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;잘 보면 기존에 레코드는 34624 개 였지만, 서브세팅 된 후 레코드는 416 개로 줄어든 것을 확인할 수 있다.&lt;/p&gt;
&lt;p&gt;만약 &amp;quot;2008-10-28 12:00:00&amp;quot; ~ &amp;quot;2009-03-09 00:33:00&amp;quot; 의 기간에 대해서 서브세팅을 하고싶다면 어떻게 하여야 할까?&lt;br /&gt;
물론 &lt;code&gt;filter()&lt;/code&gt; 안에 조건을 하나 더 넣으면 된다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;lakers %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;filter&lt;/span&gt;(time_index &amp;gt;=&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;ymd_hms&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;2008-10-28 12:00:00&amp;quot;&lt;/span&gt;), time_index &amp;lt;=&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;ymd_hms&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;2009-03-09 00:33:00&amp;quot;&lt;/span&gt;))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 25,554 &amp;lt;U+00D7&amp;gt; 12
##             time_index opponent game_type period     etype  team
##                 &amp;lt;dttm&amp;gt;    &amp;lt;chr&amp;gt;     &amp;lt;chr&amp;gt;  &amp;lt;int&amp;gt;     &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;
## 1  2008-10-28 12:00:00      POR      home      1 jump ball   OFF
## 2  2008-10-29 12:00:00      LAC      away      1 jump ball   OFF
## 3  2008-10-29 11:36:00      LAC      away      1      shot   LAL
## 4  2008-10-29 11:24:00      LAC      away      1      shot   LAC
## 5  2008-10-29 11:24:00      LAC      away      1   rebound   LAL
## 6  2008-10-29 11:08:00      LAC      away      1      shot   LAL
## 7  2008-10-29 10:58:00      LAC      away      1      shot   LAC
## 8  2008-10-29 10:57:00      LAC      away      1   rebound   LAL
## 9  2008-10-29 10:41:00      LAC      away      1      shot   LAL
## 10 2008-10-29 10:40:00      LAC      away      1   rebound   LAC
## # ... with 25,544 more rows, and 6 more variables: player &amp;lt;chr&amp;gt;,
## #   result &amp;lt;chr&amp;gt;, points &amp;lt;int&amp;gt;, type &amp;lt;chr&amp;gt;, x &amp;lt;int&amp;gt;, y &amp;lt;int&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그런데 lubridate package 에는 기간(Time intervals) 에 대해 조금 더 세련된 방법으로 처리할 수 있는 함수들을 제공해 주고 있다.&lt;br /&gt;
&lt;code&gt;interval()&lt;/code&gt; 함수와 &lt;code&gt;%within%&lt;/code&gt; 연산자를 이용하면 조금 더 직관적인 서브세팅을 할 수 있다.&lt;br /&gt;
아래처럼 말이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;inter &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;interval&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;ymd_hms&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;2008-10-28 12:00:00&amp;quot;&lt;/span&gt;), &lt;span class=&quot;kw&quot;&gt;ymd_hms&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;2009-03-09 00:33:00&amp;quot;&lt;/span&gt;))
lakers %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;filter&lt;/span&gt;(time_index %within%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;inter)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 25,554 &amp;lt;U+00D7&amp;gt; 12
##             time_index opponent game_type period     etype  team
##                 &amp;lt;dttm&amp;gt;    &amp;lt;chr&amp;gt;     &amp;lt;chr&amp;gt;  &amp;lt;int&amp;gt;     &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;
## 1  2008-10-28 12:00:00      POR      home      1 jump ball   OFF
## 2  2008-10-29 12:00:00      LAC      away      1 jump ball   OFF
## 3  2008-10-29 11:36:00      LAC      away      1      shot   LAL
## 4  2008-10-29 11:24:00      LAC      away      1      shot   LAC
## 5  2008-10-29 11:24:00      LAC      away      1   rebound   LAL
## 6  2008-10-29 11:08:00      LAC      away      1      shot   LAL
## 7  2008-10-29 10:58:00      LAC      away      1      shot   LAC
## 8  2008-10-29 10:57:00      LAC      away      1   rebound   LAL
## 9  2008-10-29 10:41:00      LAC      away      1      shot   LAL
## 10 2008-10-29 10:40:00      LAC      away      1   rebound   LAC
## # ... with 25,544 more rows, and 6 more variables: player &amp;lt;chr&amp;gt;,
## #   result &amp;lt;chr&amp;gt;, points &amp;lt;int&amp;gt;, type &amp;lt;chr&amp;gt;, x &amp;lt;int&amp;gt;, y &amp;lt;int&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2개의 조건을 자질구레하게 정의하는것 보단&lt;br /&gt;
&lt;code&gt;interval()&lt;/code&gt; 를 사용한 후자의 방법이 훨씬 직관적일 수 있겠다.&lt;/p&gt;
&lt;p&gt;참고로 덧붙이면 &lt;code&gt;interval()&lt;/code&gt; 함수대신 &lt;code&gt;%--%&lt;/code&gt; 연산자를 써도 된다.&lt;br /&gt;
&lt;code&gt;%--%&lt;/code&gt; 를 &amp;quot;~&amp;quot; 처럼 생각하면 편할 것 같다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;inter &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;ymd_hms&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;2008-10-28 12:00:00&amp;quot;&lt;/span&gt;) %--%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;ymd_hms&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;2009-03-09 00:33:00&amp;quot;&lt;/span&gt;)
lakers %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;filter&lt;/span&gt;(time_index %within%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;inter)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 25,554 &amp;lt;U+00D7&amp;gt; 12
##             time_index opponent game_type period     etype  team
##                 &amp;lt;dttm&amp;gt;    &amp;lt;chr&amp;gt;     &amp;lt;chr&amp;gt;  &amp;lt;int&amp;gt;     &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;
## 1  2008-10-28 12:00:00      POR      home      1 jump ball   OFF
## 2  2008-10-29 12:00:00      LAC      away      1 jump ball   OFF
## 3  2008-10-29 11:36:00      LAC      away      1      shot   LAL
## 4  2008-10-29 11:24:00      LAC      away      1      shot   LAC
## 5  2008-10-29 11:24:00      LAC      away      1   rebound   LAL
## 6  2008-10-29 11:08:00      LAC      away      1      shot   LAL
## 7  2008-10-29 10:58:00      LAC      away      1      shot   LAC
## 8  2008-10-29 10:57:00      LAC      away      1   rebound   LAL
## 9  2008-10-29 10:41:00      LAC      away      1      shot   LAL
## 10 2008-10-29 10:40:00      LAC      away      1   rebound   LAC
## # ... with 25,544 more rows, and 6 more variables: player &amp;lt;chr&amp;gt;,
## #   result &amp;lt;chr&amp;gt;, points &amp;lt;int&amp;gt;, type &amp;lt;chr&amp;gt;, x &amp;lt;int&amp;gt;, y &amp;lt;int&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;e-기타-간편-기능-함수들&quot;&gt;E) 기타 간편 기능 함수들&lt;/h2&gt;
&lt;h3 id=&quot;e-1-timezone-인자를-받을-수-있는-now&quot;&gt;E-1) Timezone 인자를 받을 수 있는 &lt;code&gt;now()&lt;/code&gt;&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;now&lt;/span&gt;()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;2016-09-18 21:35:41 KST&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;now()&lt;/code&gt; 함수는 &lt;code&gt;Sys.time()&lt;/code&gt; 와 거의 기능이 똑같다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;now&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;America/New_York&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;2016-09-18 08:35:41 EDT&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;now&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;UTC&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;단 위의 예제처럼&lt;br /&gt;
Timezone 변경에 대해서 &lt;code&gt;Sys.time()&lt;/code&gt; 과는 다르게 &lt;code&gt;now()&lt;/code&gt; 는 이를 반영한 날짜 + 시각을 반환할 수 있다는 차이가 있다.&lt;/p&gt;
&lt;h3 id=&quot;e-2-오전-오후-am-pm&quot;&gt;E-2) 오전? 오후? : &lt;code&gt;am()&lt;/code&gt;, &lt;code&gt;pm()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;현 시간이 오후인지 오전인지 확인하기 위해서&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;ld1&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;2011-06-04 13:30:50 UTC&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;hour&lt;/span&gt;(ld1) &amp;gt;=&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;와 같은 코드를 사용하기 보단&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;am&lt;/span&gt;(ld1)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] FALSE&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;pm&lt;/span&gt;(ld1)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;요런식으로 활용해 볼 수 있겠다.&lt;/p&gt;
&lt;h3 id=&quot;e-3-시각에-대한-올림-내림-반올림&quot;&gt;E-3) 시각에 대한 올림, 내림, 반올림&lt;/h3&gt;
&lt;p&gt;제목대로 시각에 대한 올림, 내림, 반올림은 생각만해도 끔찍하다.&lt;br /&gt;
&lt;code&gt;round_date()&lt;/code&gt;, &lt;code&gt;floor_date()&lt;/code&gt;, &lt;code&gt;ceiling_date()&lt;/code&gt; 함수를 활용하는게 정서상 좋을 것이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;ld1
## [1] &amp;quot;2011-06-04 13:30:50 UTC&amp;quot;

&lt;span class=&quot;kw&quot;&gt;round_date&lt;/span&gt;(ld1, &lt;span class=&quot;st&quot;&gt;&amp;quot;hour&amp;quot;&lt;/span&gt;)
## [1] &amp;quot;2011-06-04 14:00:00 UTC&amp;quot;
&lt;span class=&quot;kw&quot;&gt;round_date&lt;/span&gt;(ld1, &lt;span class=&quot;st&quot;&gt;&amp;quot;day&amp;quot;&lt;/span&gt;)
## [1] &amp;quot;2011-06-05 UTC&amp;quot;

&lt;span class=&quot;kw&quot;&gt;floor_date&lt;/span&gt;(ld1, &lt;span class=&quot;st&quot;&gt;&amp;quot;hour&amp;quot;&lt;/span&gt;)
## [1] &amp;quot;2011-06-04 13:00:00 UTC&amp;quot;
&lt;span class=&quot;kw&quot;&gt;floor_date&lt;/span&gt;(ld1, &lt;span class=&quot;st&quot;&gt;&amp;quot;day&amp;quot;&lt;/span&gt;)
## [1] &amp;quot;2011-06-04 UTC&amp;quot;

&lt;span class=&quot;kw&quot;&gt;ceiling_date&lt;/span&gt;(ld1, &lt;span class=&quot;st&quot;&gt;&amp;quot;hour&amp;quot;&lt;/span&gt;)
## [1] &amp;quot;2011-06-04 14:00:00 UTC&amp;quot;
&lt;span class=&quot;kw&quot;&gt;ceiling_date&lt;/span&gt;(ld1, &lt;span class=&quot;st&quot;&gt;&amp;quot;day&amp;quot;&lt;/span&gt;)
## [1] &amp;quot;2011-06-05 UTC&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://rpubs.com/davoodastaraky/lubridate&quot;&gt;Woking with Dates and Times with lubridate in R&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cran.r-project.org/web/packages/lubridate/vignettes/lubridate.html&quot;&gt;Do more with dates and times in R with lubridate 1.3.0&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 18 Sep 2016 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2016/09/18/lubridate_package.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2016/09/18/lubridate_package.html</guid>
        
        
        <category>R</category>
        
      </item>
    
  </channel>
</rss>
