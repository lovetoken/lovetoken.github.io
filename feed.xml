<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description></description>
    <link>https://lovetoken.github.io/</link>
    <atom:link href="https://lovetoken.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 19 Sep 2018 09:55:41 +0900</pubDate>
    <lastBuildDate>Wed, 19 Sep 2018 09:55:41 +0900</lastBuildDate>
    <generator>Jekyll v3.1.6</generator>
    
      <item>
        <title>POSCO AI Chanllenge 과제 참여 연구노트</title>
        <description>&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;직원 동료의 이야기를 듣고 함께 참가하게 된 &lt;a href=&quot;https://posco-aichallenge.kr/&quot;&gt;POSCO AI Chanllenge&lt;/a&gt; 에 좋은 성적으로 입상을 하게 되어 본선에서 발표를 준비해야 하는 상황까지 오게 되었다.&lt;br /&gt;
참여하게 된 과제는 주어진 데이터를 기반으로 과거의 너울성 파도를 예측하는 과제로써, 3차 최종 결과 제출본 기준으로 2등을 하게 되었으며 상위 3팀이 본선을 진출하고 발표는 내일이다. 발표를 준비하는 겸, 지금까지 수행한 과제를 정리도 할겸 글을 정리해 보고자 한다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;과제의-목표&quot;&gt;과제의 목표&lt;/h2&gt;
&lt;p&gt;필자는 대회 설명회 때 참석하지 못하여 생생함이 덜 하지만&lt;br /&gt;
설명회의 이야기로는 너울성 파도를 사전에 예측하여 선박의 출항여부에 대해 의사결정에 도움을 받고&lt;br /&gt;
이어서 경제적, 인명적 손실을 최소화 하기 위함 이라고 전해 들었다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/posco1.png&quot;&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;POSCO 사의 입장으로써 이전부터 고민이 많은 이슈라 생각이 들었고, 그로 인한 계기로 본 과제를 기획한 것으로 생각된다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;데이터-현황과-전처리-수행과정&quot;&gt;데이터 현황과 전처리 수행과정&lt;/h2&gt;
&lt;p&gt;공급받은 데이터는 포스코 본사에 있는 포항 항구 근처에서 수집한 파고, 및 해수온도, 풍향등의 데이터이며 수집 지점은 월포, 구룡포 두 지점에 대한 약 3년치 자료이다.&lt;br /&gt;
그리고 과거 3년에 너울이 발생했는지의 여부를 시간단위로 판단할 수 있는 정답지 데이터 (Training dataset), 그리고 과제의 미션으로 예측을 해내야 하는 시점이 언제인지를 알려주는 시험지 데이터(Predict dataset)로 구성되어 있다고 볼 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 2,247 x 11
##      loc date       mean_temp max_temp min_temp mean_signi_wh mean_wh
##    &amp;lt;int&amp;gt; &amp;lt;date&amp;gt;         &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;         &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt;
##  1 22453 2014-01-01      13.7     13.8     13.6           0.6     0.4
##  2 22453 2014-01-02      14       14.3     13.6           0.7     0.5
##  3 22453 2014-01-03      14.4     14.9     14.1           0.6     0.4
##  4 22453 2014-01-04      14.5     14.8     13.9           1.3     0.8
##  5 22453 2014-01-05      14.4     14.6     14.3           1.5     0.9
##  6 22453 2014-01-06      14.1     14.3     14             1.1     0.7
##  7 22453 2014-01-07      13.9     14.3     13.7           0.7     0.4
##  8 22453 2014-01-08      13.8     14.1     13.4           0.4     0.3
##  9 22453 2014-01-09      13.8     14.3     13.2           1.4     0.8
## 10 22453 2014-01-10      13.5     13.9     13.1           1       0.6
## # ... with 2,237 more rows, and 4 more variables: max_signi_wh &amp;lt;dbl&amp;gt;,
## #   max_wh &amp;lt;dbl&amp;gt;, mean_cycle &amp;lt;dbl&amp;gt;, max_cycle &amp;lt;dbl&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;제공받은 항구별 수집 정보들의 rawdata 의 샘플&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1,231 x 5
##    date       swell start_time end_time testset
##    &amp;lt;date&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;time&amp;gt;     &amp;lt;time&amp;gt;     &amp;lt;int&amp;gt;
##  1 2014-01-04  NA   15:00      19:00          0
##  2 2014-01-04  NA   19:00      07:00          0
##  3 2014-01-05  NA   07:00      10:00          0
##  4 2014-01-05   3   10:00      13:00          0
##  5 2014-01-08  NA   10:00      19:00          0
##  6 2014-01-09   4.5 14:30      19:00          0
##  7 2014-01-09  12   19:00      07:00          0
##  8 2014-01-10   3   07:00      10:00          0
##  9 2014-01-10   2   10:00      13:00          0
## 10 2014-01-21   1.5 00:30      02:00          0
## # ... with 1,221 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;제공받은 정답지 데이터와 시험지 데이터의 rawdata 샘플&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;제공받은 데이터 외의 다른 데이터를 이용해도 된다는 주최측의 안내를 받고 자체적으로 추가 수집한 데이터도 있었으며&lt;br /&gt;
그 데이터는 포항 앞바다의 부이[^해상의 기상 상황을 관측하는 장비를 의미한다]로 부터 수집된 데이터이다.[^출처는 &lt;a href=&quot;http://sts.kma.go.kr/&quot;&gt;기상청 국가 기후 데이터 센터&lt;/a&gt;이다]&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 8,541 x 14
##    location date  wind_speed wind_direction  GUST local_air_press~ humidity
##       &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt;      &amp;lt;dbl&amp;gt;          &amp;lt;int&amp;gt; &amp;lt;dbl&amp;gt;            &amp;lt;dbl&amp;gt;    &amp;lt;int&amp;gt;
##  1    22106 2014~        8.2            259  11.1            1008.       44
##  2    22106 2014~       10.6            287  15.1            1009.       43
##  3    22106 2014~       11.7            287  14.9            1009.       42
##  4    22106 2014~       11.5            302  16.2            1010.       46
##  5    22106 2014~       11.8            284  16.4            1010.       50
##  6    22106 2014~        9.1            294  12.4            1010.       48
##  7    22106 2014~        7.3            293  11.7            1012.       43
##  8    22106 2014~        6.4            298   8.5            1012.       37
##  9    22106 2014~        5              296   8.1            1013.       35
## 10    22106 2014~        6.3            270   9.5            1014.       35
## # ... with 8,531 more rows, and 7 more variables: temperature &amp;lt;dbl&amp;gt;,
## #   water_temperature &amp;lt;dbl&amp;gt;, max_wave_height &amp;lt;dbl&amp;gt;,
## #   mean_wave_height &amp;lt;dbl&amp;gt;, avg_wave_height &amp;lt;dbl&amp;gt;, wave_accurance &amp;lt;dbl&amp;gt;,
## #   wave_direction &amp;lt;int&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;추가로 수집한 부이데이터의 rawdata 샘플&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이러한 데이터들을 충분히 EDA 한 후 머신러닝이나 딥러닝의 프레임워크 툴들이 학습하기 용이하도록 학습데이터 마트로 만들기 위한단계를 거쳤다.&lt;br /&gt;
너울성 파도의 여부를 &lt;code&gt;swell&lt;/code&gt; 이란 필드명으로 각 시간별 상황데이터(파고, 풍향, 풍속, 수온 등등의 설명변수집합)에 맵핑하는 전처리를 수행하였다.&lt;br /&gt;
그 결과는 아래와 같다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6,909 x 15
##    date   time swell wind_speed wind_direction  GUST air_pressure humidity
##    &amp;lt;chr&amp;gt; &amp;lt;int&amp;gt; &amp;lt;int&amp;gt;      &amp;lt;dbl&amp;gt;          &amp;lt;int&amp;gt; &amp;lt;dbl&amp;gt;        &amp;lt;dbl&amp;gt;    &amp;lt;int&amp;gt;
##  1 2014~     0     1       11              302  14          1026.       47
##  2 2014~     1     1       11.1            315  16.1        1027.       45
##  3 2014~    10     1        9.9            320  14.1        1030.       54
##  4 2014~    11     1        9.8            306  13          1030.       54
##  5 2014~    12     1        8.7            324  13.6        1030        49
##  6 2014~     2     1       11.7            314  15.4        1027.       46
##  7 2014~     3     1       12.4            324  16.8        1027.       49
##  8 2014~     4     1       12.5            320  17.8        1028.       45
##  9 2014~     5     1       13.7            311  17.5        1029.       49
## 10 2014~     6     1       14.2            320  17.5        1029.       50
## # ... with 6,899 more rows, and 7 more variables: temperature &amp;lt;dbl&amp;gt;,
## #   water_temperature &amp;lt;dbl&amp;gt;, max_wave_height &amp;lt;dbl&amp;gt;,
## #   mean_wave_height &amp;lt;dbl&amp;gt;, avg_wave_height &amp;lt;dbl&amp;gt;, wave_accurance &amp;lt;dbl&amp;gt;,
## #   wave_direction &amp;lt;int&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;정답지가 존재하는 시점을 &lt;code&gt;date&lt;/code&gt;, &lt;code&gt;time&lt;/code&gt; 두 필드로 시점의 정보를 부여하고&lt;br /&gt;
그 시점의 너울성 파도 여부를 구분하는 &lt;code&gt;swell&lt;/code&gt; 을 맵핑하였으며 (너울성 파도가 일어난 경우 1, 그렇지 않은경우 0)&lt;br /&gt;
EDA 를 통해 선별한 12개의 설명변수&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;wind_speed&lt;/code&gt; : 풍속&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wind_direction&lt;/code&gt; : 풍향&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GUST&lt;/code&gt; : 돌풍의 정도&lt;/li&gt;
&lt;li&gt;&lt;code&gt;air_pressure&lt;/code&gt; : 기압&lt;/li&gt;
&lt;li&gt;&lt;code&gt;humidity&lt;/code&gt; : 주변습도&lt;/li&gt;
&lt;li&gt;&lt;code&gt;temperature&lt;/code&gt; : 주변온도&lt;/li&gt;
&lt;li&gt;&lt;code&gt;water_temperature&lt;/code&gt; : 수온&lt;/li&gt;
&lt;li&gt;&lt;code&gt;max_wave_height&lt;/code&gt; : 파고최대높이&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mean_wave_height&lt;/code&gt; : 파고평균높이&lt;/li&gt;
&lt;li&gt;&lt;code&gt;avg_wave_height&lt;/code&gt; : 파고유의높이&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wave_accurance&lt;/code&gt; : 파고주기&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wave_direction&lt;/code&gt; : 파도방향&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;를 같이 맵핑하였다.&lt;/p&gt;
&lt;p&gt;참고로 결측값에 대한 이슈도 있었는데&lt;br /&gt;
맵핑과정에서 그 시간시점에 해당되는 데이터가 존재하지 않아 결측이 일어나는 경우가 바로 그것이었다.&lt;br /&gt;
결측행을 제외하는것은 데이터의 손실이 너무 크다고 판단하였고 따라서 결측을 대치하는 방법을 고려했다.&lt;br /&gt;
대부분 LOCF(Last Observation Carried Forward) 방법으로 가장 최근값을 상속시키는 결측대치법을 이용하였고, LOCF 결측대치가 타당하지 않다고 판단되는 풍속(&lt;code&gt;wind_direction&lt;/code&gt;)의 경우 중앙값 대치를 고려하여 적용했다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;너울성-파도-예측-모형-구현&quot;&gt;너울성 파도 예측 모형 구현&lt;/h2&gt;
&lt;p&gt;본 과제의 명칭에 걸맞게 AI 기술을 이용하여 너울성 파도를 예측하고자 예측 모형을 구현하고 Validation set 을 통해 모형을 평가하였다.&lt;br /&gt;
머신러닝 기법과 그중에서도 딥러닝 기법들을 다양하게 테스트 해보고 예측성능이 높게 평가된 것을 선별하여 1,2,3차에 걸쳐 제출하게 되었다.&lt;/p&gt;
&lt;p&gt;1,2,3차 때는 각 차수별로 대략 2주간의 시간이 주어졌다고 볼 수 있는데&lt;br /&gt;
각 차수별 아래와 같은 목표로 진행하였다.&lt;/p&gt;
&lt;p&gt;1차때는 딥러닝 모델을 구현하기 전 손쉽게 적용해 볼 수 있는 전통적인 머신러닝 알고리즘들을 이용하여 Warming up 을 해보는 단계로 계획하여 테스트 해 보았다.&lt;/p&gt;
&lt;p&gt;2차때는 1차때 선별된 머신러닝 알고리즘의 모형보다 예측성능이 더 높은 딥러닝 기반의 모형을 구현하는 것을 목표로 잡고 딥러닝 모형을 구현하였다.&lt;/p&gt;
&lt;p&gt;3차때는 역시 2차때 선별된 딥러닝 알고리즘보다 더 높은 예측성능을 보이는 모델을 찾기 위해 더 다른 관점의 고민들을 해보는 기간으로 잡았다.&lt;/p&gt;
&lt;p&gt;그 결과&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1차 : Weighted Subspace Random Forest 알고리즘 모형&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;2차 : Artificial Neural Network(ANN) 모형&lt;/li&gt;
&lt;li&gt;3차 : Flexible Discriminant Analysis(FDA) 모형&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3개의 모형을 구현하였고, 이를 통한 예측값을 제출하게 되었다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;모형-평가&quot;&gt;모형 평가&lt;/h2&gt;
&lt;p&gt;모형의 예측성능을 평가하기 전&lt;br /&gt;
무엇을 객관적인 목표로 잡고 각 3개의 모형이 선별되었는지 선발 기준에 대한 설명을 사전에 할 필요가 있을 것 같다.&lt;/p&gt;
&lt;p&gt;본 과제는 Binary Classification 문제이고, 특히 너울성 파도가 일어난 이벤트의 당시상황이 중요하므로 &amp;quot;너울성파도가 일어난&amp;quot; 시점에 대해서, 모형이 &amp;quot;너울성 파도가 일어남&amp;quot; 이라고 예측하는 것이 더 중요했다.&lt;br /&gt;
더 중요한 이유는 너울성 파도는 드물게 일어나며, 평시 상황은 너울성파도가 일어나지 않는 상황이어서 &amp;quot;너울성 파도가 일어나지 않은&amp;quot; 시점에 대해서, 모형이 &amp;quot;너울성 파도를 일어나지 않음&amp;quot;으로 예측하는 것은 조금 덜 중요하다고 볼 수 있다.&lt;br /&gt;
이런 특성때문에 과제 평가 정책을 상황별로 다르게 스코어링 하였었고, 그 공식은 아래와 같다.&lt;br /&gt;
* 너울성파도가 일어난 시점에 대해서, 모형이 너울성 파도가 일어났다고 예측 : +2 * 너울성파도가 일어난 시점에 대해서, 모형이 너울성 파도가 일어나지 않았다고 예측 : -2 * 너울성 파도가 일어나지 않은 시점에 대해서, 모형이 너울성 파도를 일어나지 않았다고 예측 : +1 * 너울성 파도가 일어나지 않은 시점에 대해서, 모형이 너울성 파도가 일어났다고 예측 : -1&lt;/p&gt;
&lt;p&gt;이 공식에 의해서 우리가 정한 Validation set 상에서의 최대치 점수는 1943점이었고 각 차수별 모형은 아래의 예측성능 점수를 매길 수 있었다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1차 Weighted Subspace Random Forest 알고리즘 모형 : 1471점&lt;/li&gt;
&lt;li&gt;2차 Artificial Neural Network(ANN) 모형 : 1507점&lt;/li&gt;
&lt;li&gt;3차 Flexible Discriminant Analysis(FDA) 모형 : 1545점&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;각-차수별-detail&quot;&gt;각 차수별 Detail&lt;/h2&gt;
&lt;p&gt;각 차수 별로 각각 아래의 연구를 통해 모형을 구현하고 예측셋 시험지를 풀었다.&lt;/p&gt;
&lt;h3 id=&quot;차&quot;&gt;1차&lt;/h3&gt;
&lt;p&gt;머신러닝 알고리즘을 이용한 워밍업 단계라고 설명했는데&lt;br /&gt;
실제론 1차때 테스트해 본 케이스들이 정말로 많았다.&lt;br /&gt;
실험 알고리즘 케이스는 R의 caret 패키지의 머신러닝 프레임워크의 도움을 얻어 대표적으로 아래의 테스트를 해보았다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Partial Least Squares&lt;/li&gt;
&lt;li&gt;Generalized Linear Model&lt;/li&gt;
&lt;li&gt;Linear Discriminant Analysis&lt;/li&gt;
&lt;li&gt;ROC-Based Classifier&lt;/li&gt;
&lt;li&gt;k-Nearest Neighbors # Test 제외&lt;/li&gt;
&lt;li&gt;CART 5.0(Classification and Regression Tree)&lt;/li&gt;
&lt;li&gt;Weighted Subspace Random Forest&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;제시된 7개 머신러닝 알고리즘은 분류문제에 특화된 알고리즘으로써 본 데이터에 대해 성능을 기대하였던 알고리즘이다.&lt;br /&gt;
80%의 과거데이터를 Training set 으로 이용하기 위하여 파티션을 취했고, 이를 재료로 학습을 통해 모형을 구축하였다.&lt;br /&gt;
k Fold 교차검증으로[^상황에 따라 K를 8, 10 등으로 바꾸어서 하기도 해서 그냥 K라 표기한다] 각 알고리즘별 튜닝파라미터를 선정하였고, 파티션에 남은 20% 최근 데이터를 통해 예측성능을 확인해 보았다.&lt;/p&gt;
&lt;p&gt;7개 알고리즘 모형중 Weighted Subspace Random Forest 알고리즘을 이용한 모형이 1471점으로 예측성능이 가장 높아 선정하게 되었다.&lt;/p&gt;
&lt;h3 id=&quot;차-1&quot;&gt;2차&lt;/h3&gt;
&lt;p&gt;1차때 선정된 Weighted Subspace Random Forest 알고리즘 모형보다 더 높은 예측성능을 내는 딥러닝 구현을 목표로 인공신경망(ANN)에 해당되는 기법들을 테스트 했다.&lt;br /&gt;
순환신경망(RNN), 심층신경망(DNN) 등을 테스트 하였고, 하이퍼 파라미터들에 대한 실험케이스들을 여러개로 나누어 1차때의 예측성능 보다 높은 모형을 만들기 위해 노력했다.&lt;br /&gt;
그 결과 1507점을 내는 모형을 찾게 되었다.&lt;/p&gt;
&lt;h3 id=&quot;차-2&quot;&gt;3차&lt;/h3&gt;
&lt;p&gt;3차때는 전반적인 데이터의 현황에 대한 검토를 면밀하게 하고 넘어가고자 했다.&lt;br /&gt;
과제 전부터 한가지 집혔던 것이&lt;br /&gt;
전처리가 완료된 학습데이터 마트에 대한 EDA 후 확인되었던 이슈지만&lt;br /&gt;
너울성 파도의 발생 이벤트가 매우 소수이어서, 이 소수인 클래스의 학습력이 상대적으로 부족할 것이라고 우려했었다. 즉 Class imbalance problem 의 문제를 먼저 풀고 모델링에 들어가면 더 유리할 것이라고 생각했었다.&lt;br /&gt;
이 부분을 해결하기 위해 너울성 파도가 일어난 데이터(&lt;code&gt;swell&lt;/code&gt; = 1)를 늘리면서 너울성 파도가 일어나지 않은 데이터(&lt;code&gt;swell&lt;/code&gt; = 0)와 균형이 맞도록 Random Over Smapling 을 통해 학습셋을 기존 6,000여건에서 20,000여건으로 늘려 재구성 해 보았다.[^구현 방법은 R의 ROSE package 를 이용했다]&lt;/p&gt;
&lt;p&gt;이후 재구성된 학습셋을 기준으로 이전에 시도했던 알고리즘들을 다시 돌려보고, 추가로&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Radial Basis Function Network&lt;/li&gt;
&lt;li&gt;Flexible Discriminant Analysis&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;두개의 머신러닝 알고리즘을 더 고려하여 테스트 해보니, 이전보다 더 높은 예측성능을 내는 모형이 나타났고 그 결과 Flexible Discriminant Analysis 모형이 1545점 으로 지금까지 수행한 모형의 예측성능 중 가장 높게 나온 모델을 만들었다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;모델링-이전-신경썼던-부분&quot;&gt;모델링 이전 신경썼던 부분&lt;/h2&gt;
&lt;p&gt;인공지능 모형이 오버피팅이 되는 것을 사전에 막고, 제한된 학습셋을 통해 우리가 알지 못하는 실제 Test set 에 대해 잘 예측해내는 모형을 만들기 위해선 데이터에 대한 다각도의 이해와 인공지능을 구현하기 위한 머신러닝 &amp;amp; 딥러닝 알고리즘에 대한 어느정도 이론적인 이해도가 필요했다.&lt;br /&gt;
특히 차원의 저주로 인하여 타겟을(너울성파도) 예측하는데 더 많은 데이터를 필요로 하는것을 막기 위하여 다중공산성을 고려해 상관도가 높은 설명변수의 조합을 줄여보는 시도도 했고,&lt;br /&gt;
시계열적인 파생변수가 타겟과 유의미한 연관관계가 있는지도 데이터 시각화를 통해 살펴보는 등&lt;br /&gt;
EDA 를 꽤 정성들여 해 본것이 인상깊었다. (사실 EDA 는 하면 할수록 욕심이 생겨 끝도 없이 해 볼 수 있는 과정이라 생각하는데.. 제한시간이 있었기에 어느 단계에서 멈출수 있었다는 건 함정..)&lt;br /&gt;
이는 Feature engineering 측면에서 다양한 실험케이스를 만들어 분석을 풍부하게 해 볼 수 있는 요인으로 작용했지만&lt;br /&gt;
본 과제의 결론은 Full model(가용가능한 설명변수를 모두 이용하는 모델)이 채택이 되었었다.&lt;/p&gt;
</description>
        <pubDate>Wed, 19 Sep 2018 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/machinelearning/2018/09/19/posco_ai.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/machinelearning/2018/09/19/posco_ai.html</guid>
        
        
        <category>MachineLearning</category>
        
      </item>
    
      <item>
        <title>R에서 plot3d()함수를 이용한 3차원 산점도 만들기</title>
        <description>&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;다변량 데이터에 대해서 변수와 변수간 관계를 확인하고 설명하고 싶은 분들을 위해&lt;br /&gt;
그 관계성을 간편하고 직관적으로 도울 수 있는 도구들이 필요해 지고 있다.&lt;br /&gt;
특히 변수와 변수간 관계는 주관심 대상의 변수가 많아지면 많아질수록 확인해 보고 규명해야할 케이스도 많아지는데&lt;br /&gt;
이를 시각화 할때 2차원 산점도 에서는 그 많은 케이스를 확인하는데는 쉽게 피로해 질 수 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;너무많아...&lt;/p&gt;
&lt;/blockquote&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/plot3d_1.png&quot;&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;2차원 산점도 보다 한차원 높은 3차원 산점도는 주관심 대상 변수간 관계를 확인하기 위한 선택폭이 하나가 많고&lt;br /&gt;
조금 더 집중도있게 확인할 수 있는 장점이 있는 것 같다.&lt;br /&gt;
R에서는 rgl 패키지를 통해 3차원 산점도를 어려움 없이 구현할 수 있다.&lt;br /&gt;
rgl package 의 &lt;code&gt;plot3d()&lt;/code&gt; 함수를 소개해 본다.&lt;/p&gt;
&lt;p&gt;2차원 산점도를 그릴 때 R에선 간편히 &lt;code&gt;plot()&lt;/code&gt; 함수에서 &lt;code&gt;plot(x, y)&lt;/code&gt; 의 형태로 확인이 가능하다.&lt;br /&gt;
&lt;code&gt;plot3d()&lt;/code&gt; 함수에선 &lt;code&gt;plot3d(x, y, z)&lt;/code&gt; 의 형태로 주관심대상 변수 하나를 더 추가해 사용하면 되므로 이런 측면에선 사용법이 비슷하다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;plot3d()&lt;/code&gt; 의 예시코드를 실행해 보기 위해 rgl 패키지를 로드한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(rgl)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;아래 코드는 &lt;code&gt;plot3d()&lt;/code&gt; 의 대표 예제 코드이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;x &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;sort&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;rnorm&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1000&lt;/span&gt;))
y &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;rnorm&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1000&lt;/span&gt;)
z &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;rnorm&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1000&lt;/span&gt;) +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;atan2&lt;/span&gt;(x,y)
&lt;span class=&quot;kw&quot;&gt;plot3d&lt;/span&gt;(x, y, z, &lt;span class=&quot;dt&quot;&gt;col=&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;rainbow&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1000&lt;/span&gt;))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3차원 산점도를 출력시키는 &lt;code&gt;plot3d()&lt;/code&gt; 함수는 특수한 엔진을 사용하기 때문에&lt;br /&gt;
시각화 결과물이 (가령 Rstudio 의 경우 Plots창에 뜨지 않고) 새로운 창에 별도로 출력된다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;iframe width=&quot;95%&quot; height=&quot;420&quot; src=&quot;https://www.youtube.com/embed/oPszzgu00Uw&quot; frameborder=&quot;0&quot; allow=&quot;autoplay; encrypted-media&quot; allowfullscreen&gt;
&lt;/iframe&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;직접실행해 보면 새로운 팝업창이 뜨고(사용환경에 따라 다르다)&lt;br /&gt;
이 안에서 3D산점도가 출력되며, 사용자가 직접 움직여 볼 수 있다.&lt;br /&gt;
또한 휠을 움직이면 줌인과 줌아웃도 된다.&lt;/p&gt;
</description>
        <pubDate>Thu, 02 Aug 2018 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/data_visualization/2018/08/02/plot3d.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/data_visualization/2018/08/02/plot3d.html</guid>
        
        
        <category>R</category>
        
        <category>Data_Visualization</category>
        
      </item>
    
      <item>
        <title>R에서 Keras 튜토리얼 돌려보기</title>
        <description>&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;필자는 TensorFlow 를 활용한 딥러닝 구현은 아직까지도 직접 해본적이 없었는데&lt;br /&gt;
Keras 가 나오고서야 딥러닝을 처음으로 직접 시도해보게 되었다.&lt;br /&gt;
Keras 를 이용해 보고싶어 &lt;a href=&quot;https://tensorflow.rstudio.com/keras/&quot;&gt;튜토리얼&lt;/a&gt;을 빠르게 훝어본적이 있었는데&lt;br /&gt;
그 과정을 정리한 글이다.&lt;/p&gt;
&lt;p&gt;본글은 R에서 Keras 튜토리얼 예제를 따라해 본 것을 빠르게 정리한 글이며&lt;br /&gt;
딥러닝의 Hello world 격인 MNIST 의 숫자를 예측하는 모델을 만드는 것을 목적으로 한다.&lt;br /&gt;
딥러닝에 대한 이론적인 설명, 기술은 자세히 하지 않는다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;keras-를-r에서-설치하기&quot;&gt;Keras 를 R에서 설치하기&lt;/h2&gt;
&lt;p&gt;R session 에서 다음 코드를 통해 설치가 가능하다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;devtools::&lt;span class=&quot;kw&quot;&gt;install_github&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;rstudio/keras&amp;quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(keras)
&lt;span class=&quot;kw&quot;&gt;install_keras&lt;/span&gt;()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Keras 를 설치하기 위해서 rstudio 배포판 keras package 를 설치한다.&lt;br /&gt;
이후 keras package 를 로드하고 &lt;code&gt;install_keras()&lt;/code&gt; 함수를 통해 실제로 Keras 라이브러리를 설치할 수 있다.&lt;/p&gt;
&lt;p&gt;라이브러리를 추가로 설치하라는 요구사항이 뜨면서 설치가 중단될 경우 (본인의 경우 &lt;code&gt;python-virtualenv&lt;/code&gt; 가 없어서 중단됨)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Error: Prerequisites for installing TensorFlow not available.

Execute the following at a terminal to install the prerequisites:

$ sudo apt-get install python-virtualenv&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;안내 받는&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get install python-virtualenv&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;등을 실행시켜 요구사항을 충족시킨 후 &lt;code&gt;install_keras()&lt;/code&gt; 를 실행해 설치를 진행하면 되겠다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;mnist-튜토리얼-예제-수행&quot;&gt;MNIST 튜토리얼 예제 수행&lt;/h2&gt;
&lt;br&gt;&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/MNIST.png&quot;&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;지도학습의 대표적인 MNIST 예제를 수행해봄으로써 Keras 의 설치가 정상적으로 되었는지, 동작은 제대로 하는지 확인해보면 좋겠다.&lt;/p&gt;
&lt;p&gt;Keras 를 쓰기전에 코딩과정은 보통 아래의 레파토리를 거치며 진행된다.&lt;/p&gt;
&lt;br&gt;&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/keras_tuto.png&quot;&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;진행할 튜토리얼도&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;모델 정의&lt;/li&gt;
&lt;li&gt;모델 형태 사전설정&lt;/li&gt;
&lt;li&gt;모델 적합&lt;/li&gt;
&lt;li&gt;모델 평가&lt;/li&gt;
&lt;li&gt;모델을 통한 예측&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이 과정이 모두 담겨있다고 볼 수 있다.&lt;/p&gt;
&lt;p&gt;튜토리얼을 시작해보자.&lt;br /&gt;
우선 MNIST 데이터셋을 준비한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;mnist &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;dataset_mnist&lt;/span&gt;()
x_train &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;mnist$train$x
y_train &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;mnist$train$y
x_test &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;mnist$test$x
y_test &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;mnist$test$y

&lt;span class=&quot;co&quot;&gt;# reshape&lt;/span&gt;
x_train &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;array_reshape&lt;/span&gt;(x_train, &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;nrow&lt;/span&gt;(x_train), &lt;span class=&quot;dv&quot;&gt;784&lt;/span&gt;))
x_test &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;array_reshape&lt;/span&gt;(x_test, &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;nrow&lt;/span&gt;(x_test), &lt;span class=&quot;dv&quot;&gt;784&lt;/span&gt;))
&lt;span class=&quot;co&quot;&gt;# rescale&lt;/span&gt;
x_train &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;x_train /&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;255&lt;/span&gt;
x_test &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;x_test /&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;255&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위의 코드는 MNIST 의 숫자 사진들을 학습셋과 테스트셋으로 나누고 각각 라벨링을 정리한 것으로 보면 되겠다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;y_train &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;to_categorical&lt;/span&gt;(y_train, &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;)
y_test &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;to_categorical&lt;/span&gt;(y_test, &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;타겟라벨링 y 경우 맨 처음에는 각각의 그림이 무슨 숫자인지를 벡터형으로 관리했는데 더미화(One-hot encode) 하여야 한다.&lt;br /&gt;
&lt;code&gt;to_categorical()&lt;/code&gt; 함수를 통해 10개의 카테고리로써 One-hot encoding 을 간편히 수행할 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;model &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;keras_model_sequential&lt;/span&gt;() 
model %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;layer_dense&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;units =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;256&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;activation =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;#39;relu&amp;#39;&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;input_shape =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;784&lt;/span&gt;)) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;layer_dropout&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;rate =&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;0.4&lt;/span&gt;) %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;layer_dense&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;units =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;128&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;activation =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;#39;relu&amp;#39;&lt;/span&gt;) %&amp;gt;%
&lt;span class=&quot;st&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;layer_dropout&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;rate =&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;0.3&lt;/span&gt;) %&amp;gt;%
&lt;span class=&quot;st&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;layer_dense&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;units =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;activation =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;#39;softmax&amp;#39;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;모델링을 수행하기 전 모델링 방법과 레이어 구성 등의 Rule 을 적용하는 단계이다.&lt;br /&gt;
&lt;code&gt;keras_model_sequential()&lt;/code&gt; 로 모델의 레이어를 구성하기 위한 초기 뼈대를 만들어 놓고 그 객체를 &lt;code&gt;model&lt;/code&gt; 이 가져갔다면 &lt;code&gt;layer_dense()&lt;/code&gt; 함수와 &lt;code&gt;layer_dropout()&lt;/code&gt; 등의 함수들로 레이어의 순서와 구성을 기획할 수 있다.&lt;br /&gt;
단 &lt;code&gt;layer_dense()&lt;/code&gt;, &lt;code&gt;layer_dropout()&lt;/code&gt;, &lt;code&gt;layer_activation()&lt;/code&gt;, &lt;code&gt;layer_masking()&lt;/code&gt; 등의 함수들을 거친 keras.models.Sequential 클래스 객체는 따로 할당연산자 없이도 레이어 구성이 바로 적용되는것이 (나에게 있어선) 독특했다.&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;레이어 구성이 어떻게 되었는지 확인해 보고 싶다면 &lt;code&gt;summary(model)&lt;/code&gt; 을 실행해 보자.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;summary&lt;/span&gt;(model)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## ___________________________________________________________________________
## Layer (type)                     Output Shape                  Param #     
## ===========================================================================
## dense_7 (Dense)                  (None, 256)                   200960      
## ___________________________________________________________________________
## dropout_5 (Dropout)              (None, 256)                   0           
## ___________________________________________________________________________
## dense_8 (Dense)                  (None, 128)                   32896       
## ___________________________________________________________________________
## dropout_6 (Dropout)              (None, 128)                   0           
## ___________________________________________________________________________
## dense_9 (Dense)                  (None, 10)                    1290        
## ===========================================================================
## Total params: 235,146
## Trainable params: 235,146
## Non-trainable params: 0
## ___________________________________________________________________________&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;다음으로 &lt;code&gt;compile()&lt;/code&gt; 함수를 통해 비용함수와 최적화 방법, 최적화 평가기준을 설정할 수 있다.&lt;br /&gt;
튜토리얼 코드상에선 아래의 방법으로 설정했는데 그외 다양한 방법이 있는지 살펴보기 위해서 &lt;code&gt;compile()&lt;/code&gt; 함수의 도움말을 살펴보았지만 큰 도움이 안되어서 당황스러웠다.&lt;br /&gt;
이때 부터는 Keras document 를 직접 훝어보아야 할듯 하다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;model %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;compile&lt;/span&gt;(
  &lt;span class=&quot;dt&quot;&gt;loss =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;categorical_crossentropy&amp;quot;&lt;/span&gt;,
  &lt;span class=&quot;dt&quot;&gt;optimizer =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;optimizer_rmsprop&lt;/span&gt;(),
  &lt;span class=&quot;dt&quot;&gt;metrics =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;accuracy&amp;quot;&lt;/span&gt;)
)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;본격적으로 학습 및 평가를 해보자.&lt;/p&gt;
&lt;p&gt;학습은 &lt;code&gt;fit()&lt;/code&gt; 함수를 통해 가능하며 8 epochs 과 128 의 batch 사이즈로 학습을 수행하는 코드이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;history &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;model %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;fit&lt;/span&gt;(
  x_train, y_train, 
  &lt;span class=&quot;dt&quot;&gt;epochs =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;batch_size =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;128&lt;/span&gt;, 
  &lt;span class=&quot;dt&quot;&gt;validation_split =&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;0.2&lt;/span&gt;
)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;loss 가 계속 줄어드면서 학습 및 최적화를 하는 과정이 8 epochs 만큼 진행 되는 로그가 출력될 것이다.&lt;br /&gt;
약 1분이 지나면 코드수행이 끝나게 되고 &lt;code&gt;history&lt;/code&gt; 객체를 통해 학습수행과정에 대한 정보를 확인할 수 있다.&lt;br /&gt;
plotting 을 하면 학습과정중 training set 과 validation set 기준으로 정확도와 loss 가 epoch 별로 어떻게 변화했는지를 볼 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(history)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/keras_tuto1.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Keras 를 이용한 학습 모델이 테스트셋을 기준으로 얼마만큼 예측성능률을 가지고 잇는지 평가해 보자.&lt;br /&gt;
평가는 &lt;code&gt;evaluate()&lt;/code&gt; 함수를 이용한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;model %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;evaluate&lt;/span&gt;(x_test, y_test)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## $loss
## [1] 0.08196825
## 
## $acc
## [1] 0.9788&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;테스트셋에 대한 예측정확도가 97.88% 가 나온것을 볼 수 있다.&lt;br /&gt;
실제로 Testset 을 모델에 입력하여 어떤 숫자를 예측하는지 보고 싶다면&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;model %&amp;gt;%&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;predict_classes&lt;/span&gt;(x_test[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;, ])&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##  [1] 7 2 1 0 4 1 4 9 5 9&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;를 통해 뽑을 수 있겠다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://keras.rstudio.com/&quot;&gt;R interface to Keras&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://tensorflow.rstudio.com/keras/&quot;&gt;R interface to Keras (TensorFlow)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;물론 다른 이름의 객체로 할당시키는것도 가능했다&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Sat, 02 Jun 2018 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/machinelearning/keras/2018/06/02/keras_tutorial.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/machinelearning/keras/2018/06/02/keras_tutorial.html</guid>
        
        
        <category>R</category>
        
        <category>MachineLearning</category>
        
        <category>Keras</category>
        
      </item>
    
      <item>
        <title>R에서 Newton Raphson Method 에 대한 시뮬레이션 과제 (+ ggplot2, gganimate package)</title>
        <description>&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;통계학과 대학원 수업 때 미분가능한 연속 함수에 대해서 해를 찾는 방법들을 공부한 적이 있다.&lt;br /&gt;
해를 찾아가는 과정들이 알고리즘 방법별로 특색이 있었는데, 원리를 알아가면 알아갈 수록 재미있기도 한 부분이었다.&lt;br /&gt;
특히 통계학 수업에선 1학년 학부때 부터 MLE(Maximum Likelihood Estimator) 라는 추정량의 특성을 중요하게 살펴본다.&lt;br /&gt;
극대값을 알아내기 위하여 1차 도함수에 해를 찾아내기 위한 훈련을 하면서도 나는 과연 이를 실전에 어떻게 적용할 것인가의 고민을 병행했고, 결과론적으로 프로그래밍을 어떻게 해야하는지 추가적인 고민을 더했던 때가 기억이 난다.&lt;/p&gt;
&lt;p&gt;학생을 벗어나 지금은 빅데이터 프로젝트에서 언제한번 이런 해를 찾는 과제를 수행해 볼지 살짝 의문이 들기는 한다.&lt;br /&gt;
하지만 빅데이터 프로젝트의 최종 목적지 앞 팔부능선 쯤에는 최적화 문제를 직면하는 분들도 보였고,&lt;br /&gt;
서비스가 안정화 되는 시점에서 모델과 추가 실데이터에 대한 2차 타당성 검증이 필요 할 때 역시 최적화가 잘 되었는지의 확인하는 문제로 수렴한다는 생각이 문득 든다.&lt;br /&gt;
이런 근사해를 찾는 이론을 바탕으로 근간한 아이디어를 최적화 관점에서 언제 어디선가 써먹을 일이 있지 않을까 싶다.&lt;br /&gt;
그런 의미로 대학원 때 배운 Newton Raphson Method 의 시뮬레이션을 회고해 본다.&lt;/p&gt;
&lt;p&gt;그냥 회고해 보면 약간 심심하니 R의 ggplot2 와 gganimate 패키지를 학습할 겸 곁들여 시뮬레이션을 생동감있게 해보고자 한다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;newton-raphson-method&quot;&gt;Newton Raphson method&lt;/h2&gt;
&lt;p&gt;Newton Raphson method 는 평균값 정리(mean value theorem) 혹은 테일러 근사(taylor approximation)를 근간으로 근사치를 반복하여 업데이트 하는 개념을 이용한다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/netwon_raphson_0.png&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;여기서 &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;&lt;em&gt;n&lt;/em&gt;&lt;/sub&gt;&lt;/span&gt; 의 n을 계속 증가시켜 가다 보면 수렴하게 되는데 &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;∞&lt;/sub&gt;&lt;/span&gt; 을 &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;f&lt;/em&gt;(&lt;em&gt;x&lt;/em&gt;)=0&lt;/span&gt; 의 해로 판단한다.&lt;br /&gt;
단 무한대로 반복할 순 없기 때문에 정지조건을 부여한다.&lt;/p&gt;
&lt;p&gt;이 Newton Raphson method 를 구현한 R code 는 아래와 같다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.academia.edu/7031789/Newton-Raphson_Method_in_R&quot;&gt;Newton Raphson Method in R&lt;/a&gt; 글을 참조함&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;newton &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;function(fun, &lt;span class=&quot;dt&quot;&gt;tol =&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;1e-7&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;x0 =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;N =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;300&lt;/span&gt;){
  h &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;fl&quot;&gt;1e-7&lt;/span&gt;
  i &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
  x1 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;x0
  p &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;numeric&lt;/span&gt;(N)
  while(i &amp;lt;=&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;N){
    df.dx &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;fun&lt;/span&gt;(x0 +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;h) -&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;fun&lt;/span&gt;(x0)) /&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;h
    x1 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;(x0 -&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;fun&lt;/span&gt;(x0) /&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;df.dx))
    p[i] &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;x1
    i =&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;i&lt;span class=&quot;dv&quot;&gt;+1&lt;/span&gt;
    if(&lt;span class=&quot;kw&quot;&gt;abs&lt;/span&gt;(x1 -&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;x0) &amp;lt;&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;tol) break
    x0 =&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;x1
  }
  &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;(p[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:(i -&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)])
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;정의된 &lt;code&gt;newton()&lt;/code&gt; 함수를 이용해 &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;f&lt;/em&gt;(&lt;em&gt;x&lt;/em&gt;)=&lt;em&gt;x&lt;/em&gt;&lt;sup&gt;3&lt;/sup&gt; + 2&lt;/span&gt; 함수의 &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;f&lt;/em&gt;(&lt;em&gt;x&lt;/em&gt;)=0&lt;/span&gt; 의 해를 초기값 2 에서 찾기 시작하면&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;fun &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;function(x) x^&lt;span class=&quot;dv&quot;&gt;3+2&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;newton&lt;/span&gt;(fun, &lt;span class=&quot;dt&quot;&gt;x0 =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;##  [1]  1.166667  0.287982 -7.846566 -5.241872 -3.518844 -2.399736 -1.715590
##  [8] -1.370234 -1.268564 -1.259980 -1.259921 -1.259921&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이렇게 된다.&lt;br /&gt;
&lt;code&gt;tol&lt;/code&gt; 값 보다 현시차와 이전시차값의 절대값 차이가 적을 때 정지조건에 의해서 멈추는데&lt;br /&gt;
멈추고 나서의 마지막 값이 &lt;code&gt;-1.259921&lt;/code&gt; 이며 Newton Raphson method 는 이 값을 &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;x&lt;/em&gt;&lt;sup&gt;3&lt;/sup&gt; + 2 = 0&lt;/span&gt; 의 해로 계산한다.&lt;/p&gt;
&lt;p&gt;ggplot2 로 &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;y&lt;/em&gt; = &lt;em&gt;x&lt;/em&gt;&lt;sup&gt;3&lt;/sup&gt; + 2&lt;/span&gt; 함수의 그래프를 그린 후 이터레이션 별로 어디에 수렴해 가는지 시각화 해보면 아래와 같다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;p &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;ggplot&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;data.frame&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;x =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;c&lt;/span&gt;(-&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)), &lt;span class=&quot;kw&quot;&gt;aes&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;x =&lt;/span&gt; x)) +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;stat_function&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;fun =&lt;/span&gt; fun, &lt;span class=&quot;dt&quot;&gt;color =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;blue&amp;quot;&lt;/span&gt;) +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;geom_hline&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;yintercept =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;geom_vline&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;xintercept =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)

d &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;data.frame&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;label =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;kw&quot;&gt;length&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;newton&lt;/span&gt;(fun, &lt;span class=&quot;dt&quot;&gt;x0 =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)), 
                &lt;span class=&quot;dt&quot;&gt;x =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;newton&lt;/span&gt;(fun, &lt;span class=&quot;dt&quot;&gt;x0 =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;), 
                &lt;span class=&quot;dt&quot;&gt;y =&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;fun&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;newton&lt;/span&gt;(fun, &lt;span class=&quot;dt&quot;&gt;x0 =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)))

p2 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;p +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;geom_point&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; d, &lt;span class=&quot;kw&quot;&gt;aes&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;x =&lt;/span&gt; x, &lt;span class=&quot;dt&quot;&gt;y =&lt;/span&gt; y, &lt;span class=&quot;dt&quot;&gt;frame =&lt;/span&gt; label)) +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;geom_text&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; d, &lt;span class=&quot;kw&quot;&gt;aes&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;x =&lt;/span&gt; x, &lt;span class=&quot;dt&quot;&gt;y =&lt;/span&gt; y +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;label =&lt;/span&gt; label, &lt;span class=&quot;dt&quot;&gt;frame =&lt;/span&gt; label), &lt;span class=&quot;dt&quot;&gt;size =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;)

p2&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/netwon_raphson_1.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;총 12번의 반복을 통해 &lt;span class=&quot;math inline&quot;&gt;&lt;em&gt;x&lt;/em&gt; = −1.259921&lt;/span&gt; 에 가까워 지는것을 볼 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;ggplot2-에-gganimate-패키지-조합하여-시뮬레이션-시각화-하기&quot;&gt;ggplot2 에 gganimate 패키지 조합하여 시뮬레이션 시각화 하기&lt;/h2&gt;
&lt;p&gt;(개발단계로써 CRAN 에 등록되지 않은) &lt;a href=&quot;https://github.com/dgrtwo/gganimate&quot;&gt;gganimate package&lt;/a&gt;는&lt;br /&gt;
ggplot2 결과물을 프레임별로 만들어 에니메이션 그림파일을 만들어주는 재미있는 R package 이다.&lt;br /&gt;
ggplot2 문법규칙을 그대로 이용하는데 에스테틱에 &lt;code&gt;frame&lt;/code&gt; 인자를 지정하기만 하면 된다.&lt;/p&gt;
&lt;p&gt;gganimate package 설치는 &lt;code&gt;install_github()&lt;/code&gt; 를 이용한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;devtools::&lt;span class=&quot;kw&quot;&gt;install_github&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;dgrtwo/gganimate&amp;quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(gganimate)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;그리고 위에서 시각화한 &lt;code&gt;p2&lt;/code&gt; 를 재활용 한다.&lt;br /&gt;
&lt;code&gt;gganimate()&lt;/code&gt; 함수에 우선 입력해 보면&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;gganimate&lt;/span&gt;(p2)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/netwon_raphson_gif.gif&quot;&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;애니메이션 gif 가 잘 출력되는데 &lt;code&gt;p2&lt;/code&gt; 에 실은 frame 에스테틱을 미리 선언했기 때문이다.&lt;br /&gt;
입력될 ggplot 객체에 frame 에스테틱이 없을 경우 &lt;code&gt;gganimate(p2)&lt;/code&gt; 은 에러를 내며 수행되지 않는다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Error in gganimate(p2) : 
  No frame aesthetic found; cannot create animation&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;?gganimate()&lt;/code&gt; 를 실행해 다양한 옵션과 예제코드를 살펴보면 좋을 것이다.&lt;br /&gt;
gganimate package 에는 &lt;code&gt;saveVideo()&lt;/code&gt;, &lt;code&gt;saveGIF()&lt;/code&gt; 함수가 &lt;code&gt;gganimate()&lt;/code&gt; 함수에 연루되어 있으며,&lt;br /&gt;
비디오 파일을 만들거나 에니메이션 gif 파일을 만들 때 &lt;a href=&quot;http://ffmpeg.org/documentation.html&quot;&gt;ffmpeg&lt;/a&gt; 를 이용한 다양한 옵션들을 부여할 수 있음을 확인할 수 있을것이다.&lt;/p&gt;
</description>
        <pubDate>Tue, 24 Apr 2018 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/data_visualization/2018/04/24/netwon_raphson_method.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/data_visualization/2018/04/24/netwon_raphson_method.html</guid>
        
        
        <category>R</category>
        
        <category>Data_Visualization</category>
        
      </item>
    
      <item>
        <title>Docker 를 통해 Cloudera Manager 띄워보기</title>
        <description>&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://kr.cloudera.com/products/product-components/cloudera-manager.html&quot;&gt;Cloudera Manager&lt;/a&gt;(이하 CM) 실습환경을 구성하기 위해 &lt;a href=&quot;https://www.virtualbox.org/&quot;&gt;Virtual Box&lt;/a&gt; 로 CentOS 설치 및 환경설정 구성을 수차례 반복하여 힘겹게 성공 후&lt;br /&gt;
이 성공을 쉽게 재활용하기 위해 스냅샷을 저장했던 어느 날 내 맥북의 물리적 용량이 바닥이 나버렸다..&lt;br /&gt;
물리적 용량도 용량이지만 가상머신 3대를 켜 놓고 소프트웨어를 배포하는 과정 중에서 내 맥북은 한계에 도달했는지 자주 멈추어 버렸다.&lt;br /&gt;
결국은 Docker를 이용하겠어! 라는 결심과 동시에 행동으로 옮겼다.&lt;br /&gt;
약 30분&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;만에 Docker 를 통해 Cloudera Manager 을 실행시키는 데 성공했다.&lt;br /&gt;
Virtual Box 로 교재에 똑같이 따라 해서 띄우는 데는 순수하게 10시간 정도의 시행착오를 겪은 것 에 비하면 정말 순식간이었다. (물론 이런 삽질이 있었기에 Docker 에서 30분밖에 안 걸린 것일 수 있다 &lt;i class=&quot;fa fa-meh-o&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;;)&lt;/p&gt;
&lt;p&gt;필자와 같이 실습을 진행하는 분께도 온전히 30 분만에 CM 환경구성을 할 수 있도록 본 글을 통해 정리하고자 한다.&lt;br /&gt;
또한 내용들의 대부분은 &amp;quot;cloudera manager on docker&amp;quot; 라는 검색어로 구글에 검색된 글들에 기반함을 밝힌다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;(단 Datanode 를 늘리는 확장성을 고려한 실습은 이 글에서는 논외이다. 오직 CM 를 띄우고 이를 통해 할 수 있는 것들이 무엇이 있는지, 인터페이스는 어떠한지 입문자용으로써 공부를 위한 환경구성이 목적이기에 Datanode 의 선형확장까지를 고려한 실습이라면 내생각엔 Cloudera QuickStart 컨테이너를 이용한 본 글보단 VM 을 통해 실제로 Datanode 로 할당할 서버를 만들어 실습하는 것이 손에 더 잘 잡히고 직관적이며, 선형확장을 하기위한 원리와 과정 자체를 익힐 필요가 있다고 생각한다)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;필요-요건&quot;&gt;필요 요건&lt;/h2&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;Docker 설치가 되어있어야 한다.&lt;/li&gt;
&lt;li&gt;online 상태이어야 한다. (인터넷이 되어야 한다)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;분의-과정&quot;&gt;30분의 과정&lt;/h2&gt;
&lt;p&gt;Cloudera 에서는 docker container 를 통해 CM 을 띄우기 위한 &lt;a href=&quot;https://www.cloudera.com/documentation/enterprise/5-6-x/topics/quickstart_docker_container.html&quot;&gt;Cloudera QuickStart 문서&lt;/a&gt;를 제공해 주고 있다.&lt;br /&gt;
그대로 따라해 본 걸 한글화 시킨 것으로 이글을 봐도 무방하겠다.&lt;/p&gt;
&lt;h3 id=&quot;첫-번째로-터미널을-킨-후&quot;&gt;첫 번째로 터미널을 킨 후&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;docker pull cloudera/quickstart:latest&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;를 통해 Cloudera QuickStart 도커이미지 최신버전을 다운로드 한다.&lt;br /&gt;
필자의 환경에선 수십분의 시간이 걸렸으니 차분히 기다린다.&lt;br /&gt;
완료가 되었다면&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker images&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;를 실행해 Cloudera QuickStart docker image 가 준비되었는지 한번 확인해 본다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;script src=&quot;https://asciinema.org/a/177648.js&quot; id=&quot;asciicast-177648&quot; async&gt;&lt;/script&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;cloudera/quickstart 이미지의 ID 는 4239cd2958c6, 이미지 용량은 6.34Gb 임을 확인할 수 있다.&lt;/p&gt;
&lt;h3 id=&quot;두-번째로-컨테이너를-실행한다&quot;&gt;두 번째로 컨테이너를 실행한다&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;docker run --hostname=quickstart.cloudera --privileged=true -t -i [OPTIONS] [IMAGE] /usr/bin/docker-quickstart&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;에서 &lt;code&gt;[OPTIONS]&lt;/code&gt; 부분은 &lt;code&gt;-p 80:80 -p 7180:7180 -p 8888:8888&lt;/code&gt; 로 입력해 호스트간의 포트번호 80, 7180, 8888 을 열어 놓는다.&lt;br /&gt;
&lt;code&gt;[IMAGE]&lt;/code&gt; 부분은 이미지 ID 인 &lt;code&gt;4239cd2958c6&lt;/code&gt; 를 입력한다. 즉&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run --hostname=quickstart.cloudera --privileged=true -t -i -p 80:80 -p 7180:7180 -p 8888:8888 4239cd2958c6 /usr/bin/docker-quickstart&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;를 터미널에서 실행한다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;script src=&quot;https://asciinema.org/a/177651.js&quot; id=&quot;asciicast-177651&quot; async&gt;&lt;/script&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;이후 localhost 의 80번 포트로 접속&lt;a href=&quot;#fn2&quot; class=&quot;footnoteRef&quot; id=&quot;fnref2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;을 웹브라우저에서 해보면 &amp;quot;Welcome to Your Cloudera QuickStart VM!&amp;quot; page 가 반기게 되며, 8888번 포트로는 Hue가 뜨는것을 볼 수 있다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/docker_cm05.png&quot;&gt;
&lt;/center&gt;
&lt;br&gt; &lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/docker_cm06.png&quot;&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;그런데 그것보단 내 관심사는 7180번 포트인데 CM 이 디폴트로 사용하는 포트번호이다.&lt;br /&gt;
하지만 접속을 해보면 이렇게 뜬다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/docker_cm01.png&quot;&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;clouder quickstart 컨테이너는 기본적으로 CM 을 같이 실행하지 않는다고 한다. 따라서&lt;/p&gt;
&lt;h2 id=&quot;세-번째로-clouder-quickstart-컨테이너상에서-homeclouderacloudera-manager---express-명령을-입력하여-cm-을-실행시킨다&quot;&gt;세 번째로 clouder quickstart 컨테이너상에서 &lt;code&gt;/home/cloudera/cloudera-manager --express&lt;/code&gt; 명령을 입력하여 CM 을 실행시킨다&lt;/h2&gt;
&lt;p&gt;Cloudera QuickStart 컨테이너의 bash 에서 아직 빠져나오지 않았다면 &lt;code&gt;/home/cloudera/cloudera-manager --express&lt;/code&gt; 를 그대로 실행시키면 되고&lt;/p&gt;
&lt;p&gt;컨테이너 밖으로 빠져나온 호스트 상의 상태라면 &lt;code&gt;docker ps&lt;/code&gt; 를 통해 실행되고 있는 clouder quickstart 컨테이너 ID 를 알아낸 후 docker 의 exec 명령을 이처럼 이용해도 된다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker exec [CONTAINER_ID] /home/cloudera/cloudera-manager --express&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;[CONTAINER_ID]&lt;/code&gt; 이 부분을 clouder quickstart 컨테이너 ID 를 입력하면 된다.&lt;br /&gt;
여하튼 그 결과는 아래와 같이 진행된다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;script src=&quot;https://asciinema.org/a/177654.js&quot; id=&quot;asciicast-177654&quot; async&gt;&lt;/script&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;약간의 시간이 걸린다.&lt;br /&gt;
접속 계정과 비밀번호는 cloudera 이다라는 문구가 뜨면 로컬호스트의 7180 포트로 접속시 CM 로그인 화면을 볼 수 있게 된다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/docker_cm02.png&quot;&gt;
&lt;/center&gt;
&lt;br&gt; &lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/docker_cm03.png&quot;&gt;
&lt;/center&gt;
&lt;br&gt; &lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/docker_cm04.png&quot;&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://youtu.be/elXTmZbNNmE&quot;&gt;Cloudera QuickStart - Installation Using Docker Container on Ubuntu - Part 1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://youtu.be/mqFizIPJl1c&quot;&gt;Cloudera QuickStart - Starting Cloudera Manager on already running Docker Container - Part 2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;이 30분 중에서도 docker image 를 pull(다운로드) 하는 데에 20분 정도가 걸렸으므로 10분의 고민만 필요했다고 볼 수 있다&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn2&quot;&gt;&lt;p&gt;&lt;code&gt;http://127.0.0.1:80/&lt;/code&gt; 주소로 접속&lt;a href=&quot;#fnref2&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Sun, 22 Apr 2018 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/docker/mac/opensource_tool/2018/04/22/docker_CM.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/docker/mac/opensource_tool/2018/04/22/docker_CM.html</guid>
        
        
        <category>Docker</category>
        
        <category>Mac</category>
        
        <category>OpenSource_Tool</category>
        
      </item>
    
      <item>
        <title>Mac OS X 에서 hosts 를 추가하려면?</title>
        <description>&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;최근 &lt;a href=&quot;http://kr.cloudera.com/products/product-components/cloudera-manager.html&quot;&gt;Cloudera Manager&lt;/a&gt;를 사용해 보기 위하여 &lt;a href=&quot;https://www.virtualbox.org/&quot;&gt;Virtual Box&lt;/a&gt;를 통해 가상머신들을 준비 후 CDH(Cloudera Distribution Hadoop)를 이용해 Hadoop 및 빅데이터 소프트웨어를 배포 ・ 설치를 진행중이다.&lt;br /&gt;
그 과정중 호스트에서 가상머신에 돌아가고 있는 클라우데라 웹 클라이언트 접속을 시도하면 되는데&lt;br /&gt;
그 전에 로컬상 가상머신의 접속이 IP address 뿐만 아니라 도메인 주소로도 원활하도록 호스트를 등록해야 하는 과정이 필요했다.&lt;/p&gt;
&lt;p&gt;참고하는 교재&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;에선 윈도우를 기준으로 설명하고 있어서 Mac OS X 에서는 어떻게 하는지 궁금했는데&lt;br /&gt;
찾아보니 방법은 아래와 같았다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;script src=&quot;https://asciinema.org/a/176946.js&quot; id=&quot;asciicast-176946&quot; async&gt;&lt;/script&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;이처럼 Mac OS X 에서 hosts 정보를 가지고 있는 파일은 &lt;code&gt;/private/etc/hosts&lt;/code&gt; 이다.&lt;br /&gt;
이쪽에 등록, 수정하고 싶은 host 에 대한 정보를 편집한 후 재부팅(&lt;code&gt;reboot&lt;/code&gt;) 하면 된다.&lt;/p&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;&lt;a href=&quot;http://book.naver.com/bookdb/book_detail.nhn?bid=12545645&quot;&gt;실무로 배우는 빅데이터 기술 - 김강원 저&lt;/a&gt;&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Wed, 18 Apr 2018 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/mac/2018/04/18/mac_hosts.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/mac/2018/04/18/mac_hosts.html</guid>
        
        
        <category>Mac</category>
        
      </item>
    
      <item>
        <title>R에서 sp package 의 proj4string(), spTransform() 함수를 이용한 좌표계 변환 예제</title>
        <description>&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;GIS 기반의 프로젝트를 수행중에 있는 어느 날&lt;br /&gt;
어떤 특정한 위경도 좌표가 입력될 때 대한민국의 시군구 중 어디인지를 알려주는 함수를 필요로 하게 되었다.&lt;br /&gt;
API 기반의 서비스를 이용하지 않고 순수 로직에 의해 만드는것을 목표로 하고 있어 다양한 요소에 개발을 필요로 하고 있는데&lt;br /&gt;
큼지막한 요소로는 2가지 미션들이 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;좌표계의 통일을 위한 변환방법&lt;/li&gt;
&lt;li&gt;특정 (x, y) 좌표가 시군구 경계에 해당하는 컨백스홀 안에있는지 밖에있는지를 판단하는 논리 - &lt;em&gt;추후 포스팅 예정&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 중 첫번째 &lt;strong&gt;좌표계의 통일을 위한 변환방법&lt;/strong&gt;을 R의 sp 패키지를 기반으로 알아보고자 한다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/proj4string1.jpg&quot;&gt;
&lt;/center&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.biz-gis.com/index.php?mid=pds&amp;amp;document_srl=67326&quot;&gt;우리나라에서 사용하는 좌표계의 종류&lt;/a&gt; - 출처 : biz-gis.com&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;del&gt;
복잡복잡..
&lt;/del&gt;
&lt;p&gt;GIS에 대해서 1도 몰랐던 시절 좌표계의 종류가 이렇게 많은지 모르고 있었다.&lt;br /&gt;
더군다나 실제 GIS 데이터들은 이런 좌표단위들을 다양하게 사용하고 있어서 혼란이 많았다.&lt;/p&gt;
&lt;p&gt;예를 들면 이렇다.&lt;br /&gt;
서울의 광화문 중앙의 좌표를 &lt;code&gt;(위도,경도)&lt;/code&gt;&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; 라고 할 때&lt;br /&gt;
A 테이블에선 &lt;code&gt;(37.5760336, 126.9769142)&lt;/code&gt; 로 사용중이고&lt;br /&gt;
B 테이블에선 &lt;code&gt;(37.5749854, 126.9746067)&lt;/code&gt; 로 관리가 되고 있다.&lt;br /&gt;
미세한 차이로 보이지만 실제로 이 위경도값을 그대로 구글지도에 입력하여 찾아보면 멀리 떨어진 지점이다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/proj4string3.png&quot;&gt;
&lt;/center&gt;
&lt;blockquote&gt;
&lt;p&gt;Google Map 에서 A 테이블의 &lt;code&gt;(37.5760336, 126.9769142)&lt;/code&gt; 를 찍어 보았을 때&lt;/p&gt;
&lt;/blockquote&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/proj4string4.png&quot;&gt;
&lt;/center&gt;
&lt;blockquote&gt;
&lt;p&gt;Google Map 에서 B 테이블의 &lt;code&gt;(37.5749854, 126.9746067)&lt;/code&gt; 를 찍어 보았을 때&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이런 예제처럼 A테이블 정보와 B테이블의 정보를 매쉬업 하기 위해선 단위를 통일하여야 매쉬업 할 때 왜곡되어지지 않는다.&lt;br /&gt;
자연스럽게 A, B중 하나는 좌표계를 변환할 필요가 생기는데 이 시점에서&lt;br /&gt;
R에서 sp package 를 이용한 좌표계 변환 성공예제를 정리하고 공유하고자 한다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;행정경계-자료-획득---시군구-별-경계&quot;&gt;행정경계 자료 획득 - 시군구 별 경계&lt;/h2&gt;
&lt;p&gt;시군구를 구분짓는 경계에 대한 데이터 베이스가 필요했는데&lt;br /&gt;
이 데이터는 구했지만 여기서 부터 문제가 있었다.&lt;br /&gt;
필자에게 익숙한 경위도 지리좌표계가 아닌 다른 단위의 좌표계로 관리가 되고 있다는 점이었다.&lt;br /&gt;
문제의 시군구별 행정경계 데이터는 http://www.biz-gis.com/GISDB/ 에서 제공하고 있다.&lt;br /&gt;
다운로드 하는 방법은 http://www.biz-gis.com/GISDB/ 로 들어간 후 &amp;quot;행정경계-시군구&amp;quot; 항목을 클릭하여 다운로드 버튼을 누르면 된다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/proj4string2.png&quot;&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&amp;quot;vADM2_TM.zip&amp;quot; 이라는 압축파일이 다운로드가 되고, 압축을 풀면 아래와 같은 파일들이 떨어진다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;v시군구_TM.dbf&amp;quot; &amp;quot;v시군구_TM.sbn&amp;quot; &amp;quot;v시군구_TM.sbx&amp;quot; &amp;quot;v시군구_TM.shp&amp;quot;
## [5] &amp;quot;v시군구_TM.shx&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;행정경계정보가 담긴 이 5개 파일을 R에서 불러와 분석을 하기 위해 &lt;code&gt;rgdal::readOGR()&lt;/code&gt; 함수를 이용한다. &lt;a href=&quot;#fn2&quot; class=&quot;footnoteRef&quot; id=&quot;fnref2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(rgdal)
d &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;readOGR&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;data&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## OGR data source with driver: ESRI Shapefile 
## Source: &amp;quot;/Users/lovetoken/Dropbox/02_Study/01_Statistic/31_R/03_Posting/02_Package/sp/proj4string/data&amp;quot;, layer: &amp;quot;v시군구_TM&amp;quot;
## with 232 features
## It has 4 fields&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;readOGR()&lt;/code&gt; 함수의 사용법은 .shp 포맷을 포함한 기하정보들을 모두 가진 디렉토리를 첫번째 인자에 입력하면 된다.&lt;br /&gt;
만약 입력한 디렉토리 안에 &amp;quot;vADM2_TM.zip&amp;quot; 파일을 압축해제한 5개 파일 외에 다른 레이어 파일들이 있을때는 무엇을 기준으로 읽어들일지 알 수 없으므로 두번째 &lt;code&gt;layer&lt;/code&gt; 인자에 명시하여 알려 줄 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;d &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;readOGR&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;data&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;v시군구_TM&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;readOGR()&lt;/code&gt; 함수를 통해 불러온 객체 &lt;code&gt;d&lt;/code&gt; 를 &lt;code&gt;axes = T&lt;/code&gt; 를 통해 축을 표현시켜 무작정 플롯팅을 시켜보면 아래와 같이 뜬다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(d, &lt;span class=&quot;dt&quot;&gt;axes =&lt;/span&gt; T)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/proj4string5.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;시군구 경계가 구분되어 있는 대한민국 지도가 그려지는 것을 확인할 수 있다.&lt;br /&gt;
&lt;code&gt;plot()&lt;/code&gt; 함수를 실행할 때 x, y 점들을 포인팅 하는 원리로써 이런 지도가 그려지는것은&lt;br /&gt;
&lt;code&gt;d&lt;/code&gt; 객체 안에 경계선에 대해서 수많은 경계점들의 좌표정보를 가지고 있기 때문이란 것을 추측할 수 있고&lt;br /&gt;
직접 까보면 그 실체를 알 수 있게 된다. &lt;code&gt;str(d)&lt;/code&gt; 출력의 일부(tail)를 확인해 보면&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;str&lt;/span&gt;(d)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;  .. .. .. .. ..$ :Formal class &amp;#39;Polygon&amp;#39; [package &amp;quot;sp&amp;quot;] with 5 slots
  .. .. .. .. .. .. ..@ labpt  : num [1:2] 179310 418281
  .. .. .. .. .. .. ..@ area   : num 4775
  .. .. .. .. .. .. ..@ hole   : logi FALSE
  .. .. .. .. .. .. ..@ ringDir: int 1
  .. .. .. .. .. .. ..@ coords : num [1:26, 1:2] 179312 179320 179328 179337 179341 ...
  .. .. .. .. ..$ :Formal class &amp;#39;Polygon&amp;#39; [package &amp;quot;sp&amp;quot;] with 5 slots
  .. .. .. .. .. .. ..@ labpt  : num [1:2] 179400 418308
  .. .. .. .. .. .. ..@ area   : num 1161
  .. .. .. .. .. .. ..@ hole   : logi FALSE
  .. .. .. .. .. .. ..@ ringDir: int 1
  .. .. .. .. .. .. ..@ coords : num [1:24, 1:2] 179420 179419 179420 179414 179410 ...
  .. .. .. .. ..$ :Formal class &amp;#39;Polygon&amp;#39; [package &amp;quot;sp&amp;quot;] with 5 slots
  .. .. .. .. .. .. ..@ labpt  : num [1:2] 179184 418418
  .. .. .. .. .. .. ..@ area   : num 3849
  .. .. .. .. .. .. ..@ hole   : logi FALSE
  .. .. .. .. .. .. ..@ ringDir: int 1
  .. .. .. .. .. .. ..@ coords : num [1:25, 1:2] 179181 179168 179160 179159 179152 ...
  .. .. .. .. ..$ :Formal class &amp;#39;Polygon&amp;#39; [package &amp;quot;sp&amp;quot;] with 5 slots
  .. .. .. .. .. .. ..@ labpt  : num [1:2] 176061 418565
  .. .. .. .. .. .. ..@ area   : num 9792
  .. .. .. .. .. .. ..@ hole   : logi FALSE
  .. .. .. .. .. .. ..@ ringDir: int 1
  .. .. .. .. .. .. ..@ coords : num [1:39, 1:2] 176124 176126 176117 176108 176099 ...
  .. .. .. .. ..$ :Formal class &amp;#39;Polygon&amp;#39; [package &amp;quot;sp&amp;quot;] with 5 slots
  .. .. .. .. .. .. ..@ labpt  : num [1:2] 178754 418658
  .. .. .. .. .. .. ..@ area   : num 9316
  .. .. .. .. .. .. ..@ hole   : logi FALSE
  .. .. .. .. .. .. ..@ ringDir: int 1
  .. .. .. .. .. .. ..@ coords : num [1:37, 1:2] 178730 178736 178751 178760 178761 ...
  .. .. .. .. ..$ :Formal class &amp;#39;Polygon&amp;#39; [package &amp;quot;sp&amp;quot;] with 5 slots
  .. .. .. .. .. .. ..@ labpt  : num [1:2] 171224 419615
  .. .. .. .. .. .. ..@ area   : num 1090438
  .. .. .. .. .. .. ..@ hole   : logi FALSE
  .. .. .. .. .. .. ..@ ringDir: int 1
  .. .. .. .. .. .. ..@ coords : num [1:31, 1:2] 170917 170743 170551 170426 170368 ...
  .. .. .. .. ..$ :Formal class &amp;#39;Polygon&amp;#39; [package &amp;quot;sp&amp;quot;] with 5 slots
  .. .. .. .. .. .. ..@ labpt  : num [1:2] 176879 420421
  .. .. .. .. .. .. ..@ area   : num 558583
  .. .. .. .. .. .. ..@ hole   : logi FALSE
  .. .. .. .. .. .. ..@ ringDir: int 1
  .. .. .. .. .. .. ..@ coords : num [1:47, 1:2] 177012 177056 177119 177237 177352 ...
  .. .. .. .. ..$ :Formal class &amp;#39;Polygon&amp;#39; [package &amp;quot;sp&amp;quot;] with 5 slots
  .. .. .. .. .. .. ..@ labpt  : num [1:2] 188820 407056
  .. .. .. .. .. .. ..@ area   : num 692251527
  .. .. .. .. .. .. ..@ hole   : logi FALSE
  .. .. .. .. .. .. ..@ ringDir: int 1
  .. .. .. .. .. .. ..@ coords : num [1:5345, 1:2] 191196 191278 191338 191358 191399 ...
  .. .. .. ..@ plotOrder: int [1:29] 29 14 1 27 28 17 20 7 16 2 ...
  .. .. .. ..@ labpt    : num [1:2] 188820 407056
  .. .. .. ..@ ID       : chr &amp;quot;97&amp;quot;
  .. .. .. ..@ area     : num 697667674
  .. ..$ :Formal class &amp;#39;Polygons&amp;#39; [package &amp;quot;sp&amp;quot;] with 5 slots
  .. .. .. ..@ Polygons :List of 1
  .. .. .. .. ..$ :Formal class &amp;#39;Polygon&amp;#39; [package &amp;quot;sp&amp;quot;] with 5 slots
  .. .. .. .. .. .. ..@ labpt  : num [1:2] 226596 433472
  .. .. .. .. .. .. ..@ area   : num 428700798
  .. .. .. .. .. .. ..@ hole   : logi FALSE
  .. .. .. .. .. .. ..@ ringDir: int 1
  .. .. .. .. .. .. ..@ coords : num [1:5130, 1:2] 233437 233541 233595 233829 233846 ...
  .. .. .. ..@ plotOrder: int 1
  .. .. .. ..@ labpt    : num [1:2] 226596 433472
  .. .. .. ..@ ID       : chr &amp;quot;98&amp;quot;
  .. .. .. ..@ area     : num 428700798
  .. .. [list output truncated]
  ..@ plotOrder  : int [1:232] 113 121 191 116 189 195 117 208 112 199 ...
  ..@ bbox       : num [1:2, 1:2] -11603 -42102 548505 569052
  .. ..- attr(*, &amp;quot;dimnames&amp;quot;)=List of 2
  .. .. ..$ : chr [1:2] &amp;quot;x&amp;quot; &amp;quot;y&amp;quot;
  .. .. ..$ : chr [1:2] &amp;quot;min&amp;quot; &amp;quot;max&amp;quot;
  ..@ proj4string:Formal class &amp;#39;CRS&amp;#39; [package &amp;quot;sp&amp;quot;] with 1 slot
  .. .. ..@ projargs: chr NA&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;quot;sp&amp;quot; 라는 클래스로 관리되는 &lt;code&gt;d&lt;/code&gt; 객체 안에는 coords 라는 속성에 뭔지 모를 수많은 값들이 모여져서 다각형(Polygon)을 구성하게 되는 식이라 추측할 수 있다.&lt;br /&gt;
그런데 플롯팅 된 지도의 x, y 축 단위를 우리에게 낯익은 경위도 지리 좌표계(Geographic Coordinate)로 바꾸려면 어떻게 해야할까?&lt;br /&gt;
지금의 x, y축의 수치를 보면 십만단위 범위값까지 나오는데 이는 구 형의 지구를 평면으로 펼친 후 포인팅하기위한 평면직각좌표계(Projected Coordinate)를 기준으로 측정할 때 나올 수 있는 단위라고 한다.&lt;br /&gt;
필자가 개발하려는 것은 경위도 값(ex. 37.5760336, 126.9769142)이 들어올 때 어떤 시군구에 속하는지를 맵핑하는 함수를 개발하려다 보니 지금 보는 &lt;code&gt;d&lt;/code&gt; 객체의 평면좌표계 값을 경위도 지리좌표계로 변형할 필요가 생긴 것이다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;coordinate-reference-system&quot;&gt;Coordinate Reference System&lt;/h2&gt;
&lt;p&gt;좌표변형을 위해선 두가지를 사전에 알아야 한다.&lt;br /&gt;
from Coordinate Reference System(fromCRS) 과 to Coordinate Reference System(toCRS) 이다.&lt;br /&gt;
좌표계 시스템(CRS)에 대해선 전문적인 지식들이 필요로 하지만 이에 대한 언급을 자세히 하지 않겠다.&lt;a href=&quot;#fn3&quot; class=&quot;footnoteRef&quot; id=&quot;fnref3&quot;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;&lt;br /&gt;
재량을 통해&lt;a href=&quot;#fn4&quot; class=&quot;footnoteRef&quot; id=&quot;fnref4&quot;&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt; fromCRS 를 알아낸 후 그에 맞게 약속된 문법에 맞추어 준비한다.&lt;br /&gt;
본 예제에서는 중부원점 기준 좌표로 명시되어 있어 그에 맞는 CRS 를 준비했다. 참고로 &lt;code&gt;CRS()&lt;/code&gt; 함수를 이용하여 CRS 임을 명시한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;from_crs =&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;CRS&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;+proj=tmerc +lat_0=38 +lon_0=127 +k=1 +x_0=200000 +y_0=500000 +ellps=bessel +units=m&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;문법에 대해서 간단히 아는선에서 이야기하면&lt;br /&gt;
&amp;quot;+proj&amp;quot; 은 투영방법을 명시하는 부분이고&lt;br /&gt;
&amp;quot;+lat_0&amp;quot;, &amp;quot;+lon_0&amp;quot; 은 어떤 포인트를 중심으로 투영했는지&lt;br /&gt;
&amp;quot;+k&amp;quot; 는 구의 이심률&lt;br /&gt;
&amp;quot;ellps&amp;quot; 는 타원체의 규격을 정의하는 파라미터들이라고 한다.&lt;a href=&quot;#fn5&quot; class=&quot;footnoteRef&quot; id=&quot;fnref5&quot;&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;fromCRS 를 명시했으니 toCRS 도 필요하다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;to_crs =&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;CRS&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;경위도 좌표로 바꾸기 위한 toCRS 를 알아낸 후 위처럼 명시했다. fromCRS 과 toCRS 가 준비되었으니 이제 변형만 하면된다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;좌표변형&quot;&gt;좌표변형&lt;/h2&gt;
&lt;p&gt;R의 sp package 에서 &lt;code&gt;proj4string()&lt;/code&gt;, &lt;code&gt;spTransform()&lt;/code&gt; 를 통해 좌표변형을 성공할 수 있었다.&lt;br /&gt;
우선 아까 준비한 fromCRS 정보 &lt;code&gt;from_crs&lt;/code&gt; 를 아래처럼 &lt;code&gt;d&lt;/code&gt; 객체에 반영할 것이다.&lt;br /&gt;
&lt;code&gt;d&lt;/code&gt; 는 sp class 로 coordinate reference 값을 속성으로 따로 관리하는데 &amp;quot;coord. ref.&amp;quot; 부분을 보면 이전에는 &lt;code&gt;NA&lt;/code&gt; 로 알 수 없는 상태이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;d&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## class       : SpatialPolygonsDataFrame 
## features    : 232 
## extent      : -11603.22, 548504.6, -42102, 569052  (xmin, xmax, ymin, ymax)
## coord. ref. : NA 
## variables   : 4
## names       : 광역시코드, 광역시명, 시군구코드, 시군구명 
## min values  :         11,   강원도,       1111,   가평군 
## max values  :         50, 충청북도,       5013,   횡성군&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이를 fromCRS 로 변형한다.&lt;br /&gt;
coordinate reference 값만 변형하기 위해선 &lt;code&gt;proj4string()&lt;/code&gt; 함수를 이용하면 된다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;proj4string&lt;/span&gt;(d) &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;from_crs&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;다시 &lt;code&gt;d&lt;/code&gt;를 조회해보면&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;d&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## class       : SpatialPolygonsDataFrame 
## features    : 232 
## extent      : -11603.22, 548504.6, -42102, 569052  (xmin, xmax, ymin, ymax)
## coord. ref. : +proj=tmerc +lat_0=38 +lon_0=127 +k=1 +x_0=200000 +y_0=500000 +ellps=bessel +units=m 
## variables   : 4
## names       : 광역시코드, 광역시명, 시군구코드, 시군구명 
## min values  :         11,   강원도,       1111,   가평군 
## max values  :         50, 충청북도,       5013,   횡성군&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;coordinate reference 값이 &lt;code&gt;from_crs&lt;/code&gt; 에 담겨있는 string 으로 바뀐것을 확인할 수 있다.&lt;br /&gt;
이 상태에서 &lt;code&gt;spTransform()&lt;/code&gt; 함수를 통해 toCRS 형식으로 변경한다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;d2 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;spTransform&lt;/span&gt;(d, to_crs)
d2&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;## class       : SpatialPolygonsDataFrame 
## features    : 232 

## extent      : 124.5918, 130.9408, 33.11139, 38.61427  (xmin, xmax, ymin, ymax)
## coord. ref. : +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0 
## variables   : 4
## names       : 광역시코드, 광역시명, 시군구코드, 시군구명 
## min values  :         11,   강원도,       1111,   가평군 
## max values  :         50, 충청북도,       5013,   횡성군&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;CRS 를 변경시킨 &lt;code&gt;d2&lt;/code&gt; 객체를 확인해 보면&lt;br /&gt;
coordinate reference 값이 &lt;code&gt;to_crs&lt;/code&gt; string 으로 바뀐것 뿐만 아니라&lt;br /&gt;
extent 에 명시된 xmin, xmax, ymin, ymax 값도 바뀐것을 눈치 챌 수 있을것이다.&lt;br /&gt;
&lt;code&gt;d2&lt;/code&gt;를 이번엔 무작정 플랏팅 해 볼까?&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;plot&lt;/span&gt;(d2, &lt;span class=&quot;dt&quot;&gt;axes =&lt;/span&gt; T)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/proj4string6.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;이로써 경위도 지리좌표계로 변형된 것을 확인할 수 있다.&lt;br /&gt;
sp class 로 이루어진 GIS 테이블들을 좌표통일 후 매쉬업 할 수 있겠다는 생각이 든다.&lt;/p&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;위도와 경도 영어로는 각각 latitude, longitude 이다&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn2&quot;&gt;&lt;p&gt;&lt;code&gt;raster::shapefile()&lt;/code&gt; 를 이용하는 방법도 있다&lt;a href=&quot;#fnref2&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn3&quot;&gt;&lt;p&gt;국내는 TM(Transverse Mercator)좌표계를 대표적으로 사용중&lt;a href=&quot;#fnref3&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn4&quot;&gt;&lt;p&gt;기하정보데이터를 얻을 때 출처를 꼼꼼이 읽어보거나, 그것이 어려울 경우 관리자에게 직접 문의하는 등의... 메타정보를 얻는것이 가장 큰 수고를 필요로 하는듯 하다 😅&lt;a href=&quot;#fnref4&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn5&quot;&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Gi-Seop&quot;&gt;GIS 를 알고계신분&lt;/a&gt;의 도움을 통해 알게 되었다 Thank you&lt;a href=&quot;#fnref5&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
        <pubDate>Sun, 15 Apr 2018 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/data_visualization/2018/04/15/sp_proj4string_spTransform.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/data_visualization/2018/04/15/sp_proj4string_spTransform.html</guid>
        
        
        <category>R</category>
        
        <category>Data_Visualization</category>
        
      </item>
    
      <item>
        <title>R에서 Package란?</title>
        <description>&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;R은 다양한 사용자들의 희망으로 생겨나는 많은 특수한 목적의 로직들과 코드들의 집합을 패키지(Package)라는 형태로 배포한다.&lt;br /&gt;
개발자 및 실무진뿐만 아니라 일반 사용자들도 특정 주제에 대하여 완성도가 높고 설계가 잘된 코드들을 제 3자가 이용하기 쉽도록 패키지란 형태로 배포할 수 있으며, 이 배포가 용이하도록 만든 시스템은 R의 아주 중요한 역할을 하고 있다고 본다.&lt;/p&gt;
&lt;p&gt;패키지 안에는 활용 가능한 함수(function)들과 재현가능연구를 위한 빌트인 예제 데이터셋 객체, 패키지 사용 방법에 대한 개요 및 설명서(Vignette), 함수 도움말(R document) 파일들로 보통 구성되는 편이다.&lt;/p&gt;
&lt;p&gt;패키지의 공유는 &lt;a href=&quot;https://cran.r-project.org/&quot;&gt;CRAN(The Comprehensive R Archive Network)&lt;/a&gt; 을 통해 공유되고 있고,&lt;br /&gt;
현존하는 패키지만 (18년 4월 기준) 12,400개가 있다.&lt;br /&gt;
어떤 패키지들이 CRAN 에 등재되어 있는지 확인하고 싶다면 &lt;code&gt;available.packages()&lt;/code&gt; 함수를 통해 확인이 가능하다.&lt;br /&gt;
이를 통해 확인한 패키지 중 설치를 희망하는 패키지를 발견하였다면, &lt;code&gt;install.packages()&lt;/code&gt; 함수 안에 패키지명을 넣고 실행해 그 패키지를 설치할 수 있다.&lt;br /&gt;
기본적으론 CRAN 서버에서 해당하는 패키지를 찾은 후 다운로드 및 설치를 시작하게 되므로 인터넷 연결이 되어있어야 한다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;패키지-설치방법&quot;&gt;패키지 설치방법&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;install.packages()&lt;/code&gt; 함수를 사용하여 설치하는것이 가장 쉬운 기본 방법이다.&lt;br /&gt;
예를 들어 데이터 시각화에서 대중적으로 이용하는 &lt;a href=&quot;http://ggplot2.tidyverse.org/&quot;&gt;ggplot2&lt;/a&gt; 라는 패키지가 있는데,&lt;br /&gt;
이 패키지를 설치하고 싶다면&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;install.packages&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;ggplot2&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;를 실행하게 되면 아래의 로그와 같이 다운로드 및 설치가 진행된다.&lt;/p&gt;
&lt;center&gt;
&lt;script src=&quot;https://asciinema.org/a/174870.js&quot; id=&quot;asciicast-174870&quot; async&gt;&lt;/script&gt;
&lt;/center&gt;
&lt;p&gt;R studio 에선 설치아이콘을 이용해 설치하는것도 가능하지만&lt;br /&gt;
결국 &lt;code&gt;install.packages(&amp;quot;ggplot2&amp;quot;)&lt;/code&gt; 명령을 실행하는 것과 똑같다.&lt;/p&gt;
&lt;br&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/r_package.png&quot;&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;설치 도입 부분에 CRAN 미러를 선택해 달라는 것은&lt;br /&gt;
&lt;a href=&quot;https://cran.r-project.org/mirrors.html&quot;&gt;수많은 미러 아카이브&lt;/a&gt; 중 어떤 서버를 이용해 다운로드 할 것인지 묻는 것인데, 정확한 버전관리를 필요로 하는 게 아닌 이상&lt;br /&gt;
취향에 맞게 대한민국에 해당되는 미러사이트를 이용하든지 맨 위에 있는 &amp;quot;0-Cloud&amp;quot; 를 선택하고 설치를 진행하자.&lt;/p&gt;
&lt;p&gt;더해서&lt;br /&gt;
설치 과정의 로그 중 에러 및 경고메세지가 출력되면서 설치가 중단될 변수가 있다.&lt;br /&gt;
그때의 로그를 잘 살펴보면 필요로 하는 디펜던시 문제일 경우가 대부분일 것이다.&lt;br /&gt;
이땐 디펜던시에 걸린, 필요로 하는 소프트웨어를 설치 후 패키지 설치를 다시 진행해 보자.&lt;br /&gt;
그래도 문제가 해결이 안될 땐 에러 로그를 그대로 복사해 구글에서 검색되는 Stackoverflow 들의 질문과 답변을 보고 문제를 직접 해결해 보는것이 현명한 방법일 것이다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;설치된-패키지를-사용하기-위한-방법&quot;&gt;설치된 패키지를 사용하기 위한 방법&lt;/h2&gt;
&lt;p&gt;설치가 되어있는 패키지를 실제로 사용하기 위해선 R 세션으로 로드하는 과정이 필요하다.&lt;br /&gt;
마치 패키지란 상자에 담겨있는 내용물을 R에서 사용할 수 있도록 펼쳐놓는 과정으로 필자는 비유하는 편인데&lt;br /&gt;
펼쳐놓는(로드하는) 방법은 대표적으로 &lt;code&gt;library()&lt;/code&gt;, &lt;code&gt;require()&lt;/code&gt; 함수를 이용하는 방법이다.&lt;br /&gt;
관습적으론 &lt;code&gt;library()&lt;/code&gt; 를 R User 는 더 많이 이용하는 편이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(ggplot2)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위의 코드를 실행하게 되면 ggplot2 패키지에 있는 여러 가지 함수들을 사용할 수 있게 된다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;특정-패키지를-공부하고-사용할-때&quot;&gt;특정 패키지를 공부하고 사용할 때&lt;/h2&gt;
&lt;p&gt;패키지는 특정 주제나 도메인에 대해서 특별한 목적으로 만들어진다.&lt;br /&gt;
위에서 예로 들은 ggplot2 패키지의 경우 그래프를 그릴 수 있는 또다른 시스템이며 광범위한 세계이다.&lt;br /&gt;
&amp;quot;ggplot2&amp;quot; 패키지를 로드하는 순간 활성화되는 함수들이 정말 많이 있고(100개 이상) 이를 제대로 활용하기 위해선 이 패키지만의 미니언어를 구사해야 한다.&lt;br /&gt;
즉 패키지라는 상자를 까는 순간 정체를 알 수 없는, 사용법을 모르는 수많은 부품이 펼쳐진 상태로 비유할 수 있다.&lt;br /&gt;
이 도구 모두를 아는 것은 많은 시간이 걸리고, 무엇보다 우리가 현재 필요로 하지 않을 도구일 가능성이 높다.&lt;br /&gt;
따라서 특정 패키지 안에서도 핵심적인 함수와 대표적인 기능들을 추린 후 단계적으로 이해해야 할 필요가 있다.&lt;br /&gt;
이 대표적인 함수를 조금씩 조금씩 이용해 보면서 연계되는 부수적인 함수들의 기능들을 체감하는 방식이 패키지를 처음 만나게 될 때의 좋은 전략이라고 생각하며,&lt;br /&gt;
기능이 많고 부피가 큰 패키지일수록 패키지 개발자는 이러한 점을 고려하여 설계했을 가능성이 높다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://r-pkgs.had.co.nz/intro.html&quot;&gt;R packages by Hadley Wickham&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 07 Apr 2018 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2018/04/07/Rpackage.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2018/04/07/Rpackage.html</guid>
        
        
        <category>R</category>
        
      </item>
    
      <item>
        <title>R에서 조건화 그래프(Conditioning plot) 를 출력하기 위한 ggplot2::faect_wrap(), coplot() 함수에 대하여</title>
        <description>&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;R에서 기본 그래픽스로 제공하는 도구 중&lt;br /&gt;
요인별로 구분된 산점도를 그릴때 심플하게 이용할 수 있는 &lt;code&gt;coplot()&lt;/code&gt; 함수와 ggplot2 package 에서 &lt;code&gt;coplot()&lt;/code&gt; 함수와 비슷한 성격의 &lt;code&gt;faect_wrap()&lt;/code&gt; 함수에 대해 알아보고자 한다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;coplot()&lt;/code&gt; 도움말을 보면 &amp;quot;Conditioning plots&amp;quot; 즉 &amp;quot;조건화 그래프&amp;quot; 라는 제목으로 사용법이 설명되어 있다.&lt;br /&gt;
조건화 그래프는 언제 필요로 할까?&lt;/p&gt;
&lt;p&gt;요인이 많은 데이터들을 산점도를 이용하여 시각화 할 때 분간이 쉽지 않아 요인별 특색을 찾기가 어려운 경우가 있다.&lt;br /&gt;
예시를 통해 설명을 이어가겠다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;ggplot2-package-에서의-faect_wrap-faect_grid-함수&quot;&gt;ggplot2 package 에서의 &lt;code&gt;faect_wrap()&lt;/code&gt;, &lt;code&gt;faect_grid()&lt;/code&gt; 함수&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;p1 &amp;lt;-&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;ggplot&lt;/span&gt;(diamonds, &lt;span class=&quot;kw&quot;&gt;aes&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;x =&lt;/span&gt; carat, &lt;span class=&quot;dt&quot;&gt;y =&lt;/span&gt; price, &lt;span class=&quot;dt&quot;&gt;color =&lt;/span&gt; cut)) +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;geom_point&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;alpha =&lt;/span&gt; .&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;) +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;labs&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;color =&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;&amp;quot;&lt;/span&gt;)

p1&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/coplot1.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;위 산점도를 간단히 설명하면&lt;br /&gt;
세공 상태별 다이아몬드의 가격과, 캐럿(다이아몬드의 무게)의 산점도를 &lt;code&gt;ggplot2::daimonds&lt;/code&gt; 데이터셋을 이용해 출력한 결과이다.&lt;br /&gt;
결과물만을 보았을 때 세공 상태별 가격과, 캐럿의 분포를 뚜렷하게 확인 하기가 쉽지 않다.&lt;br /&gt;
종류가 5가지나 되고 데이터의 수도 많아지면서 난해하진 이 그래프는 캐럿과 가격이 정비례한다는 정보는 인지하기 쉬우나, 세공상태별로 특색의 차이를 인지하기는 매우 어렵다.&lt;/p&gt;
&lt;p&gt;세공상태별로의 특색을 눈으로 확인하고 싶다면 아래처럼 요인별로 산점도를 따로 나누는 것도 좋은 방법일 것이다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;p1 +&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;facet_wrap&lt;/span&gt;(~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;cut, &lt;span class=&quot;dt&quot;&gt;nrow =&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/coplot2.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;첫번째 그래프에서는 알기 쉽지 않던 요인별 분포를 적나라 하게 확인할 수 있게 된다.&lt;br /&gt;
가공상태가 좋지 않은 Fair 군의 다이아몬드 가격분포가 다른 군의 분포와 차이가 조금 있다는것을 첫번째 그래프로는 파악할 수 없었을 것이다.&lt;/p&gt;
&lt;p&gt;요인별로 패널을 나누어 시각화 하는 스킬들은 도구별로 방법은 다르더라도 기본적으로 제공하는 편이며&lt;br /&gt;
위의 예시인 ggplot2 package 에서는 &lt;code&gt;faect_wrap()&lt;/code&gt;, &lt;code&gt;faect_grid()&lt;/code&gt; 함수등을 이용하여 구현이 가능하다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;coplot-함수&quot;&gt;&lt;code&gt;coplot()&lt;/code&gt; 함수&lt;/h2&gt;
&lt;p&gt;ggplot2 package 가 아닌 기본 그래픽스에서 조건화 그래프를 그리려면 아래처럼 &lt;code&gt;coplot()&lt;/code&gt; 함수를 이용하여 간단하게 볼 수 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;coplot&lt;/span&gt;(price ~&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;carat |&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;cut, &lt;span class=&quot;dt&quot;&gt;data =&lt;/span&gt; diamonds)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/coplot3.png&quot; width=&quot;80%&quot; style=&quot;display: block; margin: auto;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;수학에서 조건(given) 을 &amp;quot;bar&amp;quot;(|) 로 표기하는것을 생각하고 formula 를 작성해 이용하면 되겠다.&lt;/p&gt;
</description>
        <pubDate>Mon, 02 Apr 2018 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/data_visualization/2018/04/02/coplot.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/data_visualization/2018/04/02/coplot.html</guid>
        
        
        <category>R</category>
        
        <category>Data_Visualization</category>
        
      </item>
    
      <item>
        <title>Rmarkdown + Shiny + flexdashboard package 의 조합을 통한 대쉬보드 만들기 (네이버 연관검색어를 예제로)</title>
        <description>&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;최근 &lt;a href=&quot;https://lovetoken.gitbooks.io/r-dev-team-open-seminar/content/&quot;&gt;R dev team&lt;/a&gt; 과 세미나를 통해 자발적인 분석 도전과제를 만들고 코워킹을 하고 있다.&lt;br /&gt;
도전과제 중 첫 번째로 나온 결과물이 &lt;a href=&quot;https://lovetoken.gitbooks.io/r-dev-team-open-seminar/content/b3c4-c804-acfc-c81c/b124-c774-bc84-c5f0-ad00-ac80-c0c9-c5b4-cd94-cd9c-c800-c7a5-d504-b85c-adf8-b7a8-b9cc-b4e4-ae30.html&quot;&gt;네이버 연관검색어 추출 프로그램&lt;/a&gt;이다.&lt;br /&gt;
패키지화 하여 한 개의 함수만으로 연관검색어의 결과를 저장하고 표출하며 시각화하였다.&lt;br /&gt;
이어서 R을 모르는 타인에게도 우리가 쉽게 사용토록 해 보고자 shiny application을 만들어 보기로 하였다.&lt;/p&gt;
&lt;p&gt;필자는 정석적인 Shiny app 개발 방법보단 Rmarkdown 과 &lt;a href=&quot;https://rmarkdown.rstudio.com/flexdashboard/&quot;&gt;flexdashboard package&lt;/a&gt;를 조합하여 사용하면&lt;br /&gt;
대쉬보드를 손쉽게 만들 수 있고&lt;br /&gt;
대쉬보드의 특성상 결과물을 최대한 심플하게 만들려 노력할 것이기 때문에&lt;br /&gt;
자연스럽게 개발량도 줄어들 것으로 생각했다.&lt;/p&gt;
&lt;p&gt;개발량이 줄어들면 협업이 쉬워지고 진입장벽도 낮아지기 때문에 초심자와 제 3자에게 흥미를 유도할 수 있을 거라 기대하며&lt;br /&gt;
아래와 같은 영상을 만들어 보았다.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;center&gt;
&lt;iframe width=&quot;90%&quot; height=&quot;400&quot; src=&quot;https://www.youtube.com/embed/UKw1YxQRPes&quot; frameborder=&quot;0&quot; allow=&quot;autoplay; encrypted-media&quot; allowfullscreen&gt;
&lt;/iframe&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt; 참고로 R dev team 은 성과물들을 R code 로 남기려 하고 있고 이를 &lt;a href=&quot;https://github.com/lovetoken/rdevteam&quot;&gt;rdevteam 패키지&lt;/a&gt;로 관리하려 하고 있다.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode r&quot;&gt;&lt;code class=&quot;sourceCode r&quot;&gt;&lt;span class=&quot;kw&quot;&gt;library&lt;/span&gt;(devtools)
&lt;span class=&quot;kw&quot;&gt;install_github&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;lovetoken/rdevteam&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;를 통해서 설치가 가능하며&lt;br /&gt;
현재 이를 설치하면 영상에 있는 &lt;code&gt;naverRelation()&lt;/code&gt; 함수를 이용할 수 있고&lt;br /&gt;
그대로 재현할 수 있을 것이다.&lt;/p&gt;
&lt;p&gt;영상에서 시연되는 코드의 원본은 &lt;a href=&quot;https://raw.githubusercontent.com/lovetoken/flexdashboard_example/master/example.rmd&quot;&gt;이 링크&lt;/a&gt;인 Github 저장소를 통해 확인하거나 다운로드 할 수 있다.&lt;/p&gt;
</description>
        <pubDate>Mon, 19 Mar 2018 00:00:00 +0900</pubDate>
        <link>https://lovetoken.github.io/r/2018/03/19/flexdashboard.html</link>
        <guid isPermaLink="true">https://lovetoken.github.io/r/2018/03/19/flexdashboard.html</guid>
        
        
        <category>R</category>
        
      </item>
    
  </channel>
</rss>
